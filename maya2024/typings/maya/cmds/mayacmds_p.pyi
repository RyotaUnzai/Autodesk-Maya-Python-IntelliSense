from typing import (
    NewType,
    Any
)


boolean = NewType("boolean", bool)
uint = NewType("uint", int)
linear = NewType("linear", int)
angle = NewType("angle", int)
time = NewType("time", int)
floatrange = NewType("floatrange", float)
timerange = NewType("timerange", str)
name = NewType("name", str)
string = NewType("string", str)
script = NewType("script", str)


def paintEffectsDisplay(flagmeshDrawEnable: boolean) -> None:
    """Synopsis:
---
---
 paintEffectsDisplay([meshDrawEnable=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

paintEffectsDisplay is NOT undoable, queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

cmds.paintEffectsDisplay( meshDrawEnable=True )
meshDrawEnabled = cmds.paintEffectsDisplay(query=True, me=True)

---


Flags:
---


---
meshDrawEnable(me): boolean
    properties: create, query
    Set whether mesh draw is enabled on objects

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/paintEffectsDisplay.html 
    """


def pairBlend(flagattribute: string, flaginput1: boolean, flaginput2: boolean, flagnode: string) -> string:
    """Synopsis:
---
---
 pairBlend([attribute=string], [input1=boolean], [input2=boolean], [node=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pairBlend is undoable, queryable, and editable.
Alternatively, the pairBlend command can be used to connect a pairBlend node to connected attributes of a node. The previously existing connections are rewired to input1 of the pairBlend node. Additional connections can then be made manually to input2 of the pairBlend node.

The pairBlend command can also be used to query the inputs to an existing pairBlend node.




Example:
---
import maya.cmds as cmds

Create a pairBlend node and connect sphere1's tx and ty to the pairBlend's input1
cmds.nurbsSphere(n='sphere1')
cmds.pairBlend( nd='sphere1', at=['tx','ty'] )

Query the nodes connected to input1.
---

inputs = cmds.pairBlend('pairBlend1' ,query=True, input1=True)

---
Return:
---


    string: name of pairBlend node

Flags:
---


---
attribute(at): string
    properties: create, multiuse
    The name of the attribute(s) which the blend will drive. This flag is required when creating the blend.

---
input1(i1): boolean
    properties: query
    Returns a string array of the node(s) connected to input 1.

---
input2(i2): boolean
    properties: query
    Returns a string array of the node(s) connected to input 2.

---
node(nd): string
    properties: create
    The name of the node which the blend will drive. This flag is required when creating the blend.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pairBlend.html 
    """


def palettePort(flagactualTotal: int, flagannotation: string, flagbackgroundColor: tuple[float, float, float], flagchangeCommand: script, flagcolorEditable: boolean, flagcolorEdited: script, flagdefineTemplate: string, flagdimensions: tuple[int, int], flagdocTag: string, flagdragCallback: script, flagdropCallback: script, flageditable: boolean, flagenable: boolean, flagenableBackground: boolean, flagenableKeyboardFocus: boolean, flagexists: boolean, flagfullPathName: boolean, flagheight: int, flaghighlightColor: tuple[float, float, float], flaghsvValue: tuple[int, int, float, float, float], flagisObscured: boolean, flagmanage: boolean, flagnoBackground: boolean, flagnumberOfPopupMenus: boolean, flagparent: string, flagpopupMenuArray: boolean, flagpreventOverride: boolean, flagredraw: boolean, flagrgbValue: tuple[int, float, float, float], flagsetCurCell: int, flagstatusBarMessage: string, flagtopDown: boolean, flagtransparent: int, flaguseTemplate: string, flagvisible: boolean, flagvisibleChangeCommand: script, flagwidth: int) -> string:
    """Synopsis:
---
---
 palettePort(
string
    , [actualTotal=int], [annotation=string], [backgroundColor=[float, float, float]], [changeCommand=script], [colorEditable=boolean], [colorEdited=script], [defineTemplate=string], [dimensions=[int, int]], [docTag=string], [dragCallback=script], [dropCallback=script], [editable=boolean], [enable=boolean], [enableBackground=boolean], [enableKeyboardFocus=boolean], [exists=boolean], [fullPathName=boolean], [height=int], [highlightColor=[float, float, float]], [hsvValue=[int, int, float, float, float]], [isObscured=boolean], [manage=boolean], [noBackground=boolean], [numberOfPopupMenus=boolean], [parent=string], [popupMenuArray=boolean], [preventOverride=boolean], [redraw=boolean], [rgbValue=[int, float, float, float]], [setCurCell=int], [statusBarMessage=string], [topDown=boolean], [transparent=int], [useTemplate=string], [visible=boolean], [visibleChangeCommand=script], [width=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

palettePort is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.window()
cmds.frameLayout(labelVisible=0)

create a palette of 20 columns and 15 rows
cmds.palettePort( 'palette', dim=(20, 15) )

select cell ---
30
cmds.palettePort( 'palette', edit=True, scc=30 )

return RGB value for this cell
cmds.palettePort( 'palette', query=True, rgb=True )

make cell ---
100 transparent and blue
cmds.palettePort( 'palette', edit=True, transparent=100, rgb=(100, 0.0, 0.0, 1.0) )
cmds.palettePort( 'palette', edit=True, redraw=True )

returns the current transparent cell (there can be only one)
cmds.palettePort( 'palette', query=True, transparent=True )
cmds.showWindow()

---
Return:
---


    string: The name of the palettePort created

Flags:
---


---
actualTotal(at): int
    properties: create, query
    Set the actual number of palette entries. This number
must be greater than zero, but not be greater than maximum
number of palette entries defined by the dimensions flag.

---
annotation(ann): string
    properties: create, query, edit
    Annotate the control with an extra string value.

---
backgroundColor(bgc): [float, float, float]
    properties: create, query, edit
    The background color of the control. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0.
When setting backgroundColor, the background is automatically
enabled, unless enableBackground is also specified with a false
value.

---
changeCommand(cc): script
    properties: create, edit
    This command string will be executed when a color in the
palette is changed.

---
colorEditable(ced): boolean
    properties: create, query, edit
    If true then the user can modify the current index's color.

---
colorEdited(ce): script
    properties: create, edit
    This command string will be executed when a color in the
palette is edited.

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
dimensions(dim): [int, int]
    properties: create, query
    Set the dimensions of the array.

---
docTag(dtg): string
    properties: create, query, edit
    Add a documentation flag to the control.  The documentation flag
has a directory structure.
(e.g., -dt render/multiLister/createNode/material)

---
dragCallback(dgc): script
    properties: create, edit
    Adds a callback that is called when the middle mouse button
is pressed.  The MEL version of the callback is of the form:

global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods)

The proc returns a string array that is transferred to the drop site.
By convention the first string in the array describes the user settable
message type.  Controls that are application defined drag sources may
ignore the callback. $mods allows testing for the key modifiers CTRL and
SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTRL,
3 == CTRL + SHIFT.

In Python, it is similar, but there are two ways to specify the callback.  The
recommended way is to pass a Python function object as the argument.  In that
case, the Python callback should have the form:

def callbackName( dragControl, x, y, modifiers ):

The values of these arguments are the same as those for the MEL version above.

The other way to specify the callback in Python is to specify a string to be
executed.  In that case, the string will have the values substituted into it
via the standard Python format operator.  The format values are passed in a
dictionary with the keys "dragControl", "x", "y", "modifiers".  The
"dragControl" value is a string and the other values are integers (eg the
callback string could be "print '%(dragControl)s %(x)d %(y)d %(modifiers)d'")

---
dropCallback(dpc): script
    properties: create, edit
    Adds a callback that is called when a drag and drop
operation is released above the drop site.  The MEL version of the callback is
of the form:

global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type)

The proc receives a string array that is transferred from the drag source.
The first string in the msgs array describes the user defined message type.
Controls that are application defined drop sites may ignore the
callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link.

In Python, it is similar, but there are two ways to specify the callback.  The
recommended way is to pass a Python function object as the argument.  In that
case, the Python callback should have the form:

def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ):

The values of these arguments are the same as those for the MEL version above.

The other way to specify the callback in Python is to specify a string to be
executed.  In that case, the string will have the values substituted into it
via the standard Python format operator.  The format values are passed in a
dictionary with the keys "dragControl", "dropControl", "messages", "x", "y",
"type".  The "dragControl" value is a string and the other values are integers
(eg the callback string could be
"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'")

---
editable(ed): boolean
    properties: create, query, edit
    If true then the user can change the current color.

---
enable(en): boolean
    properties: create, query, edit
    The enable state of the control.  By default, this flag is
set to true and the control is enabled.  Specify false and the control
will appear dimmed or greyed-out indicating it is disabled.

---
enableBackground(ebg): boolean
    properties: create, query, edit
    Enables the background color of the control.

---
enableKeyboardFocus(ekf): boolean
    properties: create, query, edit
    If enabled, the user can navigate to the control with the tab key and select values with the keyboard or mouse.
This flag would typically be used to turn off focus support from controls that get it by default, like Edit and List controls.
If disabled, text in text fields can still be selected with the mouse but cannot be copied (except on Linux when "Middle Click Paste" is enabled).

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
fullPathName(fpn): boolean
    properties: query
    Return the full path name of the widget, which includes all the parents.

---
height(h): int
    properties: create, query, edit
    The height of the control.  The control will attempt to
be this size if it is not overruled by parent layout conditions.

---
highlightColor(hlc): [float, float, float]
    properties: create, query, edit
    The highlight color of the control. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0.

---
hsvValue(hsv): [int, int, float, float, float]
    properties: create, query, edit
    Set a color for a given cell, using HSV format. On
query return the color of the current cell.

---
isObscured(io): boolean
    properties: query
    Return whether the control can actually be seen by the user.
The control will be obscured if its state is invisible, if it is
blocked (entirely or partially) by some other control, if it or a
parent layout is unmanaged, or if the control's window is
invisible or iconified.

---
manage(m): boolean
    properties: create, query, edit
    Manage state of the control.  An unmanaged control is
not visible, nor does it take up any screen real estate.  All
controls are created managed by default.

---
noBackground(nbg): boolean
    properties: create, edit
    Clear/reset the control's background.
Passing true means the background should not be drawn at all, false means the background should be drawn.  The state of this flag is inherited by children of this control.

---
numberOfPopupMenus(npm): boolean
    properties: query
    Return the number of popup menus attached to this control.

---
parent(p): string
    properties: create, query
    The parent layout for this control.

---
popupMenuArray(pma): boolean
    properties: query
    Return the names of all the popup menus attached to this
control.

---
preventOverride(po): boolean
    properties: create, query, edit
    If true, this flag prevents overriding the control's
attribute via the control's right mouse button menu.

---
redraw(r): boolean
    properties: create, edit
    Forces a redraw of the array

---
rgbValue(rgb): [int, float, float, float]
    properties: create, query, edit
    Set a color for a given cell, using RGB format. On
query return the color of the current cell.

---
setCurCell(scc): int
    properties: create, query, edit
    Set the current cell in the array to the given
index. Returns the current cell when queried.

---
statusBarMessage(sbm): string
    properties: create, edit
    Extra string to display in the status bar when the mouse is over the control.

---
topDown(td): boolean
    properties: create
    If this flag is true, it indicates that first entry should
appear in top left as opposed to the bottom left.

---
transparent(t): int
    properties: create, query, edit
    Set a given cell to be the transparent color.  A cell value
of -1 indicates that no cell is transparent.  On query returns the
current transparent cell.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

---
visible(vis): boolean
    properties: create, query, edit
    The visible state of the control.  A control is created
visible by default.  Note that a control's actual appearance is
also dependent on the visible state of its parent layout(s).

---
visibleChangeCommand(vcc): script
    properties: create, query, edit
    Command that gets executed when visible state of the control changes.

---
width(w): int
    properties: create, query, edit
    The width of the control.  The control will attempt to
be this size if it is not overruled by parent layout conditions.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/palettePort.html 
    """


def panZoom(flagabsolute: boolean, flagdownDistance: float, flagleftDistance: float, flagrelative: boolean, flagrightDistance: float, flagupDistance: float, flagzoomRatio: float) -> None:
    """Synopsis:
---
---
 panZoom(
[camera]
    , [absolute=boolean], [downDistance=float], [leftDistance=float], [relative=boolean], [rightDistance=float], [upDistance=float], [zoomRatio=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

panZoom is undoable, NOT queryable, and NOT editable.
The panZoom command can be applied to either a perspective or an
orthographic camera.

When no camera name is supplied, this command is applied to the
camera in the active view.




Example:
---
import maya.cmds as cmds

cmds.camera()

cmds.panZoom( 'cameraShape1', d=0.3 )

cmds.panZoom( 'cameraShape1', abs=True, u=0.4 )

cmds.panZoom( 'cameraShape1', z=0.5 )

---


Flags:
---


---
absolute(abs): boolean
    properties: create
    This flag modifies the behavior of the distance and zoomRatio
flags. If specified, the distance and zoomRatio value will be applied
directly.

---
downDistance(d): float
    properties: create
    Set the amount of down pan distance in inches

---
leftDistance(l): float
    properties: create
    Set the amount of left pan distance in inches

---
relative(rel): boolean
    properties: create
    This flag modifies the behavior of the distance and zoomRatio
flags. If specified, the distance or zoomRatio value is used multiply
the camera's existing value. By default the relative flag is always on.

---
rightDistance(r): float
    properties: create
    Set the amount of right pan distance in inches

---
upDistance(u): float
    properties: create
    Set the amount of up pan distance in inches

---
zoomRatio(z): float
    properties: create
    Set the amount of zoom ratio

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/panZoom.html 
    """


def panZoomCtx(flagalternateContext: boolean, flagbuttonDown: boolean, flagbuttonUp: boolean, flagexists: boolean, flaghistory: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flagname: string, flagpanMode: boolean, flagtoolName: string, flagzoomMode: boolean, flagzoomScale: float) -> string:
    """Synopsis:
---
---
 panZoomCtx([alternateContext=boolean], [buttonDown=boolean], [buttonUp=boolean], [exists=boolean], [history=boolean], [image1=string], [image2=string], [image3=string], [name=string], [panMode=boolean], [toolName=string], [zoomMode=boolean], [zoomScale=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

panZoomCtx is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.panZoomCtx( 'panZoomContext', zs=1.0 )

---
Return:
---


    string: The name of the context

Flags:
---


---
alternateContext(ac): boolean
    properties: create, query
    Set the ALT+MMB and ALT+SHIFT+MMB to refer to this context.

---
buttonDown(btd): boolean
    properties: create
    Perform the button down operation

---
buttonUp(btu): boolean
    properties: create
    Perform the button up operation

---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
history(ch): boolean
    properties: create
    If this is a tool command, turn the construction history on
for the tool in question.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
name(n): string
    properties: create
    If this is a tool command, name the tool appropriately.

---
panMode(pm): boolean
    properties: create
    Specify to create a camera 2D pan context, which is the default.

---
toolName(tn): string
    properties: create, query
    Name of the specific tool to which this command refers.

---
zoomMode(zm): boolean
    properties: create
    Specify to create a camera 2D zoom context.

---
zoomScale(zs): float
    properties: create, query, edit
    Scale the zoom. The smaller the scale the slower the drag.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/panZoomCtx.html 
    """


def paneLayout(flagactiveFrameThickness: int, flagactivePane: string, flagactivePaneIndex: int, flagannotation: string, flagbackgroundColor: tuple[float, float, float], flagchildArray: boolean, flagconfiguration: string, flagdefineTemplate: string, flagdocTag: string, flagdragCallback: script, flagdropCallback: script, flagenable: boolean, flagenableBackground: boolean, flagenableKeyboardFocus: boolean, flagexists: boolean, flagfullPathName: boolean, flaggeneralSpacing: int, flagheight: int, flaghighlightColor: tuple[float, float, float], flagisObscured: boolean, flagmanage: boolean, flagmargins: int, flagnoBackground: boolean, flagnumberOfChildren: boolean, flagnumberOfPopupMenus: boolean, flagnumberOfVisiblePanes: boolean, flagpane1: boolean, flagpane2: boolean, flagpane3: boolean, flagpane4: boolean, flagpaneSize: tuple[int, int, int], flagpaneUnderPointer: boolean, flagparent: string, flagpopupMenuArray: boolean, flagpreventOverride: boolean, flagseparatorMovedCommand: script, flagseparatorThickness: int, flagsetPane: tuple[string, int], flagstaticHeightPane: int, flagstaticWidthPane: int, flagstatusBarMessage: string, flaguseTemplate: string, flagvisible: boolean, flagvisibleChangeCommand: script, flagwidth: int) -> string:
    """Synopsis:
---
---
 paneLayout(
[string]
    , [activeFrameThickness=int], [activePane=string], [activePaneIndex=int], [annotation=string], [backgroundColor=[float, float, float]], [childArray=boolean], [configuration=string], [defineTemplate=string], [docTag=string], [dragCallback=script], [dropCallback=script], [enable=boolean], [enableBackground=boolean], [enableKeyboardFocus=boolean], [exists=boolean], [fullPathName=boolean], [generalSpacing=int], [height=int], [highlightColor=[float, float, float]], [isObscured=boolean], [manage=boolean], [margins=int], [noBackground=boolean], [numberOfChildren=boolean], [numberOfPopupMenus=boolean], [numberOfVisiblePanes=boolean], [pane1=boolean], [pane2=boolean], [pane3=boolean], [pane4=boolean], [paneSize=[int, int, int]], [paneUnderPointer=boolean], [parent=string], [popupMenuArray=boolean], [preventOverride=boolean], [separatorMovedCommand=script], [separatorThickness=int], [setPane=[string, int]], [staticHeightPane=int], [staticWidthPane=int], [statusBarMessage=string], [useTemplate=string], [visible=boolean], [visibleChangeCommand=script], [width=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

paneLayout is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.window()
cmds.paneLayout( configuration='quad' )
cmds.button()
cmds.textScrollList( append=['one', 'two', 'three'] )
cmds.scrollField()
cmds.scrollLayout()
cmds.columnLayout()
cmds.button()
cmds.button()
cmds.button()
cmds.showWindow()

---
Return:
---


    string: Full path name to the control.

Flags:
---


---
activeFrameThickness(aft): int
    properties: create, query, edit
    The thickness of the frame drawn around the active frame.
Specify an integer value greater than or equal to 0.

---
activePane(ap): string
    properties: create, query, edit
    The active pane has a colored border surrounding it.  Only
one pane may be active at any one time.  Using either of the
flags -ap/activePane    or -api/activePaneIndex will
automatically deactivate the previously active pane.  The argument
is the full or short name of the child control.

---
activePaneIndex(api): int
    properties: create, query, edit
    The active pane index.  The active pane has a
colored border surrounding it.  Only one pane may be active
at any one time.  Using either of the flags -ap/activePane
or -api/activePaneIndex will automatically deactivate the
previously active pane.  The argument is an integer
value ranging from 1 to 4.  Panes for any particular configuration
are numbered clockwise beginning with the pane in the top left
corner of the layout.  If any other index is specified then the
current active pane is deactivated.

---
annotation(ann): string
    properties: create, query, edit
    Annotate the control with an extra string value.

---
backgroundColor(bgc): [float, float, float]
    properties: create, query, edit
    The background color of the control. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0.
When setting backgroundColor, the background is automatically
enabled, unless enableBackground is also specified with a false
value.

---
childArray(ca): boolean
    properties: query
    Returns a string array of the names of the layout's
immediate children.

---
configuration(cn): string
    properties: create, query, edit
    Set the layout configuration for the panes.  Valid values
are:
"single", "horizontal2", "vertical2", "horizontal3", "vertical3",
"top3", "left3", "bottom3", "right3", "horizontal4", "vertical4",
"top4", "left4", "bottom4", "right4", "quad"

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
docTag(dtg): string
    properties: create, query, edit
    Add a documentation flag to the control.  The documentation flag
has a directory structure.
(e.g., -dt render/multiLister/createNode/material)

---
dragCallback(dgc): script
    properties: create, edit
    Adds a callback that is called when the middle mouse button
is pressed.  The MEL version of the callback is of the form:

global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods)

The proc returns a string array that is transferred to the drop site.
By convention the first string in the array describes the user settable
message type.  Controls that are application defined drag sources may
ignore the callback. $mods allows testing for the key modifiers CTRL and
SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTRL,
3 == CTRL + SHIFT.

In Python, it is similar, but there are two ways to specify the callback.  The
recommended way is to pass a Python function object as the argument.  In that
case, the Python callback should have the form:

def callbackName( dragControl, x, y, modifiers ):

The values of these arguments are the same as those for the MEL version above.

The other way to specify the callback in Python is to specify a string to be
executed.  In that case, the string will have the values substituted into it
via the standard Python format operator.  The format values are passed in a
dictionary with the keys "dragControl", "x", "y", "modifiers".  The
"dragControl" value is a string and the other values are integers (eg the
callback string could be "print '%(dragControl)s %(x)d %(y)d %(modifiers)d'")

---
dropCallback(dpc): script
    properties: create, edit
    Adds a callback that is called when a drag and drop
operation is released above the drop site.  The MEL version of the callback is
of the form:

global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type)

The proc receives a string array that is transferred from the drag source.
The first string in the msgs array describes the user defined message type.
Controls that are application defined drop sites may ignore the
callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link.

In Python, it is similar, but there are two ways to specify the callback.  The
recommended way is to pass a Python function object as the argument.  In that
case, the Python callback should have the form:

def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ):

The values of these arguments are the same as those for the MEL version above.

The other way to specify the callback in Python is to specify a string to be
executed.  In that case, the string will have the values substituted into it
via the standard Python format operator.  The format values are passed in a
dictionary with the keys "dragControl", "dropControl", "messages", "x", "y",
"type".  The "dragControl" value is a string and the other values are integers
(eg the callback string could be
"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'")

---
enable(en): boolean
    properties: create, query, edit
    The enable state of the control.  By default, this flag is
set to true and the control is enabled.  Specify false and the control
will appear dimmed or greyed-out indicating it is disabled.

---
enableBackground(ebg): boolean
    properties: create, query, edit
    Enables the background color of the control.

---
enableKeyboardFocus(ekf): boolean
    properties: create, query, edit
    If enabled, the user can navigate to the control with the tab key and select values with the keyboard or mouse.
This flag would typically be used to turn off focus support from controls that get it by default, like Edit and List controls.
If disabled, text in text fields can still be selected with the mouse but cannot be copied (except on Linux when "Middle Click Paste" is enabled).

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
fullPathName(fpn): boolean
    properties: query
    Return the full path name of the widget, which includes all the parents.

---
generalSpacing(gsp) 2024: int
    properties: edit
    Sets the spacing for this layout.

---
height(h): int
    properties: create, query, edit
    The height of the control.  The control will attempt to
be this size if it is not overruled by parent layout conditions.

---
highlightColor(hlc): [float, float, float]
    properties: create, query, edit
    The highlight color of the control. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0.

---
isObscured(io): boolean
    properties: query
    Return whether the control can actually be seen by the user.
The control will be obscured if its state is invisible, if it is
blocked (entirely or partially) by some other control, if it or a
parent layout is unmanaged, or if the control's window is
invisible or iconified.

---
manage(m): boolean
    properties: create, query, edit
    Manage state of the control.  An unmanaged control is
not visible, nor does it take up any screen real estate.  All
controls are created managed by default.

---
margins(mar) 2024: int
    properties: edit
    Sets the content margins for this layout.

---
noBackground(nbg): boolean
    properties: create, edit
    Clear/reset the control's background.
Passing true means the background should not be drawn at all, false means the background should be drawn.  The state of this flag is inherited by children of this control.

---
numberOfChildren(nch): boolean
    properties: query
    Returns in an int the number of immediate children of the layout.

---
numberOfPopupMenus(npm): boolean
    properties: query
    Return the number of popup menus attached to this control.

---
numberOfVisiblePanes(nvp): boolean
    properties: query
    Return the number of panes visible for the present
configuration.

---
pane4(p4): boolean
    properties: query
    Return the name of the control in the respective pane.

---
paneSize(ps): [int, int, int]
    properties: create, query, edit, multiuse
    The size of a pane in the current pane layout
configuration.  The first argument specifies the pane index and
is an integer value ranging from 1 to 4.  Panes for any particular
configuration are numbered clockwise beginning with the pane in
the top left corner of the layout.  The width and height of the
pane are specified by the last two arguments.  Both are
integer values and they indicate the percentage of the total
pane layout size rather that the number of pixels.

---
paneUnderPointer(pup): boolean
    properties: query
    Return the name of the child occupying the
pane that the pointer is currently over.  An empty string is
returned if the pointer is not over a pane.

---
parent(p): string
    properties: create, query
    The parent layout for this control.

---
popupMenuArray(pma): boolean
    properties: query
    Return the names of all the popup menus attached to this
control.

---
preventOverride(po): boolean
    properties: create, query, edit
    If true, this flag prevents overriding the control's
attribute via the control's right mouse button menu.

---
separatorMovedCommand(smc): script
    properties: create, edit
    This command executed when the pane separators are moved.

---
separatorThickness(st): int
    properties: create, query, edit
    The thickness of the separators between the panes.
Specify an integer value greater than 0. This flag has no effect
on Windows systems.

---
setPane(sp): [string, int]
    properties: create, edit, multiuse
    This flag allows you to put a child of this layout in a
particular pane.  The first argument is the full or short name of
the control.  The second argument is an integer value ranging from
1 to 4.  Panes for any particular configuration are numbered
clockwise beginning with the pane in the top left corner of the
layout.

---
staticHeightPane(shp): int
    properties: create, edit
    Set a pane to have a static height, i.e. its height will not
change when the layout is dynamically resized. Only one pane
can be set to have a static height at one time. This state
will be retained even if another child is switched into the
pane. Specify 0 to set a pane back to the default state. Any
state will be lost if the pane configuration is changed.

---
staticWidthPane(swp): int
    properties: create, edit
    Set a pane to have a static width, i.e. its width will not
change when the layout is dynamically resized. Only one pane
can be set to have a static width at one time. This state
will be retained even if another child is switched into the
pane. Specify 0 to set a pane back to the default state. Any
state will be lost if the pane configuration is changed.

---
statusBarMessage(sbm): string
    properties: create, edit
    Extra string to display in the status bar when the mouse is over the control.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

---
visible(vis): boolean
    properties: create, query, edit
    The visible state of the control.  A control is created
visible by default.  Note that a control's actual appearance is
also dependent on the visible state of its parent layout(s).

---
visibleChangeCommand(vcc): script
    properties: create, query, edit
    Command that gets executed when visible state of the control changes.

---
width(w): int
    properties: create, query, edit
    The width of the control.  The control will attempt to
be this size if it is not overruled by parent layout conditions.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/paneLayout.html 
    """


def panel(flagcontrol: boolean, flagcopy: string, flagcreateString: boolean, flagdefineTemplate: string, flagdocTag: string, flageditString: boolean, flagexists: boolean, flaginit: boolean, flagisUnique: boolean, flaglabel: string, flagmenuBarRepeatLast: boolean, flagmenuBarVisible: boolean, flagneedsInit: boolean, flagparent: string, flagpopupMenuProcedure: script, flagreplacePanel: string, flagtearOff: boolean, flagtearOffCopy: string, flagtearOffRestore: boolean, flagunParent: boolean, flaguseTemplate: string) -> None:
    """Synopsis:
---
---
 panel(
string
    , [control=boolean], [copy=string], [createString=boolean], [defineTemplate=string], [docTag=string], [editString=boolean], [exists=boolean], [init=boolean], [isUnique=boolean], [label=string], [menuBarRepeatLast=boolean], [menuBarVisible=boolean], [needsInit=boolean], [parent=string], [popupMenuProcedure=script], [replacePanel=string], [tearOff=boolean], [tearOffCopy=string], [tearOffRestore=boolean], [unParent=boolean], [useTemplate=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

panel is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

MyLabel = 'My Panel'
cmds.window()
cmds.frameLayout( lv=0 )
cmds.modelPanel( l=MyLabel )
cmds.showWindow()

panels = cmds.getPanel( all=True )

for panel in panels:
        if MyLabel == cmds.panel( panel, q=True, label=True ):
                myPanel = panel
                print( 'Found: '+MyLabel )

---


Flags:
---


---
control(ctl): boolean
    properties: query
    Returns the top level control for this panel.
Usually used for getting a parent to attach popup menus.
CAUTION: panels may not have controls at times.  This
flag can return "" if no control is present.

---
copy(cp): string
    properties: edit
    Makes this panel a copy of the specified panel.  Both
panels must be of the same type.

---
createString(cs): boolean
    properties: edit
    Command string used to create a panel

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
docTag(dtg): string
    properties: create, query, edit
    Attaches a tag to the Maya panel.

---
editString(es): boolean
    properties: edit
    Command string used to edit a panel

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
init(init): boolean
    properties: create, edit
    Initializes the panel's default state.  This is usually done
automatically on file -new and file -open.

---
isUnique(iu): boolean
    properties: query
    Returns true if only one instance of this panel type is allowed.

---
label(l): string
    properties: query, edit
    Specifies the user readable label for the panel.

---
menuBarRepeatLast(mrl): boolean
    properties: create, query, edit
    Controls whether clicking on the menu header with the middle mouse button would repeat the last selected menu item.

---
menuBarVisible(mbv): boolean
    properties: create, query, edit
    Controls whether the menu bar for the panel is displayed.

---
needsInit(ni): boolean
    properties: query, edit
    (Internal) On Edit will mark the panel as requiring initialization.
Query will return whether the panel is marked for initialization.  Used
during file -new and file -open.

---
parent(p): string
    properties: create
    Specifies the parent layout for this panel.

---
popupMenuProcedure(pmp): script
    properties: query, edit
    Specifies the procedure called for building the panel's popup menu(s).
The default value is "buildPanelPopupMenu".  The procedure should take
one string argument which is the panel's name.

---
replacePanel(rp): string
    properties: edit
    Will replace the specified panel with this panel.  If the
target panel is within the same layout it will perform a swap.

---
tearOff(to): boolean
    properties: query, edit
    Will tear off this panel into a separate window with a paneLayout
as the parent of the panel. When queried this flag will return if the
panel has been torn off into its own window.

---
tearOffCopy(toc): string
    properties: create
    Will create this panel as a torn of copy of the specified source panel.

---
tearOffRestore(tor): boolean
    properties: create, edit
    Restores panel if it is torn off and focus is given to it.
If docked, becomes the active panel in the docked window.
This should be the default flag that is added to all panels
instead of -to/-tearOff flag which should only be used to tear off the panel.

---
unParent(up): boolean
    properties: edit
    Specifies that the panel should be removed from its layout.
This (obviously) cannot be used with query.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/panel.html 
    """


def panelConfiguration(flagaddPanel: tuple[boolean, string, string, string, string], flagconfigString: string, flagcreateStrings: boolean, flagdefaultImage: string, flagdefineTemplate: string, flageditStrings: boolean, flagexists: boolean, flagimage: string, flagisFixedState: boolean, flaglabel: string, flaglabelStrings: boolean, flagnumberOfPanels: boolean, flagremoveAllPanels: boolean, flagremoveLastPanel: boolean, flagreplaceCreateString: tuple[int, string], flagreplaceEditString: tuple[int, string], flagreplaceFixedState: tuple[int, boolean], flagreplaceLabel: tuple[int, string], flagreplacePanel: tuple[int, boolean, string, string, string, string], flagreplaceTypeString: tuple[int, string], flagsceneConfig: boolean, flagtypeStrings: boolean, flaguseTemplate: string, flaguserCreated: boolean) -> string:
    """Synopsis:
---
---
 panelConfiguration(
[name]
    , [addPanel=[boolean, string, string, string, string]], [configString=string], [createStrings=boolean], [defaultImage=string], [defineTemplate=string], [editStrings=boolean], [exists=boolean], [image=string], [isFixedState=boolean], [label=string], [labelStrings=boolean], [numberOfPanels=boolean], [removeAllPanels=boolean], [removeLastPanel=boolean], [replaceCreateString=[int, string]], [replaceEditString=[int, string]], [replaceFixedState=[int, boolean]], [replaceLabel=[int, string]], [replacePanel=[int, boolean, string, string, string, string]], [replaceTypeString=[int, string]], [sceneConfig=boolean], [typeStrings=boolean], [useTemplate=string], [userCreated=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

panelConfiguration is undoable, queryable, and editable.
Once a panel configuration is created you can make it appear in the
main Maya window by selecting it from any panel's "Panels->Saved Layouts"
menu.




Example:
---
import maya.cmds as cmds

   Create a custom panel configuration.
---

configName = cmds.panelConfiguration(
                                label="Custom Panel Layout",
                                sceneConfig=False,
                                configString="paneLayout -e -cn \"vertical2\" -ps 1 39 100 -ps 2 61 100 $gMainPane;",
                                addPanel=[
                                        (False,
                                        'Outliner',
                                        'outlinerPanel',
                                        ("{global int $gUseMenusInPanels;\
                                        $panelName = `outlinerPanel -mbv $gUseMenusInPanels -unParent -l \"Outliner\"`;\
                                        outlinerEditor -e -highlightActive true $panelName;}"),
                                        "outlinerPanel -edit -l \"Outliner\"  $panelName"),

                                        (True,
                                        "Persp View",
                                        "modelPanel",
                                        ("{global int $gUseMenusInPanels;\
                                        modelPanel -mbv $gUseMenusInPanels\
                                        -unParent -l \"Persp View\" -cam persp;}" ),
                                        "modelPanel -edit -l \"Persp View\"  -cam \"persp\" $panelName")
                                ]
                        )

   Update the main Maya window to reflect the custom panel configuration.
   Note also that your custom configuration may be selected from any
   panel's "Panels->Saved Layouts" menu.
---

maya.mel.eval('setNamedPanelLayout( "Custom Panel Layout" )')

---
Return:
---


    string: The name of the panelConfiguration created.

Flags:
---


---
addPanel(ap): [boolean, string, string, string, string]
    properties: create, edit, multiuse
    Adds the specified panel to the configuration.  Arguments are:
isFixed, label string, type string, create string, edit string.

---
configString(cfs): string
    properties: create, query, edit
    Specifies the string that arranges the panels.

---
createStrings(cs): boolean
    properties: query
    Returns an string array of the panel creation strings.

---
defaultImage(di): string
    properties: create, query
    The default image for this configuration. Once the default image
is set it may not be changed. If an image is set with the -i/image
flag then it's value will take precedence.

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
editStrings(es): boolean
    properties: query
    Returns an string array of the panel edit strings.

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
image(i): string
    properties: create, query, edit
    The user specified image for this configuration. Use this flag
to override the default image.

---
isFixedState(isFixedState): boolean
    properties: query
    Returns an integer array of whether the panels have fixed states or not.

---
label(l): string
    properties: create, query, edit
    Configuration label.

---
labelStrings(ls): boolean
    properties: query
    Returns an string array of the panel labels.

---
numberOfPanels(np): boolean
    properties: query
    Returns the number of panels in the configuration.

---
removeAllPanels(rap): boolean
    properties: edit
    Removes the last panel in the config.

---
removeLastPanel(rlp): boolean
    properties: edit
    Removes the last panel in the config.

---
replaceCreateString(rcs): [int, string]
    properties: edit
    Replaces the specified create string.  The index is 1 based.

---
replaceEditString(res): [int, string]
    properties: edit
    Replaces the specified edit string.  The index is 1 based.

---
replaceFixedState(rfs): [int, boolean]
    properties: edit
    Replaces the specified fixed state value (true|false).  The index is 1 based.

---
replaceLabel(rl): [int, string]
    properties: edit
    Replaces the specified label.  The index is 1 based.

---
replacePanel(rp): [int, boolean, string, string, string, string]
    properties: create, edit
    Replaces the specified panel in the configuration.  Arguments are:
index, isFixed, label string, type string, create string, edit string.
The index is 1 based.

---
replaceTypeString(rts): [int, string]
    properties: edit
    Replaces the specified type string.  The index is 1 based.

---
sceneConfig(sc): boolean
    properties: create, query, edit
    Specifies whether the configuration is associated with the scene.
Scene configurations are created when the scene is opened and deleted when
the scene is closed.

---
typeStrings(ts): boolean
    properties: query
    Returns an string array of the panel types.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

---
userCreated(uc): boolean
    properties: create, query, edit
    Returns true if the configuration was created by the user. If it is user created, the configuration will show up in the RMB menu in the toolbox's saved layouts.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/panelConfiguration.html 
    """


def panelHistory(flagback: boolean, flagclear: boolean, flagdefineTemplate: string, flagexists: boolean, flagforward: boolean, flaghistoryDepth: int, flagisEmpty: boolean, flagsuspend: boolean, flagtargetPane: string, flaguseTemplate: string, flagwrap: boolean) -> string:
    """Synopsis:
---
---
 panelHistory(
[name]
    , [back=boolean], [clear=boolean], [defineTemplate=string], [exists=boolean], [forward=boolean], [historyDepth=int], [isEmpty=boolean], [suspend=boolean], [targetPane=string], [useTemplate=string], [wrap=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

panelHistory is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

   Create a window containing a pane layout.  The window also contains
   an option menu for changing the layout configuration and two buttons
   for stepping through the configuration history.
---

window = cmds.window( title='panelHistory Example' )
form = cmds.formLayout()

   Create the option menu for panel configuration.
---

configuration = cmds.optionMenuGrp( label='Configuration', columnWidth2=( 100, 150 ) )

single = cmds.menuItem( label='Single' )
stacked = cmds.menuItem( label='2 Stacked' )
sideBySide = cmds.menuItem( label='2 Side by Side' )
four = cmds.menuItem( label='Four' )

   Create the buttons for stepping through configuration history.
---

history = cmds.rowLayout( numberOfColumns=3 , columnWidth3=( 100, 75, 75 ),
                                                  columnAttach=[( 2, 'both', 0 ),( 3, 'both', 0 )] )
cmds.text( label='History' )
backBtn = cmds.button( label='Back' )
forwardBtn = cmds.button( label='Forward' )
cmds.setParent( '..' )

   Create the pane layout.
---

frame = cmds.frameLayout( labelVisible=False )
panes = cmds.paneLayout()
cmds.text( label='Pane 1' )
cmds.text( label='Pane 2' )
cmds.text( label='Pane 3' )
cmds.text( label='Pane 4' )

   Set up the attachments.
---

cmds.formLayout( form, edit=True,
                                 attachForm=[(configuration, 'top', 5),
                                                         (configuration, 'left', 5),
                                                         (history, 'left', 5),
                                                         (history, 'right', 5),
                                                         (frame, 'left', 5),
                                                         (frame, 'right', 5),
                                                         (frame, 'bottom', 5)],
                                 attachControl=[(history, 'top', 5, configuration),
                                                                (frame, 'top', 5, history)] )

   Create the panel history object.
---

panelHistory = cmds.panelHistory(targetPane=panes)

   Attach a command to the option menu to change the panel layout
   configuration accordingly.
---

cmds.optionMenuGrp( configuration,
                                        edit=True,
                                        changeCommand=('ExampleUpdatePaneLayout( \"'+ configuration + '\", \"' + panes + '\" )') )

   Attach commands to the buttons for stepping through the configuration
   history.  The commands should also update the value of the option menu.
---

cmds.button( backBtn, edit=True,
                         command='cmds.panelHistory( panelHistory, edit=True, back=True ); ExampleUpdateConfiguration( \"' + configuration + '\", \"' + panes + '\" )' )
cmds.button( forwardBtn, edit=True,
                         command='cmds.panelHistory( panelHistory, edit=True, forward=True ); ExampleUpdateConfiguration( \"' + configuration + '\", \"' + panes + '\" )' )

cmds.showWindow( window )

   Call this procedure whenever the option menu's configuration value
   changes.  This procedure will update the configuration of the
   pane layout to reflect the change.
---

def ExampleUpdatePaneLayout( optionMenuGrp, paneLayout ):
        if optionMenuGrp == "" or paneLayout == "":
                return

        value = cmds.optionMenuGrp( optionMenuGrp, query=True, value=True )
        if value == "Single":
                cmds.paneLayout( paneLayout, edit=True, configuration='single' )
        elif value == "2 Stacked":
                cmds.paneLayout( paneLayout, edit=True, configuration='horizontal2' )
        elif value == "2 Side by Side":
                cmds.paneLayout( paneLayout, edit=True, configuration='vertical2' )
        elif value == "Four":
                cmds.paneLayout( paneLayout, edit=True, configuration='quad' )

   Call this procedure whenever the panel configuration changes due to
   stepping through the panel history (ie. pressing either the "Forward"
   or "Back" buttons.  This procedure will update the value of the
   option menu to reflect the new pane layout configuration.
---

def ExampleUpdateConfiguration( optionMenuGrp, paneLayout ):
        if optionMenuGrp == "" or paneLayout == "":
                return

        configuration = cmds.paneLayout( paneLayout, query=True, configuration=True );

        if configuration == 'single':
                cmds.optionMenuGrp( optionMenuGrp, edit=True, value='Single' )
        elif configuration == 'horizontal2':
                cmds.optionMenuGrp( optionMenuGrp, edit=True, value='2 Stacked' )
        elif configuration == 'vertical2':
                cmds.optionMenuGrp( optionMenuGrp, edit=True, value='2 Side by Side' )
        elif configuration == 'quad':
                cmds.optionMenuGrp( optionMenuGrp, edit=True, value='Four' )

---
Return:
---


    string: The name of the panelHistory object created.

Flags:
---


---
back(b): boolean
    properties: edit
    Go back one level on the history list.

---
clear(cl): boolean
    properties: edit
    Clear the history stack

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
forward(f): boolean
    properties: edit
    Go forward one level on the history list.

---
historyDepth(hd): int
    properties: query, edit
    Specifies how many levels of history are maintained.

---
isEmpty(ie): boolean
    properties: query
    Returns true if there is currently no panel history.

---
suspend(s): boolean
    properties: edit
    Specifies whether to suspend or resume updates to the panel history.
Useful for chunking a number of changes into one history event.

---
targetPane(tp): string
    properties: create, query
    Specifies which paneLayout the history will be maintained for.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

---
wrap(w): boolean
    properties: query, edit
    Specifies whether the history will wrap at the end and
beginning.  This value is true by default.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/panelHistory.html 
    """


def paramDimContext(flagexists: boolean, flaghistory: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flagname: string) -> string:
    """Synopsis:
---
---
 paramDimContext([exists=boolean], [history=boolean], [image1=string], [image2=string], [image3=string], [name=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

paramDimContext is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.paramDimContext()

---
Return:
---


    string: - name of the context created

Flags:
---


---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
history(ch): boolean
    properties: create
    If this is a tool command, turn the construction history on
for the tool in question.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
name(n): string
    properties: create
    If this is a tool command, name the tool appropriately.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/paramDimContext.html 
    """


def paramDimension() -> string:
    """Synopsis:
---
---
 paramDimension(
[curve|surface]
    )  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

paramDimension is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

cmds.curve(d=3, p=((-9.3, 0, 3.2), (-4.2, 0, 5.0), (6.0, 0, 8.6), (2.1, 0, -1.9)), k=(0, 0, 0, 1, 2, 2));
cmds.paramDimension( 'curveShape1.u[0.5]' )
displays where u = 0.5 is on the curve
cmds.sphere();
cmds.paramDimension( 'nurbsSphere1.uv[0.5][0.5]' )
displays where u = 0.5 and v = 0.5 is on the surface

---
Return:
---


    string: Name of the paramDimension shape node created

Flags:
---


URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/paramDimension.html 
    """


def paramLocator(flagposition: boolean) -> string:
    """Synopsis:
---
---
 paramLocator(
[object]
    , [position=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

paramLocator is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Creates a locator on curve1 at parameter value 0.5.
cmds.paramLocator( 'curve1.u[0.5]' )

Creates a locator on curve1 at its second edit point. (ep[0] is the 1st edit point).
cmds.paramLocator( 'curve1.ep[1]' )

Creates a locator on curve1 at normalized parameter value 0.25.
cmds.paramLocator( 'curve1.un[0.25]' )

Creates a locator on surface1 at parameter value (0.5,0.5).
cmds.paramLocator( 'surface1.uv[0.5][0.5]' )

---
Return:
---


    string: Name for the new locator in the underworld of NURBS shape.

Flags:
---


---
position(p): boolean
    properties: create
    Whether to set the locator position in normalized space.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/paramLocator.html 
    """


def parent(flagabsolute: boolean, flagaddObject: boolean, flagnoConnections: boolean, flagnoInvScale: boolean, flagrelative: boolean, flagremoveObject: boolean, flagshape: boolean, flagworld: boolean) -> list[string]:
    """Synopsis:
---
---
 parent(
[dagObject...] [dagObject]
    , [absolute=boolean], [addObject=boolean], [noConnections=boolean], [noInvScale=boolean], [relative=boolean], [removeObject=boolean], [shape=boolean], [world=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

parent is undoable, NOT queryable, and NOT editable.
If the -w flag is specified all the selected or specified objects
are parented to the world (unparented first).

If the -rm flag is specified then all the selected or specified
instances are removed.

If there are more than two objects specified all the objects are
parented to the last object specified.

If the -add flag is specified, the objects are not reparented but
also become children of the last object specified.

If there is only a single object specified then the selected objects
are parented to that object.

If an object is parented under a different group and there is
an object in that group with the same name then this command
will rename the parented object.




Example:
---
import maya.cmds as cmds

Create some objects
cmds.circle( name='circle1' )
cmds.move( 5, 0, 0 )
cmds.group( n='group1' )
cmds.move( -5, 0, 0 )
cmds.group( em=True, n='group2' )

Move the circle under group2.
Note that the circle remains where it is.
cmds.parent( 'circle1', 'group2' )

Let's try that again with the -relative flag. This time
the circle will move.
cmds.undo()
cmds.parent( 'circle1', 'group2', relative=True )

Create an instance of the circle using the parent command.
This makes circle1 a child of group1 and group2.
cmds.undo()
cmds.parent( 'circle1', 'group2', add=True )

Remove group1 as a parent of the circle
cmds.parent( 'group1|circle1', removeObject=True )

Move the circle to the top of the hierarchy
cmds.parent( 'group2|circle1', world=True )

Remove an instance of a shape from a parent
cmds.parent('nurbsSphere3|nurbsSphereShape1',shape=True,rm=True)

---
Return:
---


    list[string]: Names of the objects parented (possibly renamed)

Flags:
---


---
absolute(a): boolean
    properties: create
    preserve existing world object transformations
(overall object transformation is preserved
by modifying the objects local transformation)
If the object to parent is a joint, it will
alter the translation and joint orientation of
the joint to preserve the world object
transformation if this suffices. Otherwise, a
transform will be inserted between the joint
and the parent for this purpose. In this case,
the transformation inside the joint is not
altered.
[default]

---
addObject(add): boolean
    properties: create
    preserve existing local object transformations
but don't reparent, just add the object(s) under
the parent. Use -world to add the world as
a parent of the given objects.

---
noConnections(nc): boolean
    properties: create
    The parent command will normally generate
new instanced set connections when adding instances.
(ie. make a connection to the shading engine for
new instances) This flag suppresses this behaviour
and is primarily used by the file format.

---
noInvScale(nis): boolean
    properties: create
    The parent command will normally connect
inverseScale to its parent scale on joints.
This is used to compensate scale on joint.
The connection of inverseScale will occur if both child and parent are joints and no connection is present on child's inverseScale.
In case of a reparenting, the old inverseScale will only get broken if the old parent is a joint. Otherwise connection will remain intact.
This flag suppresses this behaviour.

---
relative(r): boolean
    properties: create
    preserve existing local object transformations
(relative to the parent node)

---
removeObject(rm): boolean
    properties: create
    Remove the immediate parent of every object specified. To remove only
a single instance of a shape from a parent, the path to the shape
should be specified.
Note: if there is a single parent then the object is effectively deleted from
the scene. Use -world to remove the world as a parent of the given object.

---
shape(s): boolean
    properties: create
    The parent command usually only operates on
transforms.  Using this flags allows a shape
that is specified to be directly parented under
the given transform.  This is used to instance
a shape node. (ie. "parent -add -shape"    is
equivalent to the "instance" command).
This flag is primarily used by the file format.

---
world(w): boolean
    properties: create
    unparent given object(s) (parent to world)

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/parent.html 
    """


def parentConstraint(flagcreateCache: tuple[float, float], flagdecompRotationToChild: boolean, flagdeleteCache: boolean, flaglayer: string, flagmaintainOffset: boolean, flagname: string, flagremove: boolean, flagskipRotate: string, flagskipTranslate: string, flagtargetList: boolean, flagweight: float, flagweightAliasList: boolean) -> list[string]:
    """Synopsis:
---
---
 parentConstraint(
[target ...] [object]
    , [createCache=[float, float]], [decompRotationToChild=boolean], [deleteCache=boolean], [layer=string], [maintainOffset=boolean], [name=string], [remove=boolean], [skipRotate=string], [skipTranslate=string], [targetList=boolean], [weight=float], [weightAliasList=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

parentConstraint is undoable, queryable, and editable.
A parentConstraint takes as input one or more "target" DAG transform
nodes at which to position and rotate the single "constraint
object" DAG transform node.  The parentConstraint positions and rotates
the constrained object at the weighted average of the world
space position, rotation and scale target objects.




Example:
---
import maya.cmds as cmds

Position cube1 at the location of cone1
Rotate cube1 to the rotation of cone1
cmds.parentConstraint( 'cone1', 'cube1' )


Position cube1 at the average of the locations of cone1 and surf2
Rotate cube1 to the average of the rotations of cone1 and surf2
cmds.parentConstraint( 'cone1', 'surf2', 'cube2', w=.1 )

Sets the weight for cone1's effect on cube2 to 10.
cmds.parentConstraint( 'cone1', 'cube2', e=True, w=10.0 )

Removes surf2 from cube2's parentConstraint
cmds.parentConstraint( 'surf2', 'cube2', e=True, rm=True )

Adds surf3 to cube2's parentConstraint with the default weight
cmds.parentConstraint( 'surf3', 'cube2' )

Constrain position only in the y-axis with rotation
constraining in all axes
cmds.parentConstraint( 'cone2', 'cube2', st=["x","z"] )

---
Return:
---


    list[string]: Name of the created constraint node

Flags:
---


---
createCache(cc): [float, float]
    properties: edit
    This flag is used to generate an animation curve that serves as a
cache for the constraint. The two arguments define the start and end
frames.

The cache is useful if the constraint has multiple targets and
the constraint's interpolation type is set to "no flip". The "no flip"
mode prevents flipping during playback, but the result is dependent on
the previous frame. Therefore in order to consistently get the same
result on a specific frame, a cache must be generated. This flag
creates the cache and sets the constraint's interpolation type to
"cache". If a cache exists already, it will be deleted and replaced
with a new cache.

---
decompRotationToChild(dr): boolean
    properties: create
    During constraint creation, if the rotation offset between the constrained
object and the target object is maintained, this flag indicates close to
which object the offset rotation is decomposed. Setting this flag will make
the rotation decomposition close to the constrained object instead of the
target object, which is the default setting.

---
deleteCache(dc): boolean
    properties: edit
    Delete an existing interpolation cache.

---
layer(l): string
    properties: create, edit
    Specify the name of the animation layer where the constraint should be added.

---
maintainOffset(mo): boolean
    properties: create
    If this flag is specified the position and rotation of the
constrained object will be maintained.

---
name(n): string
    properties: create, query, edit
    Sets the name of the constraint node to the specified
name.  Default name is constrainedObjectName_constraintType

---
remove(rm): boolean
    properties: edit
    removes the listed target(s) from the constraint.

---
skipRotate(sr): string
    properties: create, multiuse
    Causes the axis specified not to be considered when
constraining rotation.  Valid arguments are "x", "y", "z" and "none".

---
skipTranslate(st): string
    properties: create, multiuse
    Causes the axis specified not to be considered when
constraining translation.  Valid arguments are "x", "y", "z" and "none".

---
targetList(tl): boolean
    properties: query
    Return the list of target objects.

---
weight(w): float
    properties: create, query, edit
    Sets the weight value for the specified target(s).
If not given at creation time, the default value of 1.0 is used.

---
weightAliasList(wal): boolean
    properties: query
    Returns the names of the attributes that control the weight
of the target objects. Aliases are returned in the same order
as the targets are returned by the targetList flag

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/parentConstraint.html 
    """


def particle(flagattribute: string, flagcache: boolean, flagconserve: float, flagcount: boolean, flagdeleteCache: boolean, flagdynamicAttrList: boolean, flagfloatValue: float, flaggridSpacing: linear, flaginherit: float, flagjitterBasePoint: tuple[linear, linear, linear], flagjitterRadius: linear, flaglowerLeft: tuple[linear, linear, linear], flagname: string, flagnumJitters: uint, flagorder: int, flagparticleId: int, flagperParticleDouble: boolean, flagperParticleVector: boolean, flagposition: tuple[linear, linear, linear], flagshapeName: string, flagupperRight: tuple[linear, linear, linear], flagvectorValue: tuple[float, float, float]) -> string:
    """Synopsis:
---
---
 particle(
object
    , [attribute=string], [cache=boolean], [conserve=float], [count=boolean], [deleteCache=boolean], [dynamicAttrList=boolean], [floatValue=float], [gridSpacing=linear], [inherit=float], [jitterBasePoint=[linear, linear, linear]], [jitterRadius=linear], [lowerLeft=[linear, linear, linear]], [name=string], [numJitters=uint], [order=int], [particleId=int], [perParticleDouble=boolean], [perParticleVector=boolean], [position=[linear, linear, linear]], [shapeName=string], [upperRight=[linear, linear, linear]], [vectorValue=[float, float, float]])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

particle is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Creates a particle object with four particles
cmds.particle( p=[(0, 0, 0), (3, 5, 6), (5, 6, 7), (9, 9, 9)] )

Returns the age of the particle with id 2 in object particle1
cmds.particle( 'particle1', q=True, attribute='age', id=2 )

Returns the velocity of the 3rd particle in the currently selected
particle object
cmds.particle( attribute='velocity', q=True, order=3  )

Edits the velocity of the 7th particle in the currently selected
particle object to be 0.0, 1.0, 0.0
cmds.particle( e=True, attribute='velocity', order=3, vectorValue=(0.0, 1.0, 0.0) )

Edits the mass of the particle in "particle1" with id 3 to be 0.7
cmds.particle( 'particle1', e=True, attribute='mass', id=3, fv=0.7 )

---
Return:
---


    string: The name of the particle object created

Flags:
---


---
attribute(at): string
    properties: query, edit
    Used in per particle attribute query and edit. Specifies the
name of the attribute being queried or edited.
      In query mode, this flag needs a value.

---
cache(ch): boolean
    properties: create, query, edit
    Turns caching on/off for the particle shape.

---
conserve(c): float
    properties: query, edit
    Conservation of momentum control (between 0 and 1).  Specifies
the fraction of the particle shape's existing momentum which is
conserved from frame to frame.
A value of 1 (the default) corresponds to true Newtonian physics,
in which momentum is conserved.

---
count(ct): boolean
    properties: query
    Returns the number of particles in the object.

---
deleteCache(dc): boolean
    properties: create
    Deletes the particle shapes cache. This command is not undoable.

---
dynamicAttrList(dal): boolean
    properties: query
    Returns a list of the dynamic attributes in the object.

---
floatValue(fv): float
    properties: edit
    Used only in per particle attribute edit.  Specifies that the edit is
of a float attribute and must be followed by the new float value.

---
gridSpacing(grs): linear
    properties: create, query, multiuse
    Spacing between particles in the grid.

---
inherit(i): float
    properties: query, edit
    Inherit this fraction (0-1) of emitting object's velocity.

---
jitterBasePoint(jbp): [linear, linear, linear]
    properties: create, query, multiuse
    Base point (center point) for jitters.  The command will create
one swatch of jitters for each base point.  It will pair up
other flags with base points in the order they are given in the
command line.  If not enough instances of the other flags are
availble, the last one on the line with be used for all other
instances of -jpb.

---
jitterRadius(jr): linear
    properties: create, query, multiuse
    Max radius from the center to place the particle instances.

---
lowerLeft(ll): [linear, linear, linear]
    properties: create, query, multiuse
    Lower left point of grid.

---
name(n): string
    properties: query, edit
    name of particle object

---
numJitters(nj): uint
    properties: create, query, multiuse
    Number of jitters (instances) per particle.

---
order(order): int
    properties: query, edit
    Used in per particle attribute query and edit. Specifies the
zero-based order (index) of the particle whose attribute is being
queried  or edited in the
particle array. Querying the value of a per particle attribute
requires the -attribute and -id or -order flags and their arguments
to precede the -q flag.
      In query mode, this flag needs a value.

---
particleId(id): int
    properties: query, edit
    Used in per particle attribute query and edit. Specifies the
id of the particle whose attribute is being queried or edited.
Querying the value of a per particle attribute
requires the -attribute and -id or -order flags and their arguments
to precede the -q flag.
      In query mode, this flag needs a value.

---
perParticleDouble(ppd): boolean
    properties: query
    Returns a list of the per-particle double attributes,
excluding initial-state, cache, and information-only attributes.

---
perParticleVector(ppv): boolean
    properties: query
    Returns a list of the per-particle vector attributes,
excluding initial-state, cache, and information-only attributes.

---
position(p): [linear, linear, linear]
    properties: multiuse
    World-space position of each particle.

---
shapeName(sn): string
    properties: query, edit
    Specify the shape name used for geometry instancing.
DO not confuse this with the -n flag which names the particle object.

---
upperRight(ur): [linear, linear, linear]
    properties: create, query, multiuse
    Upper right point of grid.

---
vectorValue(vv): [float, float, float]
    properties: edit
    Used only in per particle attribute edit.  Specifies that the edit is
of a vector attribute and must be followed by all three float values
for the vector.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/particle.html 
    """


def particleExists() -> boolean:
    """Synopsis:
---
---
 particleExists(
string
    )  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

particleExists is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

If the object does not exist then false (0) is returned
cmds.file( f=True, new=True )
cmds.particleExists( 'particleShape1' )
Result: 0 ---


Create a particle shape and then querying for
it will return true (1)
cmds.emitter()
Result: emitter1 ---

cmds.particle()
Result: particle1 particleShape1 ---

cmds.connectDynamic( 'particle1', em='emitter1' )
Result: particleShape1 ---

cmds.particleExists( 'particleShape1' )
Result: 1 ---


You may also query using the transform name
cmds.particleExists( 'particle1' )
Result: 1 ---


The name of a soft body object can be used to query as well
cmds.polySphere( r=1, sx=20, sy=20, ax=(0, 1, 0), tx=2, ch=1 )
Result: pSphere1 polySphere1 ---

cmds.soft( c=True )
Result: pSphere1Particle ---

cmds.particleExists( 'pSphere1Particle' )
Result: 1 ---


---
Return:
---


    boolean: True if there is a particle object or soft object by the given
name, false otherwise.

Flags:
---


URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/particleExists.html 
    """


def particleFill(flagclosePacking: boolean, flagdoubleWalled: boolean, flagmaxX: float, flagmaxY: float, flagmaxZ: float, flagminX: float, flagminY: float, flagminZ: float, flagparticleDensity: float, flagresolution: int) -> None:
    """Synopsis:
---
---
 particleFill([closePacking=boolean], [doubleWalled=boolean], [maxX=float], [maxY=float], [maxZ=float], [minX=float], [minY=float], [minZ=float], [particleDensity=float], [resolution=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

particleFill is NOT undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

create a poly torus with particles filling interior
cmds.polyTorus()
cmds.particleFill()

---


Flags:
---


---
closePacking(cp): boolean
    properties: create
    If this is on then the particles are positioned as closely as possible in a hexagonal close packing arrangement.
Otherwise particles are packed in a uniform grid lattice.

---
doubleWalled(dw): boolean
    properties: create
    This flag should be used if the thickness of the object to fill has been modeled( for example a mug ).
Otherwise the particles will be created inside the wall. Note that doubleWalled will not
handle some cases very well. For example a double walled donut shape may get the center
region of the donut filled. In cases like this it may be better to make the internal wall a
separate mesh then fill that without using doubleWalled.

---
maxX(mxx): float
    properties: create
    The fill max bounds of the particles in X relative to the X bounds of the object.
A value of zero is totally empty and one is totally full. The default value is 1, or fully filled.

---
maxY(mxy): float
    properties: create
    The fill max bounds of the particles in Y relative to the Y bounds of the object.
A value of zero is totally empty and one is totally full. The default value is 1, or fully filled.

---
maxZ(mxz): float
    properties: create
    The fill max bounds of the particles in Z relative to the Z bounds of the object.
A value of zero is totally empty and one is totally full. The default value is 1, or fully filled.

---
minX(mnx): float
    properties: create
    The fill lower bounds of the particles in X relative to the X bounds of the object.
A value of zero is totally full and one is totally empty. The default value is 0, or fully filled.

---
minY(mny): float
    properties: create
    The fill lower bounds of the particles in Y relative to the Y bounds of the object.
A value of zero is totally full and one is totally empty. The default value is 0, or fully filled.

---
minZ(mnz): float
    properties: create
    The fill lower bounds of the particles in Z relative to the Z bounds of the object.
A value of zero is totally full and one is totally empty. The default value is 0, or fully filled.

---
particleDensity(pd): float
    properties: create
    This controls the size of the particles. At a value of 1.0 the particle size will exactly match the
grid spacing determined by the resolution parameter and the object bounds. Particles which overlap
the surface will be rejected even if the center of the particle is inside.

---
resolution(rs): int
    properties: create
    This determines the total number of particles generated.
It represent the resolution along the largest axis of the object's bounding box.
For a cube shape the total potential particles will be the cube of the resolution.
For other shapes it will be less.
The default value for this flag is 10, so 1000 particles could be generated for a cube shape.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/particleFill.html 
    """


def particleInstancer(flagaddObject: boolean, flagaimAxis: string, flagaimDirection: string, flagaimPosition: string, flagaimUpAxis: string, flagaimWorldUp: string, flagattributeMapping: boolean, flagcycle: string, flagcycleStartObject: string, flagcycleStep: float, flagcycleStepUnits: string, flagindex: int, flaginstanceId: string, flaglevelOfDetail: string, flagname: string, flagobject: string, flagobjectIndex: string, flagparticleAge: string, flagposition: string, flagremoveObject: boolean, flagrotation: string, flagrotationOrder: string, flagrotationType: string, flagrotationUnits: string, flagscale: string, flagshear: string, flagvisibility: string) -> string:
    """Synopsis:
---
---
 particleInstancer([addObject=boolean], [aimAxis=string], [aimDirection=string], [aimPosition=string], [aimUpAxis=string], [aimWorldUp=string], [attributeMapping=boolean], [cycle=string], [cycleStartObject=string], [cycleStep=float], [cycleStepUnits=string], [index=int], [instanceId=string], [levelOfDetail=string], [name=string], [object=string], [objectIndex=string], [particleAge=string], [position=string], [removeObject=boolean], [rotation=string], [rotationOrder=string], [rotationType=string], [rotationUnits=string], [scale=string], [shear=string], [visibility=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

particleInstancer is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds


create a cube and a particle emitter
cmds.polyCube()
cmds.emitter(pos=(0,0,0), type='omni', r=100, sro=0, nuv=0, cye='none', cyi=1, spd=1, srn=0, nsp=1, tsp=0, mxd=0, mnd=0, dx=1, dy=0, dz=0, sp=0)
cmds.particle()
cmds.connectDynamic('particle1',em='emitter1')

instance the cube to each particle emitted
cmds.particleInstancer( 'particleShape1', addObject=True, object='pCube1', cycle='None', cycleStep=1, cycleStepUnits='Frames', levelOfDetail='Geometry', rotationUnits='Degrees', rotationOrder='XYZ', position='worldPosition', age='age')

query the instancer associated with the particle
cmds.particleInstancer( 'particle1', q=True, name=True )

query the particle attribute name corresponding to the position attribute for the instancer
cmds.particleInstancer( 'particle1', name='instancer1', q=True, position=True )

---
Return:
---


    string: Command result

Flags:
---


---
addObject(a): boolean
    properties: create, edit
    This flag indicates that objects specified by the -object flag will be added to
the instancer node as instanced objects.

---
aimAxis(aa): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the aim axis
of the instanced objects.

---
aimDirection(ad): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the aim direction
of the instanced objects.

---
aimPosition(ap): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the aim position
of the instanced objects.

---
aimUpAxis(aua): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the aim up axis
of the instanced objects.

---
aimWorldUp(awu): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the aim world up
of the instanced objects.

---
attributeMapping(am): boolean
    properties: query
    This flag queries the particle attribute mapping list.

---
cycle(c): string
    properties: create, query, edit
    This flag sets or queries the cycle attribute for the instancer node.  The options are
"none", "sequential". The default is "none".

---
cycleStartObject(sto): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the cycle start object
of the instanced objects.

---
cycleStep(cs): float
    properties: create, query, edit
    This flag sets or queries the cycle step attribute for the instancer node.  This attribute
indicates the size of the step in frames or seconds (see cycleStepUnits).

---
cycleStepUnits(csu): string
    properties: create, query, edit
    This flag sets or queries the cycle step unit attribute for the instancer node.
The options are "frames" or "seconds".  The default is "frames".

---
index(i): int
    properties: query
    This flag is used to query the name of the ith instanced object.

---
instanceId(id): string
    properties: query
    This flag queries the particle attribute name to be used for the id of the instanced objects.

---
levelOfDetail(lod): string
    properties: create, query, edit
    This flag sets or queries the level of detail of the instanced objects.  The options are
"geometry", "boundingBox" or "boundingBoxes".  The default is "geometry".

---
name(n): string
    properties: create, query
    This flag sets or queries the name of the instancer node.

---
object(obj): string
    properties: create, query, edit, multiuse
    This flag indicates which objects will be add/removed from the list of instanced
objects.  The flag is used in conjuction with the -addObject and -remove flags.  If
neither of these flags is specified on the command line then -addObject is assumed.

---
objectIndex(oi): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the object index
of the instanced objects.

---
particleAge(age): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the age
of the instanced objects.

---
position(p): string
    properties: create, query, edit
    DEFAULT "worldPosition"
This flag sets or queries the particle attribute name to be used for the positions
of the instanced objects.  By default the attribute is worldPosition.

---
removeObject(rm): boolean
    properties: edit
    This flag indicates that objects specified by the -object flag will be
removed from the instancer node as instanced objects.

---
rotation(r): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the rotation
of the instanced objects.

---
rotationOrder(ro): string
    properties: create, query, edit
    This flag specifies the rotation order associated with the rotation flag.  The options are
XYZ, XZY, YXZ, YZX, ZXY, or ZYX.  By default the attribute is XYZ.

---
rotationType(rt): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the rotation type
of the instanced objects.

---
rotationUnits(ru): string
    properties: create, query, edit
    This flag specifies the rotation units associated with the rotation flag.  The options are
degrees or radians.  By default the attribute is degrees.

---
scale(sc): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the scale
of the instanced objects.

---
shear(sh): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the shear
of the instanced objects.

---
visibility(vis): string
    properties: create, query, edit
    This flag sets or queries the particle attribute name to be used for the visibility
of the instanced objects.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/particleInstancer.html 
    """


def particleRenderInfo(flagattrList: int, flagattrListAll: boolean, flagname: int, flagrenderTypeCount: boolean) -> None:
    """Synopsis:
---
---
 particleRenderInfo([attrList=int], [attrListAll=boolean], [name=int], [renderTypeCount=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

particleRenderInfo is undoable, queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

---
Return the list of all render attributes
cmds.particleRenderInfo(query=True, ala=True)

---


Flags:
---


---
attrList(al): int
    properties: query
    Return the list of attributes used by this render type.

---
attrListAll(ala): boolean
    properties: query
    Return a complete list of all render attributes used by the
particle object. This also includes the per particle attributes.

---
name(n): int
    properties: query
    Return the name of the render subclass using the render type.

---
renderTypeCount(rtc): boolean
    properties: query
    Return the count of registered render classes for particle.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/particleRenderInfo.html 
    """


def partition(flagaddSet: name, flagname: string, flagremoveSet: name, flagrender: boolean) -> string:
    """Synopsis:
---
---
 partition(
[string] [string...]
    , [addSet=name], [name=string], [removeSet=name], [render=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

partition is undoable, queryable, and editable.
Without any flags, the command will create a
partition with a default name.  Any sets which are arguments
to the command will be added to the partition.

A set can be added to a partition only if none of its members
are in any of the other sets in the partition. If the -re/render
flag is specified when the partition is created, only 'renderable'
sets can be added to the partition.

Sets can be added and removed from a partition by using the
-addSet or -removeSet flags.

Note: If a set is already selected, and the partition command is
executed, the set will be added to the created partition.




Example:
---
import maya.cmds as cmds

To create a partition calls p1 which contains set1 and set2 ...
cmds.partition( 'set1', 'set2', n='p1' )

To create an empty render partition ...
cmds.partition( render=True )

To add/remove sets from partition p1 ...
cmds.partition( 'set3', add='p1' )
cmds.partition( 'set1', rm='p1' )

To get a list of all sets in a partition ...
cmds.partition( 'p1', q=True )

To check if the partition is a render partition
cmds.partition( 'p1', q=True, re=True )

---
Return:
---


    string: Name of the partition that was created or edited

Flags:
---


---
addSet(add): name
    properties: create
    Adds the list of sets to the named partition.

---
name(n): string
    properties: create
    Assigns the given name to new partition. Valid only for create mode.

---
removeSet(rm): name
    properties: create
    Removes the list of sets from the named partition.

---
render(re): boolean
    properties: create, query
    New partition can contain render sets.
For use in creation mode only. Default is false.  Can also
be used with query flag - returns boolean.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/partition.html 
    """


def pasteKey(flaganimLayer: string, flaganimation: string, flagattribute: string, flagclipboard: string, flagconnect: boolean, flagcopies: uint, flagfloat: floatrange, flagfloatOffset: float, flagincludeUpperBound: boolean, flagindex: uint, flagmatchByName: boolean, flagoption: string, flagtime: timerange, flagtimeOffset: time, flagvalueOffset: float) -> int:
    """Synopsis:
---
---
 pasteKey(
[objects]
    , [animLayer=string], [animation=string], [attribute=string], [clipboard=string], [connect=boolean], [copies=uint], [float=floatrange], [floatOffset=float], [includeUpperBound=boolean], [index=uint], [matchByName=boolean], [option=string], [time=timerange], [timeOffset=time], [valueOffset=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pasteKey is undoable, queryable, and editable.
Valid operations include:

 One attribute to one or more attributes (Clipboard
animation is pasted onto all target attributes.

 One attribute to one or more objects (Clipboard animation
pasted onto target object, when attribute names match.)

Many attributes to one or more objects

Clipboard animation pasted onto targets when attribute names
match.



TbaseKeySetCmd.h

The way the keyset clipboard will be pasted to the specified object's
attributes depends on the paste "-option" specified. Each of these
options below will be explained using an example. For all the
explanations, let us assume that there is a curve segment
with 20 frames of animation on the keyset clipboard (you can put
curve segments onto the clipboard using the cutKey or
copyKey commands). We will call the animation curve that
we are pasting to the target curve:


pasteKey -time 5 -option insert
1. Shift all keyframes on the target curve after time 5 to the right
by 20 frames (to make room for the 20-frame clipboard segment).

2. Paste the 20-frame clipboard segment starting at time 5.


pasteKey -time "5:10" -option replace

1. Remove all keys on the target curve from 5 to 10.

2. Paste the 20-frame clipboard curve at time 5. Keys from frame 11-25 will be
overridden if a key is present on the clipboard curve.


pasteKey -option replaceCompletely

1. Remove all keys on the target curve.

2. Paste the 20-frame clipboard curve, preserving
the clipboard curve's original keyframe times.


pasteKey -time 5 -option merge

1.The clipboard curve segment will be pasted starting at time 5
for its full 20-frame range until frame 25.

2. If a keyframe on the target curve has the same time
as a keyframe on the clipboard curve, it is overwritten.
Otherwise, any keys that existed in the 5:25 range
before the paste, will remain untouched


pasteKey -time "3:10" -option scaleInsert

1. Shift all keyframes on the target curve after time 3 to the right
by 7 frames (to clear the range 3:10 to paste in)

2. The clipboard curve segment will be scaled to fit the specified
time range (i.e. the 20 frames on the clipboard will be scaled to
fit into 7 frames), and then pasted into the range 3:10.


pasteKey -time "3:10" -option scaleReplace

1. Any existing keyframes in the target curve in the range 3:10
are removed.

2. The clipboard curve segment will be scaled to fit the specified
time range (i.e. the 20 frames on the clipboard will be scaled to
fit into 7 frames), and then pasted into the range 3:10.


pasteKey -time "3:10" -option scaleMerge

1. The clipboard curve segment will be scaled to fit the specified
time range (i.e. the 20 frames on the clipboard will be scaled to
fit into 7 frames).

2. If there are keys on the target curve at the same time
as keys on the clipboard curve, they are overwritten.
Otherwise, keyframes on the target curve that
existed in the 3:10 range before the paste, will
remain untouched.


pasteKey -time "3:10" -option fitInsert

1. Shift all the keyframes on the target curve after time 3 to the right
by 7 frames (to clear the range 3:10 to paste in)

2. The first 7 frames of the clipboard curve segment will be
pasted into the range 3:10.


pasteKey -time "3:10" -option fitReplace

1. Any existing frames in the target curve in the range 3:10
are removed.

2. The first 7 frames of the clipboard curve segment will be
pasted into the range 3:10.


pasteKey -time "3:10" -option fitMerge

1. The first 7 frames of the clipboard curve segment
will be pasted into the range 3:10.

2. If there are keys on the target curve at the same time
as keys on the clipboard curve, they are overwritten.
Otherwise, keyframes on the target curve that
existed in the 3:10 range before the paste, will
remain untouched.






Example:
---
import maya.cmds as cmds

Paste keyframes onto nurbsSphere1's translateX attribute at time 10
---

cmds.pasteKey( 'nurbsSphere1', time=(10,10), attribute='translateX' )

Paste to all active objects, preserving the timing from the clipboard.
---

cmds.pasteKey()

---
Return:
---


    int: The number of curves pasted

Flags:
---


---
animLayer(al): string
    properties: create
    Specifies that the keys getting pasted should be pasted onto
curves on the specified animation layer.If that layer doesn't
exist for the specified objects or attributes then the keys
won't get pasted.

---
animation(an): string
    properties: create
    Where this command should get the animation to act
on.  Valid values are "objects," "keys," and
"keysOrObjects" Default: "keysOrObjects."  (See
Description for details.)

---
attribute(at): string
    properties: create, multiuse
    List of attributes to select
      In query mode, this flag needs a value.

---
clipboard(cb): string
    properties: create
    Specifies the clipboard from which animation is pasted.
Valid clipboards are "api" and "anim".  The default clipboard
is: anim

---
connect(c): boolean
    properties: create
    When true, connect the source curve with the
destination curve's value at the paste time.
(This has the effect of shifting the clipboard curve
in value to connect with the destination curve.)
False preserves the source curve's original keyframe
values. Default is false.

---
copies(cp): uint
    properties: create
    The number of times to paste the source curve.

---
float(f): floatrange
    properties: create
    value uniquely representing a non-time-based
key (or key range) on a time-based animCurve.  Valid
floatRange include single values (-f 10) or a
string with a lower and upper bound, separated by a
colon (-f "10:20")
      In query mode, this flag needs a value.

---
floatOffset(fo): float
    properties: create
    How much to offset the pasted keys in time (for non-time-input
animation curves).

---
includeUpperBound(iub): boolean
    properties: create
    When the -t/time or -f/float flags represent a range
of keys, this flag determines whether the keys at the
upper bound of the range are included in the keyset.
Default value: true.  This flag is only valid when
the argument to the -t/time flag is a time range with
a lower and upper bound.  (When used with the "pasteKey"
command, this flag refers only to the time range of the
target curve that is replaced, when using options such
as "replace," "fitReplace," or "scaleReplace."  This
flag has no effect on the curve pasted from the clipboard.)

---
index(index): uint
    properties: create
    index of a key on an animCurve
      In query mode, this flag needs a value.

---
matchByName(mn): boolean
    properties: create
    When true, we will only paste onto items in the scene whose
node and attribute names match up exactly with a corresponding
item in the clipboard. No hierarchy information is used.
Default is false, and in this case the usual matching by
hierarchy occurs.

---
option(o): string
    properties: create
    Valid values are "insert", "replace",
"replaceCompletely", "merge", "scaleInsert,"
"scaleReplace", "scaleMerge", "fitInsert",
"fitReplace", and "fitMerge". The default paste
option is: "insert".

---
time(t): timerange
    properties: create
    time uniquely representing a key (or key
range) on a time-based animCurve.  See the code
examples below on how to format for a single
frame or frame ranges.
      In query mode, this flag needs a value.

---
timeOffset(to): time
    properties: create
    How much to offset the pasted keys in time (for time-input
animation curves).

---
valueOffset(vo): float
    properties: create
    How much to offset the pasted keys in value.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pasteKey.html 
    """


def pathAnimation(flagbank: boolean, flagbankScale: float, flagbankThreshold: angle, flagcurve: string, flagendTimeU: time, flagendU: float, flagfollow: boolean, flagfollowAxis: string, flagfractionMode: boolean, flaginverseFront: boolean, flaginverseUp: boolean, flagname: string, flagstartTimeU: time, flagstartU: float, flagupAxis: string, flaguseNormal: boolean, flagworldUpObject: name, flagworldUpType: string, flagworldUpVector: tuple[float, float, float]) -> string:
    """Synopsis:
---
---
 pathAnimation(
[objects]
    , [bank=boolean], [bankScale=float], [bankThreshold=angle], [curve=string], [endTimeU=time], [endU=float], [follow=boolean], [followAxis=string], [fractionMode=boolean], [inverseFront=boolean], [inverseUp=boolean], [name=string], [startTimeU=time], [startU=float], [upAxis=string], [useNormal=boolean], [worldUpObject=name], [worldUpType=string], [worldUpVector=[float, float, float]])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pathAnimation is undoable, queryable, and editable.

There are two ways to specify the moving objects:

 by explicitly specifying their names in the command line, or
 by making the objects selected (interactively, or through a
MEL command).


Likewise, there are two ways to specify a motion curve:

 by explicitly specifying the name of the motion curve
in the command line (i.e. using the -c curve_name option), or
 by selecting the moving objects first before selecting the
motion curve. I.e. if the name of the motion curve is not
provided in the command line, the curve will be taken to be the
last selected object in the selection list.


When the end time is not specified: only one keyframe
will be created either at the current time, or at the specified
start time.




Example:
---
import maya.cmds as cmds

Create a set of simple objects for the motion path animation

create a path, e,g, a curve
path = cmds.curve(d=3,p=[(-10, 0, 0),(-6, 0, 10),(-3, 0, -10),(10, 0, 0)],k=[0, 0, 0, 1, 1, 1])

create an object, e.g. a sphere
object = cmds.sphere()
cmds.scale( 0.5, 2.0, 0.2 )

1. To animate the sphere along the curve, with one keyframe at
the current time:

cmds.pathAnimation( object[0], c=path )

or:

cmds.select( object[0], path )
cmds.pathAnimation()

2. To animate the sphere along the curve, from time 0 to time 30:

cmds.pathAnimation( object[0], stu=0, etu=30, c=path )

3. To align the sphere to its path:

cmds.pathAnimation( object[0], stu=0, etu=30, follow=True, c=path )

4. To align the Z axis of sphere to the tangent of the curve, and
to align the Y axis of the sphere to the up direction of the
motion curve:

cmds.pathAnimation( object[0], stu=0, etu=30, fa='z', ua='y', c=path )

5. To align the Z axis of sphere to the tangent of the motion curve,
to align the Y axis of sphere to the up direction of the motion
curve, and to bank with the curvature of the motion curve:

cmds.pathAnimation( object[0], stu=0, etu=30, fa='z', ua='y', bank=True, c=path )

6. To change the setting on the bankScale for the motionPath1
to negative 2.5 (i.e. bank out and multiply the computed
bank value by 2.5):

cmds.pathAnimation( 'motionPath1', edit=True, bankScale=-2.5 )

Notes:
If the computed bank angles are not large enough, the user can
specify the bankScale to amplify them. The default value is 1.

Positive bankScale produces inward bank angle,
negative bankScale produces outward bank angle.

The user can also change the maximum bank angle through
the bankThreshold option. Default value is 90 degrees.

---
Return:
---


    string: (name of the created motionPath node)

Flags:
---


---
bank(b): boolean
    properties: query
    If on, enable alignment of the up axis of the moving
object(s) to the curvature of the path geometry.
Default is false.
When queried, this flag returns a boolean.

---
bankScale(bs): float
    properties: query
    This flag specifies a factor to scale the amount of
bank angle.
Default is 1.0
When queried, this flag returns a float.

---
bankThreshold(bt): angle
    properties: query
    This flag specifies the limit of the bank angle.
Default is 90 degrees
When queried, this flag returns an angle.

---
curve(c): string
    properties: query
    This flag specifies the name of the curve for the path.
Default is NONE
When queried, this flag returns a string.

---
endTimeU(etu): time
    properties: query, multiuse
    This flag specifies the ending time of the animation
for the u parameter.
Default is NONE.
When queried, this flag returns a time.

---
endU(eu): float
    properties: query
    This flag specifies the ending value of the u
parameterization for the animation.
Default is the end parameterization value of the curve.
When queried, this flag returns a linear.

---
follow(f): boolean
    properties: query
    If on, enable alignment of the front axis of the moving object(s).
Default is false.
When queried, this flag returns a boolean.

---
followAxis(fa): string
    properties: query
    This flag specifies which object local axis to be
aligned to the tangent of the path curve.
Default is y
When queried, this flag returns a string.

---
fractionMode(fm): boolean
    properties: query
    If on, evaluation on the path is based on the fraction
of length of the path curve.
Default is false.
When queried, this flag returns a boolean.

---
inverseFront(inverseFront): boolean
    properties: query
    This flag specifies whether or not to align
the front axis of the moving object(s) to the opposite direction
of the tangent vector of the path geometry.
Default is false.
When queried, this flag returns a boolean.

---
inverseUp(iu): boolean
    properties: query
    This flag specifies whether or not to align
the up axis of the moving object(s) to the opposite direction
of the normal vector of the path geometry.
Default is false.
When queried, this flag returns a boolean.

---
name(n): string
    properties: query
    This flag specifies the name for the new motion path node.
(instead of the default name)
When queried, this flag returns a string.

---
startTimeU(stu): time
    properties: query, multiuse
    This flag specifies the starting time of the animation
for the u parameter.
Default is the the current time.
When queried, this flag returns a time.

---
startU(su): float
    properties: query
    This flag specifies the starting value of the u
parameterization for the animation.
Default is the start parameterization value of the curve.
When queried, this flag returns a linear.

---
upAxis(ua): string
    properties: query
    This flag specifies which object local axis to be
aligned a computed up direction.
Default is z
When queried, this flag returns a string.

---
useNormal(un): boolean
    properties: create, query, edit
    This flag is now obsolete. Use -wut/worldUpType instead.

---
worldUpObject(wuo): name
    properties: create, query, edit
    Set the DAG object to use for worldUpType "object" and
"objectrotation". See -wut/worldUpType for greater detail.
The default value is no up object, which is interpreted
as world space.

---
worldUpType(wut): string
    properties: create, query, edit
    Set the type of the world up vector computation.
The worldUpType can have one of 5 values: "scene",
"object", "objectrotation", "vector", or "normal".
If the value is "scene", the upVector is
aligned with the up axis of the scene and
worldUpVector and worldUpObject are ignored.
If the value is "object", the upVector is
aimed as closely as possible to the
origin of the space of the worldUpObject and
the worldUpVector is ignored.
If the value is "objectrotation" then the
worldUpVector is interpreted as being in
the coordinate space of the worldUpObject, transformed into
world space and the upVector is aligned as
closely as possible to the result.
If the value is "vector", the upVector
is aligned with worldUpVector as closely as
possible and worldUpObject is ignored.
Finally, if the value is "normal" the upVector is aligned to
the path geometry.
The default worldUpType is "vector".

---
worldUpVector(wu): [float, float, float]
    properties: create, query, edit
    Set world up vector.  This is the vector in world
coordinates that up vector should align with.
See -wut/worldUpType for greater detail.
If not given at creation time, the default
value of (0.0, 1.0, 0.0) is used.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pathAnimation.html 
    """


def pause(flagseconds: int) -> None:
    """Synopsis:
---
---
 pause([seconds=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pause is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

cmds.pause( sec=10 )

---


Flags:
---


---
seconds(sec): int
    properties: create
    Pause for the specified number of seconds.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pause.html 
    """


def perCameraVisibility(flagcamera: name, flagexclusive: boolean, flaghide: boolean, flagremove: boolean, flagremoveAll: boolean, flagremoveCamera: boolean) -> list[string]:
    """Synopsis:
---
---
 perCameraVisibility([camera=name], [exclusive=boolean], [hide=boolean], [remove=boolean], [removeAll=boolean], [removeCamera=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

perCameraVisibility is NOT undoable, queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

make 'pSphere1' exclusive to camera 'persp'
cmds.perCameraVisibility( 'pSphere1', ex=True, c='persp' )
remove 'pSphere1' from camera 'persp''s exclusive objects
cmds.perCameraVisibility( 'pSphere1', ex=True, rm=True, c='persp' )
query the objects that are exclusive to 'persp'
cmds.perCameraVisibility( q=True, ex=True, c='persp' )
hide 'pSphere1' from camera 'persp'
cmds.perCameraVisibility( 'pSphere1', hi=True, c='persp' )
remove 'pSphere1' from camera 'persp''s hidden objects
cmds.perCameraVisibility( 'pSphere1', hi=True, rm=True, c='persp' )
query the objects that are hidden from 'persp'
cmds.perCameraVisibility( q=True, hi=True, c='persp' )
remove all exclusive or hidden objects from 'persp'
cmds.perCameraVisibility( rc=True, c='persp' )
remove all exclusive or hidden objects from all cameras
cmds.perCameraVisibility( ra=True )

---
Return:
---


    list[string]: Command result

Flags:
---


---
camera(c): name
    properties: create, query
    Specify the camera for the operation.

---
exclusive(ex): boolean
    properties: create, query
    Set objects as being exclusive to the given camera.

---
hide(hi): boolean
    properties: create, query
    Set objects as being hidden from the given camera.

---
remove(rm): boolean
    properties: create
    Used with exclusive or hide, removes the objects instead of adding them.

---
removeAll(ra): boolean
    properties: create
    Remove all exclusivity/hidden objects for all cameras.

---
removeCamera(rc): boolean
    properties: create
    Remove all exclusivity/hidden objects for the given camera.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/perCameraVisibility.html 
    """


def percent(flagaddPercent: boolean, flagdropoffAxis: tuple[linear, linear, linear], flagdropoffCurve: string, flagdropoffDistance: linear, flagdropoffPosition: tuple[linear, linear, linear], flagdropoffType: string, flagmultiplyPercent: boolean, flagvalue: float) -> None:
    """Synopsis:
---
---
 percent(
node [objects]
    , [addPercent=boolean], [dropoffAxis=[linear, linear, linear]], [dropoffCurve=string], [dropoffDistance=linear], [dropoffPosition=[linear, linear, linear]], [dropoffType=string], [multiplyPercent=boolean], [value=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

percent is undoable, queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

set percents on the selected items to 0.6
---

cmds.percent( 'cluster1', v=0.6 )

set percents on the selected items dropping off along the
z-axis starting at the origin. Dropoff distance is 5, and
the initial value is 1. Dropoff type is linear.
---

cmds.percent( 'cluster1', dp=(0, 0, 0), dax=(0, 0, 1), dt='linear', dds=5, v=1 )

set percents on the selected items dropping off along
curve1. Dropoff distance is 5, and
the initial value is 0.3.
---

cmds.percent( 'cluster2', dc='curve2', dds=3, v=0.3 )

add 0.1 to the percents of the selected items
---

cmds.percent( 'cluster1', v=0.1, ap=True )

---


Flags:
---


---
addPercent(ap): boolean
    properties: create
    Add the percent value specified with the -v flag to the existing percent values

---
dropoffAxis(dax): [linear, linear, linear]
    properties: create
    Specifies the axis along which to dropoff the percent value,
starting from the dropoffPosition.

---
dropoffCurve(dc): string
    properties: create
    Specifies the curve around which to dropoff the percent value.

---
dropoffDistance(dds): linear
    properties: create
    Specifies the dropoff distance from the point, plane or curve
that was specified using the -dp -dax or -dc flags.

---
dropoffPosition(dp): [linear, linear, linear]
    properties: create
    Specifies the point around which to dropoff the percent value.

---
dropoffType(dt): string
    properties: create
    Specifies the type of dropoff. Used in conjunction with
the -dp, -dax or -dc flags. Default is linear.
Valid values are: linear, sine, exponential, linearSquared, none.

---
multiplyPercent(mp): boolean
    properties: create
    Multiply the percent value specified with the -v flag with existing percent values

---
value(v): float
    properties: create, query
    The percent value to be applied. The default is 1. In query mode,
returns an array of doubles corresponding to the weights of the
selected object components.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/percent.html 
    """


def performanceOptions(flagclusterResolution: float, flagdisableStitch: string, flagdisableTrimBoundaryDisplay: string, flagdisableTrimDisplay: string, flaglatticeResolution: float, flagpassThroughBindSkinAndFlexors: string, flagpassThroughBlendShape: string, flagpassThroughCluster: string, flagpassThroughDeltaMush: string, flagpassThroughFlexors: string, flagpassThroughLattice: string, flagpassThroughMeshBoolean: string, flagpassThroughPaintEffects: string, flagpassThroughSculpt: string, flagpassThroughWire: string, flagregionOfEffect: string, flagskipHierarchyTraversal: boolean, flaguseClusterResolution: string, flaguseLatticeResolution: string) -> float | string:
    """Synopsis:
---
---
 performanceOptions([clusterResolution=float], [disableStitch=string], [disableTrimBoundaryDisplay=string], [disableTrimDisplay=string], [latticeResolution=float], [passThroughBindSkinAndFlexors=string], [passThroughBlendShape=string], [passThroughCluster=string], [passThroughDeltaMush=string], [passThroughFlexors=string], [passThroughLattice=string], [passThroughMeshBoolean=string], [passThroughPaintEffects=string], [passThroughSculpt=string], [passThroughWire=string], [regionOfEffect=string], [skipHierarchyTraversal=boolean], [useClusterResolution=string], [useLatticeResolution=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

performanceOptions is undoable, queryable, and NOT editable.
Performance options that are in effect may be on all the time, or they can be
turned on only for interaction.  In the latter case, the options will only
take effect during UI interaction or playback.

Note that none of these performance options will affect rendering.




Example:
---
import maya.cmds as cmds

Disable the generation of stitch surfaces
cmds.performanceOptions( ds=1 )

Put sculpt deformers into pass-through mode during interaction/playback
cmds.performanceOptions( ps='interactive' )

---
Return:
---


    string: One of "on", "off", or "interactive" giving the state of the option
    float: Global resolution value

Flags:
---


---
clusterResolution(cr): float
    properties: query
    Sets the global cluster resolution.  This value may range between
0.0 (exact calculation) and 10.0 (rough approximation)

---
disableStitch(ds): string
    properties: query
    Sets the state of stitch surface disablement.  Setting this
to "on" suppresses the generation of stitch surfaces.
Valid values are "on", "off", "interactive".

---
disableTrimBoundaryDisplay(dtb): string
    properties: query
    Sets the state of trim boundary drawing disablement.  Setting this
to "on" suppresses the drawing of surface trim boundaries.
Valid values are "on", "off", "interactive".

---
disableTrimDisplay(dt): string
    properties: query
    Sets the state of trim drawing disablement.  Setting this
to "on" suppresses the drawing of surface trims.
Valid values are "on", "off", "interactive".

---
latticeResolution(lr): float
    properties: query
    Sets the global lattice resolution.  This value may range between
0.0 (exact calculation) and 1.0 (rough approximation)

---
passThroughBindSkinAndFlexors(pbf): string
    properties: query
    Sets the state of bind skin and all flexors pass through.
Valid values are "on", "off", "interactive".

---
passThroughBlendShape(pbs): string
    properties: query
    Sets the state of blend shape deformer pass through.
Valid values are "on", "off", "interactive".

---
passThroughCluster(pc): string
    properties: query
    Sets the state of cluster deformer pass through.
Valid values are "on", "off", "interactive".

---
passThroughDeltaMush(pdm): string
    properties: query
    Sets the state of delta mush deformer pass through.
Valid values are "on", "off", "interactive".

---
passThroughFlexors(pf): string
    properties: query
    Sets the state of flexor pass through.
Valid values are "on", "off", "interactive".

---
passThroughLattice(pl): string
    properties: query
    Sets the state of lattice deformer pass through.
Valid values are "on", "off", "interactive".

---
passThroughMeshBoolean(pmb): string
    properties: query
    Sets the state of mesh booleans pass through.
Valid values are "on", "off", "interactive".

---
passThroughPaintEffects(pp): string
    properties: query
    Sets the state of paint effects pass through.
Valid values are "on", "off", "interactive".

---
passThroughSculpt(ps): string
    properties: query
    Sets the state of sculpt deformer pass through.
Valid values are "on", "off", "interactive".

---
passThroughWire(pw): string
    properties: query
    Sets the state of wire deformer pass through.
Valid values are "on", "off", "interactive".

---
regionOfEffect(roe): string
    properties: query
    When enabled, an interactive update of translation commands will attempt to
determine which components are being changed and only update effected components
as a performance optimization while dragging a manip.

---
skipHierarchyTraversal(sht): boolean
    properties: query
    When enabled, hierarchy traversal of invisible objects in the scene will be
disabled in order to increase performance however this has a side effect of
performing redundant viewport refreshes on certain actions such as manipulations,
start/end of playback, idle refresh calls, etc.

---
useClusterResolution(ucr): string
    properties: query
    Sets the state of cluster deformer global resolution.  This
allows clusters to be calculated at a lower resolution.
Valid values are "on", "off", "interactive".

---
useLatticeResolution(ulr): string
    properties: query
    Sets the state of lattice deformer global resolution.  This
allows lattices to be calculated at a lower resolution.
Valid values are "on", "off", "interactive".

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/performanceOptions.html 
    """


def pfxstrokes(flagfilename: string, flagpostCallback: boolean, flagselected: boolean) -> None:
    """Synopsis:
---
---
 pfxstrokes([filename=string], [postCallback=boolean], [selected=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pfxstrokes is NOT undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

cmds.pfxstrokes( fn='/tmp/output_file' )

---


Flags:
---


---
filename(fn): string
    properties: create
    The output file.

---
postCallback(pc): boolean
    properties: create
    Output information to the file after the Runtime Callback MEL function has been invoked. The default
is to output the information prior to the callback.

---
selected(sl): boolean
    properties: create
    Only loop through the selected strokes.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pfxstrokes.html 
    """


def pickWalk(flagdirection: string, flagrecurse: boolean, flagtype: string) -> list[string]:
    """Synopsis:
---
---
 pickWalk(
[objects]
    , [direction=string], [recurse=boolean], [type=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pickWalk is undoable, NOT queryable, and NOT editable.
If the -type flag is instances, then the left and right direction will
walk to the previous or next instance of the same selected dag node.




Example:
---
import maya.cmds as cmds

Given the transforms A and B which are parented to a transform C,
and C is instanced with parents D and E.

cmds.pickWalk( 'A', direction='right' )

cmds.select('|E|C')
cmds.pickWalk( type='instances', direction='left')

The pickWalk command also works on CVs and edit points
cmds.select('nurbsPlaneShape1.cv[2][1]')
cmds.pickWalk(direction='right' )
Result: nurbsPlaneShape1.cv[3][1] ---


cmds.pickWalk( direction='up' )
Result: nurbsPlaneShape1.cv[3][2] ---


cmds.select( 'curveShape2.ep[1]' )
cmds.pickWalk( direction='left' )
Result: curveShape2.ep[0] ---


---
Return:
---


    list[string]: A list of the newly selected items

Flags:
---


---
direction(d): string
    properties: create
    The direction to walk from the node. The choices are
up | down | left | right | in | out. up walks to the parent node,
down to the child node, and left and right to the sibling nodes.
If a CV on a surface is selected, the left and right directions walk
in the U parameter direction of the surface, and the up and down directions
walk in the V parameter direction.
In and out are only used if the type flag is 'latticepoints'.
Default is right.

---
recurse(r): boolean
    properties: create
    If specified then recurse down when walking

---
type(typ): string
    properties: create
    The choices are nodes | instances | edgeloop | edgering | faceloop | keys | latticepoints | motiontrailpoints.
If type is nodes, then the left and right direction walk to the next dag siblings.
If type is instances, the left and right direction walk to the previous or next
instance of the same dag node.
If type is edgeloop, then the edge loop starting at the first selected edge will
be selected.
If type is edgering, then the edge ring starting at the first selected edge will
be selected.
If type is faceloop, and there are two connected quad faces selected which define
a face loop, then that face loop will be selected.

edgeloop, edgering and faceloop all remember which was the first edge or faces
selected for as long as consecutive selections are made by this command.  They
use this information to determine what the "next" loop or ring selection should
be.  Users can make selections forwards and backwards by using the direction
flag with "left" or "right".

If type is motiontrailpoints, then the left and right direction walk to the previous
or next motion trail points respectively.

Default is nodes.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pickWalk.html 
    """


def picture(flagannotation: string, flagbackgroundColor: tuple[float, float, float], flagdefineTemplate: string, flagdocTag: string, flagdragCallback: script, flagdropCallback: script, flagenable: boolean, flagenableBackground: boolean, flagenableKeyboardFocus: boolean, flagexists: boolean, flagfullPathName: boolean, flagheight: int, flaghighlightColor: tuple[float, float, float], flagimage: string, flagisObscured: boolean, flagmanage: boolean, flagnoBackground: boolean, flagnumberOfPopupMenus: boolean, flagparent: string, flagpopupMenuArray: boolean, flagpreventOverride: boolean, flagstatusBarMessage: string, flagtile: boolean, flaguseTemplate: string, flagvisible: boolean, flagvisibleChangeCommand: script, flagwidth: int) -> string:
    """Synopsis:
---
---
 picture(
[string]
    , [annotation=string], [backgroundColor=[float, float, float]], [defineTemplate=string], [docTag=string], [dragCallback=script], [dropCallback=script], [enable=boolean], [enableBackground=boolean], [enableKeyboardFocus=boolean], [exists=boolean], [fullPathName=boolean], [height=int], [highlightColor=[float, float, float]], [image=string], [isObscured=boolean], [manage=boolean], [noBackground=boolean], [numberOfPopupMenus=boolean], [parent=string], [popupMenuArray=boolean], [preventOverride=boolean], [statusBarMessage=string], [tile=boolean], [useTemplate=string], [visible=boolean], [visibleChangeCommand=script], [width=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

picture is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

window = cmds.window()
cmds.columnLayout()
cmds.picture( image='sphere.png' )
cmds.showWindow( window )

---
Return:
---


    string: The name of the picture control created.

Flags:
---


---
annotation(ann): string
    properties: create, query, edit
    Annotate the control with an extra string value.

---
backgroundColor(bgc): [float, float, float]
    properties: create, query, edit
    The background color of the control. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0.
When setting backgroundColor, the background is automatically
enabled, unless enableBackground is also specified with a false
value.

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
docTag(dtg): string
    properties: create, query, edit
    Add a documentation flag to the control.  The documentation flag
has a directory structure.
(e.g., -dt render/multiLister/createNode/material)

---
dragCallback(dgc): script
    properties: create, edit
    Adds a callback that is called when the middle mouse button
is pressed.  The MEL version of the callback is of the form:

global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods)

The proc returns a string array that is transferred to the drop site.
By convention the first string in the array describes the user settable
message type.  Controls that are application defined drag sources may
ignore the callback. $mods allows testing for the key modifiers CTRL and
SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTRL,
3 == CTRL + SHIFT.

In Python, it is similar, but there are two ways to specify the callback.  The
recommended way is to pass a Python function object as the argument.  In that
case, the Python callback should have the form:

def callbackName( dragControl, x, y, modifiers ):

The values of these arguments are the same as those for the MEL version above.

The other way to specify the callback in Python is to specify a string to be
executed.  In that case, the string will have the values substituted into it
via the standard Python format operator.  The format values are passed in a
dictionary with the keys "dragControl", "x", "y", "modifiers".  The
"dragControl" value is a string and the other values are integers (eg the
callback string could be "print '%(dragControl)s %(x)d %(y)d %(modifiers)d'")

---
dropCallback(dpc): script
    properties: create, edit
    Adds a callback that is called when a drag and drop
operation is released above the drop site.  The MEL version of the callback is
of the form:

global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type)

The proc receives a string array that is transferred from the drag source.
The first string in the msgs array describes the user defined message type.
Controls that are application defined drop sites may ignore the
callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link.

In Python, it is similar, but there are two ways to specify the callback.  The
recommended way is to pass a Python function object as the argument.  In that
case, the Python callback should have the form:

def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ):

The values of these arguments are the same as those for the MEL version above.

The other way to specify the callback in Python is to specify a string to be
executed.  In that case, the string will have the values substituted into it
via the standard Python format operator.  The format values are passed in a
dictionary with the keys "dragControl", "dropControl", "messages", "x", "y",
"type".  The "dragControl" value is a string and the other values are integers
(eg the callback string could be
"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'")

---
enable(en): boolean
    properties: create, query, edit
    The enable state of the control.  By default, this flag is
set to true and the control is enabled.  Specify false and the control
will appear dimmed or greyed-out indicating it is disabled.

---
enableBackground(ebg): boolean
    properties: create, query, edit
    Enables the background color of the control.

---
enableKeyboardFocus(ekf): boolean
    properties: create, query, edit
    If enabled, the user can navigate to the control with the tab key and select values with the keyboard or mouse.
This flag would typically be used to turn off focus support from controls that get it by default, like Edit and List controls.
If disabled, text in text fields can still be selected with the mouse but cannot be copied (except on Linux when "Middle Click Paste" is enabled).

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
fullPathName(fpn): boolean
    properties: query
    Return the full path name of the widget, which includes all the parents.

---
height(h): int
    properties: create, query, edit
    The height of the control.  The control will attempt to
be this size if it is not overruled by parent layout conditions.

---
highlightColor(hlc): [float, float, float]
    properties: create, query, edit
    The highlight color of the control. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0.

---
image(i): string
    properties: create, query, edit
    Sets the image given the .xpm file name.

---
isObscured(io): boolean
    properties: query
    Return whether the control can actually be seen by the user.
The control will be obscured if its state is invisible, if it is
blocked (entirely or partially) by some other control, if it or a
parent layout is unmanaged, or if the control's window is
invisible or iconified.

---
manage(m): boolean
    properties: create, query, edit
    Manage state of the control.  An unmanaged control is
not visible, nor does it take up any screen real estate.  All
controls are created managed by default.

---
noBackground(nbg): boolean
    properties: create, edit
    Clear/reset the control's background.
Passing true means the background should not be drawn at all, false means the background should be drawn.  The state of this flag is inherited by children of this control.

---
numberOfPopupMenus(npm): boolean
    properties: query
    Return the number of popup menus attached to this control.

---
parent(p): string
    properties: create, query
    The parent layout for this control.

---
popupMenuArray(pma): boolean
    properties: query
    Return the names of all the popup menus attached to this
control.

---
preventOverride(po): boolean
    properties: create, query, edit
    If true, this flag prevents overriding the control's
attribute via the control's right mouse button menu.

---
statusBarMessage(sbm): string
    properties: create, edit
    Extra string to display in the status bar when the mouse is over the control.

---
tile(tl): boolean
    properties: create, query, edit
    If true, the picture is tiled to fill the picture area. False
by default. (Windows only flag)

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

---
visible(vis): boolean
    properties: create, query, edit
    The visible state of the control.  A control is created
visible by default.  Note that a control's actual appearance is
also dependent on the visible state of its parent layout(s).

---
visibleChangeCommand(vcc): script
    properties: create, query, edit
    Command that gets executed when visible state of the control changes.

---
width(w): int
    properties: create, query, edit
    The width of the control.  The control will attempt to
be this size if it is not overruled by parent layout conditions.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/picture.html 
    """


def pixelMove() -> None:
    """Synopsis:
---
---
 pixelMove(
float float
    )  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pixelMove is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

move selected objects to the right (in current view) by one "pixel"
cmds.pixelMove( 1, 0 )

move selected objects up by one "pixel"
cmds.pixelMove( 0, 1 )

---


Flags:
---


URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pixelMove.html 
    """


def planarSrf(flagcaching: boolean, flagconstructionHistory: boolean, flagdegree: int, flagkeepOutside: boolean, flagname: string, flagnodeState: int, flagobject: boolean, flagpolygon: int, flagrange: boolean, flagtolerance: linear) -> list[string]:
    """Synopsis:
---
---
 planarSrf(
objects
    , [caching=boolean], [constructionHistory=boolean], [degree=int], [keepOutside=boolean], [name=string], [nodeState=int], [object=boolean], [polygon=int], [range=boolean], [tolerance=linear])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

planarSrf is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

create linear planar trimmed surface given boundary curve(s)
cmds.planarSrf( d=1 )

use boundary curve(s) to create a hole by
keeping the outside trimmed regions
cmds.planarSrf( ko=True)

---
Return:
---


    list[string]: Object name and node name

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
degree(d): int
    properties: create, query, edit
    The degree of the resulting surface:
1 - linear,
3 - cubic
Default: 3

---
keepOutside(ko): boolean
    properties: create, query, edit
    If true, keep the regions outside the given curves.
Default: false

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
tolerance(tol): linear
    properties: create, query, edit
    The distance tolerance for the cvs of the curves to be in the same plane.
Default: 0.01

---
constructionHistory(ch): boolean
    properties: create
    Turn the construction history on or off.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node.

---
polygon(po): int
    properties: create
    The value of this argument controls the type of the object
created by this operation

 0: nurbs surface
 1: polygon (use nurbsToPolygonsPref to set the parameters for the conversion)
 2: subdivision surface (use nurbsToSubdivPref to set the parameters for the conversion)
 3: Bezier surface
 4: subdivision surface solid (use nurbsToSubdivPref to set the
parameters for the conversion)

---
range(rn): boolean
    properties: create
    Force a curve range on complete input curve.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/planarSrf.html 
    """


def plane(flaglength: linear, flagname: string, flagposition: tuple[linear, linear, linear], flagrotation: tuple[angle, angle, angle], flagsize: linear, flagwidth: linear) -> string:
    """Synopsis:
---
---
 plane([length=linear], [name=string], [position=[linear, linear, linear]], [rotation=[angle, angle, angle]], [size=linear], [width=linear])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

plane is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

Creates a plane of size (10x10) with center at (1,1,1)
cmds.plane( p=(1, 1, 1), s=10 )

Creates a plane of size (10x10) with center at (1,1,1) using various units
cmds.plane( p=('1ft', '1ft', '1ft'), s='10in', r=('30deg', '30deg', '45deg') )

---
Return:
---


    string: (name of the new plane)

Flags:
---


---
length(l): linear
    properties: create
    The length of plane.
"linear" means that this flag can handle values with units.

---
name(n): string
    properties: create
    Name the resulting object.

---
position(p): [linear, linear, linear]
    properties: create
    3D position where the centre of the plane is positioned.
"linear" means that this flag can handle values with units.

---
rotation(r): [angle, angle, angle]
    properties: create
    The rotation of plane.
"angle" means that this flag can handle values with units.

---
size(s): linear
    properties: create
    The combined size (size x size) of plane.
"linear" means that this flag can handle values with units.

---
width(w): linear
    properties: create
    The width of plane.
"linear" means that this flag can handle values with units.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/plane.html 
    """


def play(flagforward: boolean, flagplaySound: boolean, flagrecord: boolean, flagsound: string, flagstate: boolean, flagwait: boolean) -> None:
    """Synopsis:
---
---
 play([forward=boolean], [playSound=boolean], [record=boolean], [sound=string], [state=boolean], [wait=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

play is undoable, queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

Begin playback from min to max
---

cmds.play( forward=True )

Begin playback from max to min
---

cmds.play( forward=False )

Stop (forward or backward) playback
---

cmds.play( state=False )

Record mode through one playback loop
---

cmds.play( record=True )

Are we playing back?  Returns 1 if yes, 0 if no.
---

cmds.play( q=True, state=True )

---


Flags:
---


---
forward(f): boolean
    properties: create, query
    When true, play back the animation from the
currentTime to the maximum of the playback range.
When false, play back from the currentTime to the
minimum of the playback range.  When queried,
returns an int.

---
playSound(ps): boolean
    properties: create, query
    Specify whether or not sound should be used during playback

---
record(rec): boolean
    properties: create, query
    enable the recording system and start one playback loop

---
sound(s): string
    properties: create, query
    Specify the sound node to be used during playback

---
state(st): boolean
    properties: create, query
    start or stop playing back

---
wait(w): boolean
    properties: create
    Wait till completion before returning control to
command Window.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/play.html 
    """


def playbackOptions(flaganimationEndTime: time, flaganimationStartTime: time, flagblockingAnim: boolean, flagby: float, flagframesPerSecond: boolean, flagloop: string, flagmaxPlaybackSpeed: float, flagmaxTime: time, flagminTime: time, flagplaybackSpeed: float, flagselectionEndTime: time, flagselectionStartTime: time, flagselectionVisible: boolean, flagstepLoop: boolean, flagview: string) -> string:
    """Synopsis:
---
---
 playbackOptions([animationEndTime=time], [animationStartTime=time], [blockingAnim=boolean], [by=float], [framesPerSecond=boolean], [loop=string], [maxPlaybackSpeed=float], [maxTime=time], [minTime=time], [playbackSpeed=float], [selectionEndTime=time], [selectionStartTime=time], [selectionVisible=boolean], [stepLoop=boolean], [view=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

playbackOptions is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.playbackOptions( loop='continuous' )
cmds.playbackOptions( minTime='0sec', maxTime='1sec' )
cmds.playbackOptions( selectionStartTime='0sec', selectionEndTime='1sec' )
cmds.playbackOptions( selectionVisible=False )

Playback every 2nd frame
---

cmds.playbackOptions( by=2 )

---
Return:
---


    string: or float
Query of edited option.

Flags:
---


---
animationEndTime(aet): time
    properties: create, query, edit
    Sets the end time of the animation.  Query returns a float.

---
animationStartTime(ast): time
    properties: create, query, edit
    Sets the start time of the animation.  Query returns a float.

---
blockingAnim(ba): boolean
    properties: create, query
    All tangents playback as stepped so that animation can be viewed in pure pose-to-pose form

---
by(by): float
    properties: create, query, edit
    Increment between times viewed during playback. (Default 1.0)

---
framesPerSecond(fps): boolean
    properties: create, query
    Queries the actual playback rate.  Query returns a float.

---
loop(l): string
    properties: create, query, edit
    Controls if and how playback repeats.  Valid values are
"once," "continuous," and "oscillate."  Query returns string.

---
maxPlaybackSpeed(mps): float
    properties: create, query, edit
    Sets the desired maximum playback speed.  Query returns a float. The
maxPlaybackSpeed is only used by Maya when your playbackSpeed is 0
(play every frame). The maxPlaybackSpeed will clamp the maximum
playback rate to prevent it from going more than a certain amount. A
maxPlaybackSpeed of 0 will give free (unclamped) playback.

---
maxTime(max): time
    properties: create, query, edit
    Sets the end of the playback time range.  Query returns a float.

---
minTime(min): time
    properties: create, query, edit
    Sets the start of the playback time range.  Query returns a float.

---
playbackSpeed(ps): float
    properties: create, query, edit
    Sets the desired playback speed.  Query returns a float.

---
selectionEndTime(set) 2024: time
    properties: create, query, edit
    Sets the end time of the selection.  Query returns a float.

---
selectionStartTime(sst) 2024: time
    properties: create, query, edit
    Sets the start time of the selection.  Query returns a float.

---
selectionVisible(sv) 2024: boolean
    properties: create, query, edit
    Sets the selection visibility. Query returns current visibility.

---
stepLoop(slp): boolean
    properties: create, query
    Turns on/off looping back to the start or end of the play range for step forward/backward one frame and step forward/backward one key.

---
view(v): string
    properties: create, query, edit
    Controls how many modelling views update during playback.
Valid values are "all" and "active".  Query returns a string.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/playbackOptions.html 
    """


def playblast(flagactiveEditor: boolean, flagcameraSetup: tuple[string, string], flagclearCache: boolean, flagcodecOptions: boolean, flagcombineSound: boolean, flagcompleteFilename: string, flagcompression: string, flageditorPanelName: string, flagendTime: time, flagfilename: string, flagforceOverwrite: boolean, flagformat: string, flagframe: time, flagframePadding: int, flagheight: int, flagindexFromZero: boolean, flagoffScreen: boolean, flagoffScreenViewportUpdate: boolean, flagoptions: boolean, flagpercent: int, flagquality: int, flagrawFrameNumbers: boolean, flagreplaceAudioOnly: boolean, flagreplaceEndTime: time, flagreplaceFilename: string, flagreplaceStartTime: time, flagsequenceTime: boolean, flagshowOrnaments: boolean, flagsound: string, flagstartTime: time, flagthrowOnError: boolean, flaguseTraxSounds: boolean, flagviewer: boolean, flagwidth: int, flagwidthHeight: tuple[int, int]) -> string:
    """Synopsis:
---
---
 playblast(
filename
    , [activeEditor=boolean], [cameraSetup=[string, string]], [clearCache=boolean], [codecOptions=boolean], [combineSound=boolean], [completeFilename=string], [compression=string], [editorPanelName=string], [endTime=time], [filename=string], [forceOverwrite=boolean], [format=string], [frame=time], [framePadding=int], [height=int], [indexFromZero=boolean], [offScreen=boolean], [offScreenViewportUpdate=boolean], [options=boolean], [percent=int], [quality=int], [rawFrameNumbers=boolean], [replaceAudioOnly=boolean], [replaceEndTime=time], [replaceFilename=string], [replaceStartTime=time], [sequenceTime=boolean], [showOrnaments=boolean], [sound=string], [startTime=time], [throwOnError=boolean], [useTraxSounds=boolean], [viewer=boolean], [width=int], [widthHeight=[int, int]])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

playblast is undoable, NOT queryable, and NOT editable.
Note that the playblast command registers a condition called "playblasting"
so that users can monitor whether playblasting is occurring. You may monitor the
condition using the API (MConditionMessage) or a script (scriptJob and condition
commands).




Example:
---
import maya.cmds as cmds

Run movieplayer on the currently playblasted range
(including sound) and save the movie to a file.
---

cmds.playblast( s="ohNo", f="myMovie.mv" )

Run movieplayer on the currently playblasted range
(at 60% of the size of the current view), and
save the movie to file "myMovie.mv" and don't
launch any viewing program.
---

cmds.playblast( p=60, s="ohNo", f="myMovie.mv", v=False )

Output frames 2, 3, 8 as images and launch the viewer;
---

cmds.playblast( frame=[8,3,2], format="image", viewer=True )

Output an image sequence in 'gif' format
---

cmds.playblast( format="image", compression="gif" )

Output depth with image in 'iff' format
---

cmds.playblast( format="image", compression="maya", saveDepth=True )

---
Return:
---


    string: Name of moviefile created.

Flags:
---


---
activeEditor(ae): boolean
    properties: create
    This flag will return the current model editor that would be used
for playblast. It does not invoke playblast itself.

---
cameraSetup(cs): [string, string]
    properties: create, multiuse
    Information about camera setup. The first string defines a camera setup MEL procedure.
The camera setup procedure will be invoked before executing a playblast.
The second string argument which is used as a camera identifier and is
appended to the root file name to specify the final output file name(s).
The command will fail there is not a pair of strings supplied to the argument.

---
clearCache(cc): boolean
    properties: create
    When true, all previous temporary playblast files will be deleted
before the new playblast files are created and the remaining temporary
playblast files will be deleted when the application quits.
Any playblast files that were explicitly given a name by the user will not be deleted.

---
codecOptions(co): boolean
    properties: create
    Brings up the OS specific dialog for setting playblast codec options, and
does not run the playblast.

---
combineSound(csd): boolean
    properties: create
    Combine the trax sounds into a single track. This might force a
resampling of the sound if the sound paramters don't match up.

---
completeFilename(cf): string
    properties: create
    When set, this string specifies the exact name of the output image.
In contrast with the -f/filename flag, -cf/completeFilename does not
append any frame number or extension string at the end of the filename.
Additionally, playblast will not delete the image from disk after it is
displayed. This flag should not be used in conjunction with -f/filename.

---
compression(c): string
    properties: create
    Specify the compression to use for the movie file.  To determine which settings are available on your system, use the
`playblast -options` command. This will display a system-specific dialog with supported compression formats.
When the 'format' flag is 'image', this flag is used to pass in the
desired image format. If the format is 'image' and the compression flag is ommitted,
the output format specified via the Render Globals preference (see -format) will be used.
If compression is set to 'none', the iff image format will be used.

---
editorPanelName(epn): string
    properties: create
    This optional flag specifies the name of the model editor or panel, which is to
be used for playblast. The current model editor or panel won't be used for
playblast unless its name is specified. Flag usage is specific to invoking
playblast.

---
endTime(et): time
    properties: create
    Specify the end time of the playblast.  Default
is the end time of the playback range displayed in
the Time Slider. Overridden by -frame.

---
filename(f): string
    properties: create
    The filename to use for the output of this playblast.
If the file already exists, a confirmation box will be
displayed if playblast is performed interactively.  If
playblast is executed from the command line and the file
already exists, it will abort.

---
forceOverwrite(fo): boolean
    properties: create
    Overwrite existing playblast files which may have the
the same name as the one specified with the "-f" flag

---
format(fmt): string
    properties: create
    The format for the playblast output.



ValueDescription


"movie"
This option selects a platform-specific default movie format.
On Linux and Mac OSX the default movie format is Quicktime.
On Windows the default movie format is Audio Video Interleave.



"avi"
Set the format to Audio Video Interleave (Windows only)


"qt"
Set the format to QuickTime (all platforms).


"avfoundation"
Write movie by AVFoundation (Mac only).


"image"
Outputs a sequence of image files.
The image format will be the Output Format specified using Window > RenderEditors > RenderSettings > CommonTab.
The resulting files use the value of the "-f" flag as a prefix, with an
appended frame number, as in "myFile.0007.iff"


"iff"
Same as "image"



The default value of the -fmt/format flag is "movie".
Depending on the selected format, a platform-specific default application will be used to view results.
For image sequences, the default application is "fcheck".
For movies, the default application is Windows Media Player (on Windows),
Quicktime Player (on Mac OSX), and Lqtplay (on Linux).
Users can specify different applications via Maya's application preferences.

---
frame(fr): time
    properties: create, multiuse
    List of frames to blast. One frame specified per flag.
The frames can be specified in any order but will be output
in an ordered sequence. When specified this flag will override any
start/end range

---
framePadding(fp): int
    properties: create
    Number of zeros used to pad file name. Typically set to 4 to support fcheck.

---
height(h): int
    properties: create
    Height of the final image. This value will be clamped if larger
than the width of the active window.
Windows: If not using fcheck, the width and height must each be divisible
by 4.

---
indexFromZero(ifz): boolean
    properties: create
    Output frames starting with file.0000.ext and incrementing by one. Typically
frames use the Maya time as their frame number. This option can only be used
for frame based output formats.

---
offScreen(os): boolean
    properties: create
    When set, this toggle allow playblast to use an offscreen buffer
to render the view. This allows playblast to work when the application
is iconified, or obscured.

---
offScreenViewportUpdate(osv): boolean
    properties: create
    When set, this toggle allows playblast to update the viewport
while rendering with the offscreen buffer.

---
options(o): boolean
    properties: create
    Brings up a dialog for setting playblast options, and
does not run the playblast.

---
percent(p): int
    properties: create
    Percentage of current view size  to use during blasting.
Accepted values are integers between 10 and 100.  All other
values are clamped to be within this range.  A value of 25
means 1/4 of the  current view size; a  value of 50  means
half the current view size; a value of 100 means full
size.  (Default is 50.)

---
quality(qlt): int
    properties: create
    Specify the compression quality factor to use for the movie file.
Value should be in the 0-100 range

---
rawFrameNumbers(rfn): boolean
    properties: create
    Playblast typically numbers its frames sequentially, starting at zero.
This flag will override the default action and frames will be numbered using the
actual frames specified by the -frame or -startFrame/-endFrame flags.

---
replaceAudioOnly(rao): boolean
    properties: create
    When set, this string dictates that only the audio will be replaced when
the scene is re-playblasted.

---
replaceEndTime(ret): time
    properties: create
    Specify the end time of a replayblast of an existing
playblast.  Default is the start time of the playback
range displayed in the Time Slider. Overridden by -frame.

---
replaceFilename(rf): string
    properties: create
    When set, this string specifies the name of an input playblast file which
will have frames replaced according to the replace start and end times.

---
replaceStartTime(rst): time
    properties: create
    Specify the start time of a replayblast of an existing
playblast.  Default is the start time of the playback
range displayed in the Time Slider. Overridden by -frame.

---
sequenceTime(sqt): boolean
    properties: create
    Use sequence time

---
showOrnaments(orn): boolean
    properties: create
    Sets whether or not model view ornaments (e.g. the axis icon)
should be displayed

---
sound(s): string
    properties: create
    Specify the sound node to be used during playblast

---
startTime(st): time
    properties: create
    Specify the start time of the playblast.  Default
is the start time of the playback range displayed in
the Time Slider. Overridden by -frame.

---
throwOnError(toe): boolean
    properties: create
    Playblast is tolerant of failures in most situations. When set,
this toggle allows playblast to throw an error on these failures.

---
useTraxSounds(uts): boolean
    properties: create
    Use sounds from TRAX.

---
viewer(v): boolean
    properties: create
    Specify whether a viewer should be launched for the
playblast.  Default is "true".  Runs "fcheck" when -fmt is "image".
The player for movie files depends on the OS: Windows uses Microsoft Media
Player, Irix uses movieplayer, OSX uses QuickTime.

---
width(w): int
    properties: create
    Width of the final image. This value will be clamped if larger than
the width of the active window.
Windows: If not using fcheck, the width and height must each be divisible
by 4.

---
widthHeight(wh): [int, int]
    properties: create
    Final image's width and height.
Values larger than the dimensions of the active window are clamped.
A width and height of 0 means to use the window's current
size.
Windows: If not using fcheck, the width and height must each be divisible
by 4.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/playblast.html 
    """


def pluginDisplayFilter(flagclassification: string, flagderegister: boolean, flagexists: boolean, flaglabel: string, flaglistFilters: boolean, flagregister: boolean) -> string:
    """Synopsis:
---
---
 pluginDisplayFilter([classification=string], [deregister=boolean], [exists=boolean], [label=string], [listFilters=boolean], [register=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pluginDisplayFilter is NOT undoable, queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

   Register a plugin display filter.
---

cmds.pluginDisplayFilter('myDisplayFilter', register = 1, label = 'My Display Filter', classification = 'drawdb/geometry/myShape')

   Deregister a plugin display filter.
---

cmds.pluginDisplayFilter('myDisplayFilter', deregister = 1)

   List all plugin display filters.
---

filters = cmds.pluginDisplayFilter(q = 1, listFilters = 1)

   Query the label of a display filter
---

label = cmds.pluginDisplayFilter('myDisplayFilter', q = 1, label = 1)

---
Return:
---


    string: string[]

Flags:
---


---
classification(cls): string
    properties: create, query
    The classification used to filter objects in Viewport 2.0.
This classification is the same as MFnPlugin::registerNode().
If the node was registered with multiple classifications, use the one beginning with "drawdb".
The default value of this flag is an empty string (""). It will not
filter any objects in Viewport 2.0.

---
deregister(dr): boolean
    properties: create
    Deregister a plugin display filter.

---
exists(ex): boolean
    properties: create
    Returns true if the specified filter exists, false otherwise.
Other flags are ignored.

---
label(l): string
    properties: create, query
    The string to be displayed for this filter in the UI. E.g. in the 'Show' menu of a model panel.
The default value of this flag is the same as the plugin display filter name.

---
listFilters(lf): boolean
    properties: query
    Returns an array of all plugin display filters.

---
register(r): boolean
    properties: create
    Register a plugin display filter.
The -register is implied if both -register and -deregister flags are missing in create mode.
You are responsible for deregistering any filters which you register.
Filters are reference counted, meaning that if you register the same filter twice
then you will have to deregister it twice as well.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pluginDisplayFilter.html 
    """


def pluginInfo(flagactiveFile: boolean, flagallEvaluators: boolean, flaganimCurveInterp: string, flagapiVersion: boolean, flagautoload: boolean, flagcacheFormat: boolean, flagchangedCommand: script, flagcommand: string, flagconstraintCommand: boolean, flagcontrolCommand: boolean, flagdata: tuple[string, string], flagdependNode: boolean, flagdependNodeByType: string, flagdependNodeId: string, flagdevice: boolean, flagdragAndDropBehavior: boolean, flagevaluator: boolean, flagiksolver: boolean, flaglistPlugins: boolean, flaglistPluginsPath: boolean, flagloadPluginPrefs: boolean, flagloaded: boolean, flagmodelEditorCommand: boolean, flagname: string, flagpath: string, flagpluginsInUse: boolean, flagreferenceTranslators: boolean, flagregistered: boolean, flagremove: boolean, flagrenderer: boolean, flagsavePluginPrefs: boolean, flagserviceDescriptions: boolean, flagsettings: boolean, flagtool: string, flagtranslator: boolean, flagunloadOk: boolean, flaguserNamed: boolean, flagvendor: string, flagversion: boolean, flagwriteRequires: boolean) -> Any:
    """Synopsis:
---
---
 pluginInfo(
[string]
    , [activeFile=boolean], [allEvaluators=boolean], [animCurveInterp=string], [apiVersion=boolean], [autoload=boolean], [cacheFormat=boolean], [changedCommand=script], [command=string], [constraintCommand=boolean], [controlCommand=boolean], [data=[string, string]], [dependNode=boolean], [dependNodeByType=string], [dependNodeId=string], [device=boolean], [dragAndDropBehavior=boolean], [evaluator=boolean], [iksolver=boolean], [listPlugins=boolean], [listPluginsPath=boolean], [loadPluginPrefs=boolean], [loaded=boolean], [modelEditorCommand=boolean], [name=string], [path=string], [pluginsInUse=boolean], [referenceTranslators=boolean], [registered=boolean], [remove=boolean], [renderer=boolean], [savePluginPrefs=boolean], [serviceDescriptions=boolean], [settings=boolean], [tool=string], [translator=boolean], [unloadOk=boolean], [userNamed=boolean], [vendor=string], [version=boolean], [writeRequires=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pluginInfo is undoable, queryable, and editable.
The argument is either the internal name of the plug-in or the path to
access it.




Example:
---
import maya.cmds as cmds

List the plug-ins that are currently loaded
cmds.pluginInfo( query=True, listPlugins=True )

Find the vendor of a plug-in
cmds.pluginInfo( 'newNode.py', query=True, vendor=True )

Find the commands provided by a given plug-in
cmds.pluginInfo( 'helloCmd.py', query=True, command=True )

Turn on autoloading for a plug-in
cmds.pluginInfo( 'newNode.py', edit=True, autoload=True )

Make maya write requires command in the saved file for a plug-in
cmds.pluginInfo( 'pluginName', edit=True, writeRequires=True )

Return all custom locators registered by plug-ins.
cmds.pluginInfo( query=True, dependNodeByType="kLocatorNode" )

---
Return:
---


    Any: Dependent upon the action requested.

Flags:
---


---
activeFile(af): boolean
    properties: query
    Restricts the command to the active file only, not the entire scene.
This only affects the dependNode/dn and pluginsInUse/pu flags.
For use during export selected.

---
allEvaluators(ae): boolean
    properties: query
    Returns a string array containing the names of all of the
evaluator types registered to any plug-in.

---
animCurveInterp(aci): string
    properties: query
    Returns a string array containing the names of all of the
animation curve interpolators registered by this plug-in.

---
apiVersion(av): boolean
    properties: query
    Returns a string containing the version of the API that this
plug-in was compiled with.  See the comments in MTypes.h for the
details on how to interpret this value.

---
autoload(a): boolean
    properties: create, query, edit
    Sets whether or not this plug-in should be loaded every
time the application starts up. Returns a boolean in query mode.

---
cacheFormat(cf): boolean
    properties: query
    Returns a string array containing the names of all of the
registered geometry cache formats

---
changedCommand(cc): script
    properties: create
    Adds a callback that will get executed every time the plug-in
registry changes. Any other previously registered callbacks will
also get called.

---
command(c): string
    properties: query, multiuse
    Returns a string array containing the names of all of the
normal commands registered by this plug-in.
Constraint, control, context and model editor commands are not included.

---
constraintCommand(cnc): boolean
    properties: query
    Returns a string array containing the names of all of the
constraint commands registered by this plug-in.

---
controlCommand(ctc): boolean
    properties: query
    Returns a string array containing the names of all of the
control commands registered by this plug-in.

---
data(d): [string, string]
    properties: query, multiuse
    Returns a string array containing the names of all of the
data types registered by this plug-in.

---
dependNode(dn): boolean
    properties: query, multiuse
    Returns a string array containing the names of all of the
custom nodes types registered by this plug-in.

---
dependNodeByType(dnt): string
    properties: query
    Returns a string array of all registered node types within a specified
class of nodes.  Each custom node type registered by a plug-in belongs
to a more general class of node types as specified by its
MPxNode::Type. The flag's argument is an MPxNode::Type as a string.  For
example, if you want to list all registered Locator nodes, you should
specify kLocatorNode as a argument to this flag.

---
dependNodeId(dni): string
    properties: query
    Returns an integer array containing the ids of all of the
custom node types registered by this plug-in.

---
device(dv): boolean
    properties: query
    Returns a string array containing the names of all of the
devices registered by this plug-in.

---
dragAndDropBehavior(ddb): boolean
    properties: query
    Returns a string array containing the names of all of the
drag and drop behaviors registered by this plug-in.

---
evaluator(e): boolean
    properties: query
    Returns a string array containing the names of all of the
evaluator types registered by this plug-in.

---
iksolver(ik): boolean
    properties: query
    Returns a string array containing the names of all of the
ik solvers registered by this plug-in.

---
listPlugins(ls): boolean
    properties: query
    Returns a string array containing all the plug-ins that are
currently loaded.

---
listPluginsPath(lsp): boolean
    properties: query
    Returns a string array containing the full paths of all the plug-ins that are
currently loaded.

---
loadPluginPrefs(lpp): boolean
    properties: create
    Loads the plug-in preferences (ie. autoload) from pluginPrefs.mel into Maya.

---
loaded(l): boolean
    properties: query
    Returns a boolean specifying whether or not the plug-in is loaded.

---
modelEditorCommand(mec): boolean
    properties: query
    Returns a string array containing the names of all of the
model editor commands registered by this plug-in.

---
name(n): string
    properties: query
    Returns a string containing the internal name by which the
plug-in is registered.

---
path(p): string
    properties: query
    Returns a string containing the absolute path name to the plug-in.

---
pluginsInUse(pu): boolean
    properties: query
    Returns a string array containing all the plug-ins that are
currently being used in the scene.

---
referenceTranslators(rtr): boolean
    properties: query
    If this flag is used in conjunction with the pluginsInUse/pu flag
then it will modify the output. When true it will only show plug-ins currently in use
containing translators that are used to load referenced files. When false it
will only show plug-ins not containing such translators.

---
registered(r): boolean
    properties: query
    Returns a boolean specifying whether or not plug-in is currently
registered with the system.

---
remove(rm): boolean
    properties: edit
    Removes the given plug-in's record from the registry.
There is no return value.

---
renderer(rdr): boolean
    properties: query
    Returns a string array containing the names of all of the
renderers registered by this plug-in.

---
savePluginPrefs(spp): boolean
    properties: create
    Saves the plug-in preferences (ie. autoload) out to pluginPrefs.mel

---
serviceDescriptions(sd): boolean
    properties: query
    If there are services in use, then this flag will return a string
array containing short descriptions saying what those services are.

---
settings(set): boolean
    properties: query
    Returns an array of values with the loaded, autoload, registered flags

---
tool(t): string
    properties: query, multiuse
    Returns a string array containing the names of all of the
tool contexts registered by this plug-in.

---
translator(tr): boolean
    properties: query
    Returns a string array containing the names of all of the
file translators registered by this plug-in.

---
unloadOk(uo): boolean
    properties: query
    Returns a boolean that specifies whether or not the plug-in can
be safely unloaded.  It will return false if the plug-in is currently
in use.  For example, if the plug-in adds a new dependency node type,
and an instance of that node type is present in the scene, then this
query will return false.

---
userNamed(u): boolean
    properties: query
    Returns a boolean specifying whether or not the plug-in has
been assigned a name by the user.

---
vendor(vd): string
    properties: query
    Returns a string containing the vendor of the plug-in.

---
version(v): boolean
    properties: query
    Returns a string containing the version the plug-in.

---
writeRequires(wr): boolean
    properties: create, query, edit
    Sets whether or not this plug-in should write "requires" command
into the saved file. "requires" command could autoload
the plug-in when you open or import that saved file.
This way, Maya will load the plug-in
when a file is being loaded for some specified reason,
such as to create a customized UI or to load some plug-in data
that is not saved in any node or attributes.
For example, "stereoCamera" is using this flag for its customized UI.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pluginInfo.html 
    """


def pointConstraint(flaglayer: string, flagmaintainOffset: boolean, flagname: string, flagoffset: tuple[float, float, float], flagremove: boolean, flagskip: string, flagtargetList: boolean, flagweight: float, flagweightAliasList: boolean) -> list[string]:
    """Synopsis:
---
---
 pointConstraint(
[target...] [object]
    , [layer=string], [maintainOffset=boolean], [name=string], [offset=[float, float, float]], [remove=boolean], [skip=string], [targetList=boolean], [weight=float], [weightAliasList=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pointConstraint is undoable, queryable, and editable.
A pointConstraint takes as input one or more "target" DAG transform
nodes at which to position the single "constraint object" DAG
transform node.  The pointConstraint positions the constrained object
at the weighted average of the world space position target
objects.




Example:
---
import maya.cmds as cmds

Position cube1 at the location of cone1.
cmds.pointConstraint( 'cone1', 'cube1' )

Uses the average of the position of cone1 and surf2.
cmds.pointConstraint( 'cone1', 'surf2', 'cube2', w=.1 )

Sets the weight for cone1's effect on cube2 to 10.
cmds.pointConstraint( 'cone1', 'cube2', e=True, w=10.0 )

Removes surf2 from cube2's pointConstraint
cmds.pointConstraint( 'surf2', 'cube2', e=True, rm=True )

Adds surf3 to cube2's pointConstraint with the default weight
cmds.pointConstraint( 'surf3', 'cube2' )

Constrain the y &amp; z translation of sph2 to sph1
cmds.pointConstraint( 'sph1', 'sph2', skip="x" )

---
Return:
---


    list[string]: Name of the created constraint node

Flags:
---


---
layer(l): string
    properties: create, edit
    Specify the name of the animation layer where the constraint should be added.

---
maintainOffset(mo): boolean
    properties: create
    The offset necessary to preserve the constrained
object's initial position will be calculated and used as the
offset.

---
name(n): string
    properties: create, query, edit
    Sets the name of the constraint node to the specified
name.  Default name is constrainedObjectName_constraintType

---
offset(o): [float, float, float]
    properties: create, query, edit
    Sets or queries the value of the offset. Default is 0,0,0.

---
remove(rm): boolean
    properties: edit
    removes the listed target(s) from the constraint.

---
skip(sk): string
    properties: create, edit, multiuse
    Specify the axis to be skipped. Valid values are "x", "y", "z" and "none". During creation, "none" is the default. This flag is multi-use.

---
targetList(tl): boolean
    properties: query
    Return the list of target objects.

---
weight(w): float
    properties: create, query, edit
    Sets the weight value for the specified target(s).
If not given at creation time, the default value of 1.0 is used.

---
weightAliasList(wal): boolean
    properties: query
    Returns the names of the attributes that control the weight
of the target objects. Aliases are returned in the same order
as the targets are returned by the targetList flag

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pointConstraint.html 
    """


def pointCurveConstraint(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int, flagobject: boolean, flagpointConstraintUVW: tuple[float, float, float], flagpointWeight: float, flagposition: tuple[float, float, float], flagreplaceOriginal: boolean, flagweight: float) -> list[string]:
    """Synopsis:
---
---
 pointCurveConstraint(
selectionItem
    , [caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int], [object=boolean], [pointConstraintUVW=[float, float, float]], [pointWeight=float], [position=[float, float, float]], [replaceOriginal=boolean], [weight=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pointCurveConstraint is undoable, queryable, and editable.
If construction history for the cmd is enabled, a locator is created
to enable subsequent interactive manipulation of the curve. The
locator position may be key framed or transformed and the "curve1"
will try to match the position of the locator.

The argument is a curve location




Example:
---
import maya.cmds as cmds

Apply a constraint to manipulate the  position corresponding to
the 1st edit point on curve1.
cmds.pointCurveConstraint( 'curve1.ep[1]', ch=True )

Apply a constraint to manipulate the end point on curve1.
cmds.pointCurveConstraint( 'curve1.un[1.0]', ch=True, w=1.0 )

Apply a constraint around the midpoint in the parameter domain on curve1.
cmds.pointCurveConstraint( 'curve1.un[0.5]', ch=True, w=-1.0 )

---
Return:
---


    list[string]: Object Name(s), node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
pointConstraintUVW(puv): [float, float, float]
    properties: create, query, edit
    Point constraint parameter space location on input NURBS Object

---
pointWeight(pw): float
    properties: create, query, edit
    Point constraint weight. Determines how strong an influence the constraint has on the input NURBS object.
Default: 1.0

---
position(p): [float, float, float]
    properties: create
    The new desired position in space for the nurbs object
at the specified parameter space component. If not specified,
the position is taken to be the one evaluated at the parameter
space component on the nurbs object.

---
weight(w): float
    properties: create
    weight of the lsq constraint. The larger the weight,
the least squares constraint is strictly met.

---
constructionHistory(ch): boolean
    properties: create
    Turn the construction history on or off.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node.

---
replaceOriginal(rpo): boolean
    properties: create
    Create "in place" (i.e., replace).

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pointCurveConstraint.html 
    """


def pointLight(flagdecayRate: int, flagdiscRadius: linear, flagexclusive: boolean, flagintensity: float, flagname: string, flagposition: tuple[linear, linear, linear], flagrgb: tuple[float, float, float], flagrotation: tuple[angle, angle, angle], flagshadowColor: tuple[float, float, float], flagshadowDither: float, flagshadowSamples: int, flagsoftShadow: boolean, flaguseRayTraceShadows: boolean) -> string:
    """Synopsis:
---
---
 pointLight([decayRate=int], [discRadius=linear], [exclusive=boolean], [intensity=float], [name=string], [position=[linear, linear, linear]], [rgb=[float, float, float]], [rotation=[angle, angle, angle]], [shadowColor=[float, float, float]], [shadowDither=float], [shadowSamples=int], [softShadow=boolean], [useRayTraceShadows=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pointLight is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.pointLight()

---
Return:
---


    string: Light shape name

Flags:
---


---
decayRate(d): int
    properties: create, query, edit
    decay rate of the light (0-no decay, 1-slow, 2-realistic, 3-fast)

---
discRadius(drs): linear
    properties: create, query, edit
    radius of the disc around the light

---
exclusive(exc): boolean
    properties: create, query, edit
    This flag is obsolete.

---
intensity(i): float
    properties: create, query, edit
    intensity of the light (expressed as a percentage)

---
name(n): string
    properties: create, query, edit
    specify the name of the light

---
position(pos): [linear, linear, linear]
    properties: create, query, edit
    This flag is obsolete.

---
rgb(rgb): [float, float, float]
    properties: create, query, edit
    color of the light (0-1)

---
rotation(rot): [angle, angle, angle]
    properties: create, query, edit
    This flag is obsolete.

---
shadowColor(sc): [float, float, float]
    properties: create, query, edit
    the shadow color

---
shadowDither(sd): float
    properties: create, query, edit
    dither the shadow

---
shadowSamples(sh): int
    properties: create, query, edit
    number of shadow samples.

---
softShadow(ss): boolean
    properties: create, query, edit
    soft shadow

---
useRayTraceShadows(rs): boolean
    properties: create, query, edit
    ray trace shadows

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pointLight.html 
    """


def pointOnCurve(flagcaching: boolean, flagconstructionHistory: boolean, flagcurvatureCenter: boolean, flagcurvatureRadius: boolean, flagnodeState: int, flagnormal: boolean, flagnormalizedNormal: boolean, flagnormalizedTangent: boolean, flagparameter: float, flagposition: boolean, flagtangent: boolean, flagturnOnPercentage: boolean) -> float | float[3] | string:
    """Synopsis:
---
---
 pointOnCurve(
[objects]
    , [caching=boolean], [constructionHistory=boolean], [curvatureCenter=boolean], [curvatureRadius=boolean], [nodeState=int], [normal=boolean], [normalizedNormal=boolean], [normalizedTangent=boolean], [parameter=float], [position=boolean], [tangent=boolean], [turnOnPercentage=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pointOnCurve is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.pointOnCurve( 'curve1', pr=0.5, p=True )
Returns the (x,y,z) position of curve1 at parameter 0.5.

cmds.pointOnCurve( 'curve1', pr=0.5 )
Returns the (x,y,z) position of curve1 at parameter 0.5, since
position is the default information.

cmds.pointOnCurve( 'curve1', pr=0.5, nn=True )
Returns the (x,y,z) normalized normal of curve1 at parameter 0.5.

cmds.pointOnCurve( 'curve1', pr=0.5, cr=True )
Returns the curvature radius of curve1 at parameter 0.5.

infoNode = cmds.pointOnCurve('curve1', ch=True, pr=0.55)
cmds.getAttr(infoNode + ".position")  returns the position
cmds.getAttr(infoNode + ".normal")    returns the normal

Returns a string which is the name of a new pointOnCurveInfo
dependency node.  With this node connected to the curve,
the output values of the pointOnCurveInfo node are always current
even if, for example, the parameter is being animated.

---
Return:
---


    float[3]: Vector query result
    float: Single float query result
    string: String query result

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create
    Turn the construction history on or off.

---
curvatureCenter(cc): boolean
    properties: create
    Returns the (x,y,z) center of curvature of the specified point
on the curve

---
curvatureRadius(cr): boolean
    properties: create
    Returns the radius of curvature of the specified point
on the curve

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
normal(no): boolean
    properties: create
    Returns the (x,y,z) normal of the specified point on the curve

---
normalizedNormal(nn): boolean
    properties: create
    Returns the (x,y,z) normalized normal of the specified point
on the curve

---
normalizedTangent(nt): boolean
    properties: create
    Returns the (x,y,z) normalized tangent of the specified point
on the curve

---
parameter(pr): float
    properties: query, edit
    The parameter value on curve
Default: 0.0

---
position(p): boolean
    properties: create
    Returns the (x,y,z) position of the specified point on the curve

---
tangent(t): boolean
    properties: create
    Returns the (x,y,z) tangent of the specified point on the curve

---
turnOnPercentage(top): boolean
    properties: query, edit
    Whether the parameter is normalized (0,1) or not
Default: false

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pointOnCurve.html 
    """


def pointOnPolyConstraint(flaglayer: string, flagmaintainOffset: boolean, flagname: string, flagoffset: tuple[float, float, float], flagremove: boolean, flagskip: string, flagtargetList: boolean, flagweight: float, flagweightAliasList: boolean) -> list[string]:
    """Synopsis:
---
---
 pointOnPolyConstraint(
[target...] [object]
    , [layer=string], [maintainOffset=boolean], [name=string], [offset=[float, float, float]], [remove=boolean], [skip=string], [targetList=boolean], [weight=float], [weightAliasList=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pointOnPolyConstraint is undoable, queryable, and editable.
A pointOnPolyConstraint takes as input one or more "target" DAG transform
nodes at which to position the single "constraint object" DAG
transform node.  The pointOnPolyConstraint positions the constrained object
at the weighted average of the world space position target
objects.




Example:
---
import maya.cmds as cmds

Position cube1 at the location of cone1.
cmds.pointOnPolyConstraint( 'cone1', 'cube1' )

Uses the average of the position of cone1 and surf2.
cmds.pointOnPolyConstraint( 'cone1', 'surf2', 'cube2', w=.1 )

Sets the weight for cone1's effect on cube2 to 10.
cmds.pointOnPolyConstraint( 'cone1', 'cube2', e=True, w=10.0 )

Removes surf2 from cube2's pointOnPolyConstraint
cmds.pointOnPolyConstraint( 'surf2', 'cube2', e=True, rm=True )

Adds surf3 to cube2's pointOnPolyConstraint with the default weight
cmds.pointOnPolyConstraint( 'surf3', 'cube2' )

Constrain the y &amp; z translation of sph2 to sph1
cmds.pointOnPolyConstraint( 'sph1', 'sph2', skip="x" )

---
Return:
---


    list[string]: Name of the created constraint node

Flags:
---


---
layer(l): string
    properties: create, edit
    Specify the name of the animation layer where the constraint should be added.

---
maintainOffset(mo): boolean
    properties: create
    The offset necessary to preserve the constrained
object's initial position will be calculated and used as the
offset.

---
name(n): string
    properties: create, query, edit
    Sets the name of the constraint node to the specified
name.  Default name is constrainedObjectName_constraintType

---
offset(o): [float, float, float]
    properties: create, query, edit
    Sets or queries the value of the offset. Default is 0,0,0.

---
remove(rm): boolean
    properties: edit
    removes the listed target(s) from the constraint.

---
skip(sk): string
    properties: create, edit, multiuse
    Specify the axis to be skipped. Valid values are "x", "y", "z" and "none". During creation, "none" is the default. This flag is multi-use.

---
targetList(tl): boolean
    properties: query
    Return the list of target objects.

---
weight(w): float
    properties: create, query, edit
    Sets the weight value for the specified target(s).
If not given at creation time, the default value of 1.0 is used.

---
weightAliasList(wal): boolean
    properties: query
    Returns the names of the attributes that control the weight
of the target objects. Aliases are returned in the same order
as the targets are returned by the targetList flag

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pointOnPolyConstraint.html 
    """


def pointOnSurface(flagcaching: boolean, flagconstructionHistory: boolean, flagnodeState: int, flagnormal: boolean, flagnormalizedNormal: boolean, flagnormalizedTangentU: boolean, flagnormalizedTangentV: boolean, flagparameterU: float, flagparameterV: float, flagposition: boolean, flagtangentU: boolean, flagtangentV: boolean, flagturnOnPercentage: boolean) -> float[3] | string:
    """Synopsis:
---
---
 pointOnSurface(
[objects]
    , [caching=boolean], [constructionHistory=boolean], [nodeState=int], [normal=boolean], [normalizedNormal=boolean], [normalizedTangentU=boolean], [normalizedTangentV=boolean], [parameterU=float], [parameterV=float], [position=boolean], [tangentU=boolean], [tangentV=boolean], [turnOnPercentage=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pointOnSurface is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.pointOnSurface( 'surface1', u=0.5, v=1.0, position=True )
Returns the (x,y,z) position of the surface at parameter (u=0.5,v=1.0).

infoNode = cmds.pointOnSurface('surface1', ch= True, u=0.55, v=0.33)
cmds.getAttr(infoNode + ".position" )  returns the position
The pointOnSurface command returns  a string which is the name of
a new pointOnSurfaceInfo dependency node.  With this node connected
to the surface, the output values of the pointOnSurfaceInfo node
are always current even if, for example, the surface parameters are
being animated.

---
Return:
---


    float[3]: Vector query result
    string: String query result

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create
    Turn the construction history on or off.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
normal(no): boolean
    properties: create, query, edit
    Returns the (x,y,z) normal of the specified point on the surface

---
normalizedNormal(nn): boolean
    properties: create, query, edit
    Returns the (x,y,z) normalized normal of the specified point
on the surface

---
normalizedTangentU(ntu): boolean
    properties: create, query, edit
    Returns the (x,y,z) normalized U tangent of the specified point
on the surface

---
normalizedTangentV(ntv): boolean
    properties: create, query, edit
    Returns the (x,y,z) normalized V tangent of the specified point
on the surface

---
parameterU(u): float
    properties: query, edit
    The U parameter value on surface
Default: 0.0

---
parameterV(v): float
    properties: query, edit
    The V parameter value on surface
Default: 0.0

---
position(p): boolean
    properties: create, query, edit
    Returns the (x,y,z) positon of the specified point on the surface

---
tangentU(tu): boolean
    properties: create, query, edit
    Returns the (x,y,z) U tangent of the specified point on the surface

---
tangentV(tv): boolean
    properties: create, query, edit
    Returns the (x,y,z) V tangent of the specified point on the surface

---
turnOnPercentage(top): boolean
    properties: query, edit
    Whether the parameter is normalized (0,1) or not
Default: false

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pointOnSurface.html 
    """


def pointPosition(flaglocal: boolean, flagworld: boolean) -> float[]:
    """Synopsis:
---
---
 pointPosition(
[object]
    , [local=boolean], [world=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pointPosition is undoable, NOT queryable, and NOT editable.
It works on the selected object or you can specify the object in
the command. By default, if no flag is specified then the world
position is returned.




Example:
---
import maya.cmds as cmds

cmds.pointPosition( 'curve1.cv[3]' )
Returns the (x,y,z) world position of curve1's 3rd CV.

cmds.pointPosition( 'particle1.pt[1]', l=True )
Returns the (x,y,z) local position of the particle point.

---
Return:
---


    float[]: Command result

Flags:
---


---
local(l): boolean
    properties: create
    Return the point in local space coordinates.

---
world(w): boolean
    properties: create
    Return the point in world space coordinates.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pointPosition.html 
    """


def poleVectorConstraint(flaglayer: string, flagname: string, flagremove: boolean, flagtargetList: boolean, flagweight: float, flagweightAliasList: boolean) -> list[string]:
    """Synopsis:
---
---
 poleVectorConstraint(
[target ...] [object]
    , [layer=string], [name=string], [remove=boolean], [targetList=boolean], [weight=float], [weightAliasList=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

poleVectorConstraint is undoable, queryable, and editable.
An poleVectorConstraint takes as input one or more "target" DAG
transform nodes at which to aim pole vector for an IK handle using
the rotate plane solver.  The pole vector is adjust such that
the in weighted average of the world space position target
objects lies is the "rotate plane" of the handle.




Example:
---
import maya.cmds as cmds

aims the pole vector of handle1 at cone1.
cmds.poleVectorConstraint( 'cone1', 'handle1' )

uses the average of the position of cone1 and surf2.
cmds.poleVectorConstraint( 'cone1', 'surf2', 'handle2', w=.1 )

sets the weight for cone1's effect on handle2's poleVector to 10.
cmds.poleVectorConstraint( 'cone1', 'handle2', e=True, w=10. )

removes surf2 from handle2's poleVectorConstraint.
cmds.poleVectorConstraint( 'surf2', 'handle2', e=True, rm=True )

adds surf3 to handle2's poleVectorConstraint with the default weight.
cmds.poleVectorConstraint( 'surf3', 'handle2' )

---
Return:
---


    list[string]: name of the created constraint node

Flags:
---


---
layer(l): string
    properties: create, edit
    Specify the name of the animation layer where the constraint should be added.

---
name(n): string
    properties: create, query, edit
    Sets the name of the constraint node to the specified
name.  Default name is constrainedObjectName_constraintType

---
remove(rm): boolean
    properties: edit
    removes the listed target(s) from the constraint.

---
targetList(tl): boolean
    properties: query
    Return the list of target objects.

---
weight(w): float
    properties: create, query, edit
    Sets the weight value for the specified target(s).
If not given at creation time, the default value of 1.0 is used.

---
weightAliasList(wal): boolean
    properties: query
    Returns the names of the attributes that control the weight
of the target objects. Aliases are returned in the same order
as the targets are returned by the targetList flag

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/poleVectorConstraint.html 
    """


def polyAppend(flagappend: tuple[int | tuple[float, ...], ...], flagconstructionHistory: boolean, flagedge: int, flaghole: boolean, flagname: string, flagpoint: tuple[float, float, float], flagsubdivision: int, flagtexture: int) -> string:
    """Synopsis:
---
---
 polyAppend([append=[[, float, float, float, ]]], [constructionHistory=boolean], [edge=int], [hole=boolean], [name=string], [point=[float, float, float]], [subdivision=int], [texture=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyAppend is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polyCreateFacet( p=[(0, 0, 0), (10, 0, 0), (10, 10, 0), (0, 10, 0)] )

---
add a new triangular facet described by the edge ---
0, and a free point
cmds.polyAppend( a=[0, (5, -5, 0)] )

---
add a new quadrangular facet with 2 triangular holes.
cmds.polyAppend( a=[1, (20, 0, 0), (20, 10, 0), (), (12, 6, 0), (14, 5, 0), (12, 4, 0), (), (16, 5, 0), (18, 6, 0), (18, 4, 0)] )

---
Return:
---


    string: The node name.

Flags:
---


---
append(a): [[, float, float, float, ]]
    properties: create, multiuse
    Appends to the given polygon object.  The append flag should be used
multiple times to specify the edges, points, and holes that make up the new
face that is being added.

You may specify an edge by passing a single argument which will be the edges
index.  A point is specified with three arguments which are the coordinates
of the point in the objects local space.  Pass no arguments indicates that
the values which follow shall specify a hole.  In Python, pass an empty
tuple to specify no arguments.

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
edge(ed): int
    properties: create, multiuse
    Adds the given edge of the selected object to the new face.
This edge must be a border, which will be then shared by the
new face and the neighboring one. The new face is oriented according
to the orientation of the given edge(s).

Note that this flag should be avoided in Python.  You may use the "append"
flag instead and pass one argument.

---
hole(hl): boolean
    properties: create, multiuse
    Add a hole. The following points and edges will define a hole.

Note that this flag should be avoided in Python.  You may use the "append"
flag instead and pass an empty tuple ().

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
point(p): [float, float, float]
    properties: create, multiuse
    Adds a new point to the new face.
Coordinates of free points are given in the local object reference.

Note that this flag should be avoided in Python.  You may use the "append"
flag instead and pass three arguments.

---
subdivision(s): int
    properties: create, query, edit
    This flag specifies the level of subdivisions.
Automatically subdivides new edges into the given number of edges.
Existing edges cannot be subdivided.
C : Default is 1 (no subdivision).
Q: When queried, this flag returns an int.

---
texture(tx): int
    properties: create, query, edit
    Specifies how new faces are mapped.
 0 - None; 1 - Normalize; 2 - Unitize
C: Default is 0 (no mapping).
Q: When queried, this flag returns an int

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyAppend.html 
    """


def polyAppendFacetCtx(flagappend: boolean, flagexists: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flagisRotateAvailable: boolean, flagmaximumNumberOfPoints: int, flagplanarConstraint: boolean, flagrotate: float, flagsubdivision: int, flagtexture: int) -> None:
    """Synopsis:
---
---
 polyAppendFacetCtx([append=boolean], [exists=boolean], [image1=string], [image2=string], [image3=string], [isRotateAvailable=boolean], [maximumNumberOfPoints=int], [planarConstraint=boolean], [rotate=float], [subdivision=int], [texture=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyAppendFacetCtx is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a poly plane
cmds.polyPlane(w=10, h=10, sx=10, sy=10, n='pPlane1')

Create a new poly append facet context, set it to add four vertices per new edge, and then switch to it
cmds.polyAppendFacetCtx('polyAppendFacetCtx1', s=4)
cmds.setToolTo('polyAppendFacetCtx1')

---


Flags:
---


---
append(ap): boolean
    properties: create, query, edit
    Allows to switch to polyCreateFacetCtx tool

---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
isRotateAvailable(isr): boolean
    properties: query
    Tells if the control associated to rotate flag is available.
If several edges are already selected and they are not aligned
(thus there is no "rotation axis") the rotation is no longer available.

---
maximumNumberOfPoints(mp): int
    properties: create, query, edit
    Allows the ability to set a upper bound on the number of
points in interactively place before polygon is
created. A value less than 2 will mean that there is no
upper bound.

---
planarConstraint(pc): boolean
    properties: create, query, edit
    Allows/avoid new facet to be non-planar.
If on, all new points will be projected onto
current facet plane. Selected edges will be checked as well.

---
rotate(r): float
    properties: create, query, edit
    Rotate current facet around the first edge selected.

---
subdivision(s): int
    properties: create, query, edit
    Number of sub-edges created for each new edge. Default is 1.

---
texture(tx): int
    properties: create, query, edit
    Number of textures. Default is 1.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyAppendFacetCtx.html 
    """


def polyAppendVertex(flagappend: tuple[int | tuple[float, ...], ...], flagconstructionHistory: boolean, flaghole: boolean, flagname: string, flagpoint: tuple[float, float, float], flagtexture: int, flagvertex: int) -> string:
    """Synopsis:
---
---
 polyAppendVertex([append=[[, float, float, float, ]]], [constructionHistory=boolean], [hole=boolean], [name=string], [point=[float, float, float]], [texture=int], [vertex=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyAppendVertex is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polyPlane( sx=3, sy=3 )

add a new face
cmds.polyAppendVertex( a=[6, 10, (.167, .3, -.167), (.167, .3, .167)] )

add a new holed face
cmds.polyAppendVertex( a=[9, 5, (-.167, .3, .167), (-.167, .3, -.167), (), (-.167, .2, .1), (-.167, .1, 0), (-.167, .2, -.1)] )

connect the two new faces
cmds.polyAppendVertex( a=[18, 17, 16, 19] )

add a new unconnected quad
cmds.polyAppendVertex( a=[(-.5, .5, -.5), (.5, .5, -.5), (.5, .5, .5), (-.5, .5, .5)] )

---
Return:
---


    string: The node name.

Flags:
---


---
append(a): [[, float, float, float, ]]
    properties: create, multiuse
    Append a vertex or a point to the selected object, or mark the start of a
hole.

This flag may also be used in place of the "hole", "vertex" and "point" flags.
If no argument is passed to the "append" flag, then it marks the beginning of a
hole (use an empty tuple in Python '()').  If one argument is passed, then the
argument is considered to be an index into the vertices of the selected
object, as with the "vertex" flag.  If three arguments are passed, then it is
interpreted as the coordinates of a new point which will be inserted, as with
the "point" flag.

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
hole(h): boolean
    properties: create, multiuse
    Add a hole. The following points and edges will define a hole.

Note that this flag should be avoided in Python.  You may use the "append"
flag instead and pass an empty tuple '()' to specify the start of a hole.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
point(p): [float, float, float]
    properties: create, multiuse
    Adds a new point to the new face.
Coordinates of free points are given in the local object reference.

Note that this flag should be avoided in Python.  You may use the "append"
flag instead and pass three arguments.

---
texture(tx): int
    properties: create, query, edit
    Specifies how new faces are mapped.
0 - None; 1 - Normalize; 2 - Unitize
C: Default is 0 (no mapping).
Q: When queried, this flag returns an int

---
vertex(v): int
    properties: create, multiuse
    Adds the given vertex of the selected object to the new face.

Note that this flag should be avoided in Python.  You may use the "append"
flag instead and pass one argument.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyAppendVertex.html 
    """


def polyAutoProjection(flagcaching: boolean, flagconstructionHistory: boolean, flagcreateNewMap: boolean, flaginsertBeforeDeformers: boolean, flaglayout: int, flaglayoutMethod: int, flagname: string, flagnodeState: int, flagoptimize: int, flagpercentageSpace: float, flagpivot: tuple[linear, linear, linear], flagpivotX: linear, flagpivotY: linear, flagpivotZ: linear, flagplanes: int, flagprojectBothDirections: boolean, flagrotate: tuple[angle, angle, angle], flagrotateX: angle, flagrotateY: angle, flagrotateZ: angle, flagscale: tuple[float, float, float], flagscaleMode: int, flagscaleX: float, flagscaleY: float, flagscaleZ: float, flagskipIntersect: boolean, flagtranslate: tuple[linear, linear, linear], flagtranslateX: linear, flagtranslateY: linear, flagtranslateZ: linear, flaguvSetName: string, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyAutoProjection([caching=boolean], [constructionHistory=boolean], [createNewMap=boolean], [insertBeforeDeformers=boolean], [layout=int], [layoutMethod=int], [name=string], [nodeState=int], [optimize=int], [percentageSpace=float], [pivot=[linear, linear, linear]], [pivotX=linear], [pivotY=linear], [pivotZ=linear], [planes=int], [projectBothDirections=boolean], [rotate=[angle, angle, angle]], [rotateX=angle], [rotateY=angle], [rotateZ=angle], [scale=[float, float, float]], [scaleMode=int], [scaleX=float], [scaleY=float], [scaleZ=float], [skipIntersect=boolean], [translate=[linear, linear, linear]], [translateX=linear], [translateY=linear], [translateZ=linear], [uvSetName=string], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyAutoProjection is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a plane with default UVs.
cmds.polySphere( n='sph' )

Automatic projections with 6 planes.
cmds.polyAutoProjection( 'sphShape.f[*]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createNewMap(cm): boolean
    properties: create
    Set to true if a new map should be created

---
insertBeforeDeformers(ibd): boolean
    properties: create
    Set to true if the new node created should inserted before any deformer nodes.

---
layout(l): int
    properties: create, query, edit
    What layout algorithm should be used:
0 UV pieces are set to no layout.
1 UV pieces are aligned along the U axis.
2 UV pieces are moved in a square shape.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
optimize(o): int
    properties: create, query, edit
    Use two different flavors for the cut generation.
0 Every face is assigned to the best plane. This optimizes the
map distortion.
1 Small UV pieces are incorporated into larger ones, when the
extra distortion introduced is reasonable. This tends to produce fewer
UV pieces.

---
percentageSpace(ps): float
    properties: create, query, edit
    When layout is set to square, this value is a percentage of
the texture area which is added around each UV piece. It can be
used to ensure each UV piece uses different pixels in the texture.
Maximum value is 5 percent.

---
planes(p): int
    properties: create, query, edit
    Number of intermediate projections used. Valid numbers
are 4, 5, 6, 8, and 12.
C: Default is 6.

---
projectBothDirections(pb): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : projections are mirrored on directly opposite faces.
If "off" : projections are not mirrored on opposite faces.
C: Default is "off".
Q: When queried, this flag returns an integer.

---
scaleMode(sc): int
    properties: create, query, edit
    How to scale the pieces, after projections:
0 No scale is applied.
1 Uniform scale to fit in unit square.
2 Non proportional scale to fit in unit square.

---
skipIntersect(si): boolean
    properties: create, query, edit
    When on, self intersection of UV pieces are not
tested. This makes the projection faster and produces fewer pieces,
but may lead to overlaps in UV space.

---
uvSetName(uvs): string
    properties: create
    Name of the UV set to be created

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

---
layoutMethod(lm): int
    properties: create, query, edit
    Set which layout method to use:
0 Block Stacking.
1 Shape Stacking.

---
pivot(pvt): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the pivot for scaling and rotation.
C: Default is 0.0 0.0 0.0.
Q: When queried, this flag returns a float[3].

---
pivotX(pvx): linear
    properties: create, query, edit
    This flag specifies the X pivot for scaling and rotation.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
pivotY(pvy): linear
    properties: create, query, edit
    This flag specifies the Y pivot for scaling and rotation.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
pivotZ(pvz): linear
    properties: create, query, edit
    This flag specifies the Z pivot for scaling and rotation.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
rotate(ro): [angle, angle, angle]
    properties: create, query, edit
    This flag specifies the rotation angles around X, Y, Z.
C: Default is 0.0 0.0 0.0.
Q: When queried, this flag returns a float[3].

---
rotateX(rx): angle
    properties: create, query, edit
    This flag specifies the rotation angle around X.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
rotateY(ry): angle
    properties: create, query, edit
    This flag specifies the rotation angle around Y.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
rotateZ(rz): angle
    properties: create, query, edit
    This flag specifies the rotation angle around Z.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
scale(s): [float, float, float]
    properties: create, query, edit
    This flag specifies the scaling vector.
C: Default is 1.0 1.0 1.0.
Q: When queried, this flag returns a float[3].

---
scaleX(sx): float
    properties: create, query, edit
    This flag specifies X for scaling vector.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
scaleY(sy): float
    properties: create, query, edit
    This flag specifies Y for scaling vector.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
scaleZ(sz): float
    properties: create, query, edit
    This flag specifies Z for scaling vector.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
translate(t): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the translation vector.
C: Default is 0.0 0.0 0.0.
Q: When queried, this flag returns a float[3].

---
translateX(tx): linear
    properties: create, query, edit
    This flag specifies the X translation vector.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
translateY(ty): linear
    properties: create, query, edit
    This flag specifies the Y translation vector.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
translateZ(tz): linear
    properties: create, query, edit
    This flag specifies the Z translation vector.
C: Default is 0.0.
Q: When queried, this flag returns a float.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyAutoProjection.html 
    """


def polyAverageNormal(flagallowZeroNormal: boolean, flagdistance: float, flagpostnormalize: boolean, flagprenormalize: boolean, flagreplaceNormalXYZ: tuple[float, float, float]) -> string:
    """Synopsis:
---
---
 polyAverageNormal([allowZeroNormal=boolean], [distance=float], [postnormalize=boolean], [prenormalize=boolean], [replaceNormalXYZ=[float, float, float]])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyAverageNormal is undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

To average normals when they are within 0.2 distance.
cmds.polyAverageNormal( distance=0.2 )

To average normals when they are within 0.2 distance.
Normalize the normals before computing the average.
cmds.polyAverageNormal( distance=0.2, prenormalize=True )

To averge normals when they are within 0.2 distance. Do not
normalize the normals before computing the average (so to get weighted
average). But do normalize the resulting normal.
cmds.polyAverageNormal( distance=0.2, postnormalize=True )

To average normals when they are within 0.2 distance. Do not
allow zero normal and replace zero normal with (1 0 0).
cmds.polyAverageNormal( distance=0.2, allowZeroNormal=False, replaceNormalXYZ=(1,0,0) )

---
Return:
---


    string: of the node name.

Flags:
---


---
allowZeroNormal(azn): boolean
    properties: create
    Specifies whether to allow zero normals to be created.
By default it is false. If it is false, replaceNormal is needed.

---
distance(d): float
    properties: create
    Specifies the distance threshold. All vertices within
the threshold are considered when computing an average
normal. By default it is 0.0.

---
postnormalize(pon): boolean
    properties: create
    Specifies whether to normalize the resulting normals.
By default it is true.

---
prenormalize(prn): boolean
    properties: create
    Specifies whether to normalize the normals before averaging.
By default it is true.

---
replaceNormalXYZ(xyz): [float, float, float]
    properties: create
    If the allowZeroNormal is false, this value is used to
replace the zero normals. By default it is (1, 0, 0).

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyAverageNormal.html 
    """


def polyAverageVertex(flagcaching: boolean, flagconstructionHistory: boolean, flagiterations: int, flagname: string, flagnodeState: int, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyAverageVertex(
selectionList
    , [caching=boolean], [constructionHistory=boolean], [iterations=int], [name=string], [nodeState=int], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyAverageVertex is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a cube with a 5x5x5 subdivision.
cmds.polyCube( sx=5, sy=5, sz=5, n='plg' )

Average all the vertices
cmds.polyAverageVertex( 'plg.vtx[*]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
iterations(i): int
    properties: create, query, edit
    Number of rounding steps.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyAverageVertex.html 
    """


def polyAxis(flagarrowType: int, flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagframeType: int, flaglengthX: linear, flaglengthY: linear, flaglengthZ: linear, flagmaterialTemplate: string, flagname: string, flagnodeState: int, flagobject: boolean, flagradius: linear, flagrightHanded: boolean, flagscale: linear, flagsubdivisionsAxis: int) -> list[string]:
    """Synopsis:
---
---
 polyAxis([arrowType=int], [axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [frameType=int], [lengthX=linear], [lengthY=linear], [lengthZ=linear], [materialTemplate=string], [name=string], [nodeState=int], [object=boolean], [radius=linear], [rightHanded=boolean], [scale=linear], [subdivisionsAxis=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyAxis is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a coordinate system shape with 16 subdivisions for the cylinders of the axis,
rounded end shapes, an overall scale of 2 and an x-asxis of length 1.5
cmds.polyAxis(sa=16, arw=2, sca=2.0, lx=1.5)


Create a wedge shaped coordinate system named myFrame with an overall scale of 0.5
cmds.polyAxis(ftp=1, sca=0.5, n='myFrame')

Query the scale of "myFrame"
s = cmds.polyAxis('myFrame', q=True, sca=True)

Create a coordinate system shape with material assigned
cmd.polyAxis(n='myColoredFrame', mt='polyAxis_materialTemplate')

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
arrowType(arw): int
    properties: create, query, edit
    This flag specifies the shape at the ends of the axis
The valid values are 0, 1 and 2.
0 means a flat end shape.
1 means a rounded end shape.
2 means a cone end shape.

C: Default is the cone end shape

---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the frame. This is the axis that will point up.
Q: When queried, this flag returns a float[3].

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
frameType(ftp): int
    properties: create, query, edit
    This flag allows a specific frame type to be created
The valid values are 0 and 1.
0 implies an axis shape will be created.
1 implies an wedge shape will be created.

C: Default is the axis shape

---
lengthX(lx): linear
    properties: create, query, edit
    This flag specifies the length of the x-axis.

---
lengthY(ly): linear
    properties: create, query, edit
    This flag specifies the length of the y-axis.

---
lengthZ(lz): linear
    properties: create, query, edit
    This flag specifies the length of the z-axis.

---
materialTemplate(mt): string
    properties: create
    Assign the specified material template to geoemtry. If it does
not exist one will be created with materials assigned to each
axis

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
radius(r): linear
    properties: create, query, edit
    This flag specifies the radius of the axis.

---
rightHanded(rhd): boolean
    properties: create, query, edit
    When this is set to true the result will be a shape representing a right handed coordinate system

---
scale(sca): linear
    properties: create, query, edit
    This flag specifies the overall scale of the frame shape.

---
subdivisionsAxis(sa): int
    properties: create, query, edit
    This specifies the number of subdivisions for the axis.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyAxis.html 
    """


def polyBevel(flagangleTolerance: float, flagautoFit: boolean, flagcaching: boolean, flagconstructionHistory: boolean, flagmergeVertexTolerance: linear, flagmergeVertices: boolean, flagmiteringAngle: float, flagname: string, flagnodeState: int, flagoffset: linear, flagoffsetAsFraction: boolean, flagroundness: float, flagsegments: int, flagsmoothingAngle: float, flagsubdivideNgons: boolean, flaguseLegacyBevelAlgorithm: boolean, flaguvAssignment: int, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyBevel([angleTolerance=float], [autoFit=boolean], [caching=boolean], [constructionHistory=boolean], [mergeVertexTolerance=linear], [mergeVertices=boolean], [miteringAngle=float], [name=string], [nodeState=int], [offset=linear], [offsetAsFraction=boolean], [roundness=float], [segments=int], [smoothingAngle=float], [subdivideNgons=boolean], [useLegacyBevelAlgorithm=boolean], [uvAssignment=int], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyBevel is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Replace an edge by 1 face, the width of the new face is given by the offset value.
cmds.polyCube( n='plg' )
cmds.polyBevel( 'plg.e[7]', offset=0.2 )
cmds.delete( 'plg' )

Replace an edge by 4 faces, the new faces are rounding a smooth angle.
cmds.polyCube( n='plg' )
cmds.polyBevel( 'plg.e[7]', segments=4, offset=0.4 )
cmds.delete( 'plg' )

Replace an edge by 4 faces, the new faces are rounding an angle specified by the default value of roundness (i.e 0.5).
cmds.polyCube( n='plg' )
cmds.polyBevel( 'plg.e[7]', segments=4, autoFit=Flase )
cmds.delete( 'plg' )

---
Return:
---


    string: The node name.

Flags:
---


---
angleTolerance(at): float
    properties: create, query, edit
    Angular tolerance for creation of extra triangles
Note this attribute is for compatability only and should not be modified in Maya 7.0 files
Default: 20.0

---
autoFit(af): boolean
    properties: create, query, edit
    If autoFit is on, it computes a smooth roundness :  new facets round off a smooth angle.
Default: true

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
mergeVertexTolerance(mvt): linear
    properties: create, query, edit
    Tolerance within which to merge vertices
Default: 0.0

---
mergeVertices(mv): boolean
    properties: create, query, edit
    Merge vertices within a tolerance
Default: false

---
miteringAngle(ma): float
    properties: create, query, edit
    Miter faces that have angles less than this value
Default: 0.0

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
offset(o): linear
    properties: create, query, edit
    The offset for bevel.
Default: 0.2

---
offsetAsFraction(oaf): boolean
    properties: create, query, edit
    If on, the offset value is treated as a fraction between zero and one.
Default: false

---
roundness(r): float
    properties: create, query, edit
    The roundness of bevel, it is taken into account when autoFit is off.
Default: 0.5

---
segments(sg): int
    properties: create, query, edit
    The number of segments used for beveling.
Default: 1

---
smoothingAngle(sa): float
    properties: create, query, edit
    Create new edges as hard edges if the angle between adjacent faces exceeds this value
Default: 0.0

---
subdivideNgons(sn): boolean
    properties: create, query, edit
    Subdivide new faces with more than 4 edges
Default: false

---
useLegacyBevelAlgorithm(com): boolean
    properties: create, query, edit
    If on, bevel is done the way maya 2014 did
Default: false

---
uvAssignment(ua): int
    properties: create, query, edit
    Technique used to compute UVs on new faces
0 computes new UVs by projecting along surface normal of original mesh onto new mesh
1 computes new UVs by projecting along surface normal of new mesh onto original mesh
Default: 0

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyBevel.html 
    """


def polyBevel3(flagangleTolerance: float, flagautoFit: boolean, flagcaching: boolean, flagchamfer: boolean, flagconstructionHistory: boolean, flagdepth: float, flagfillNgons: boolean, flagmergeVertexTolerance: linear, flagmergeVertices: boolean, flagmiterAlong: int, flagmitering: int, flagmiteringAngle: float, flagname: string, flagnodeState: int, flagoffset: linear, flagoffsetAsFraction: boolean, flagroundness: float, flagsegments: int, flagsmoothingAngle: float, flaguvAssignment: int, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyBevel3([angleTolerance=float], [autoFit=boolean], [caching=boolean], [chamfer=boolean], [constructionHistory=boolean], [depth=float], [fillNgons=boolean], [mergeVertexTolerance=linear], [mergeVertices=boolean], [miterAlong=int], [mitering=int], [miteringAngle=float], [name=string], [nodeState=int], [offset=linear], [offsetAsFraction=boolean], [roundness=float], [segments=int], [smoothingAngle=float], [uvAssignment=int], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyBevel3 is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Replace an edge by 1 face, the width of the new face is given by the offset value.
cmds.polyCube( n='plg' )
cmds.polyBevel3( 'plg.e[7]', offset=0.2 )
cmds.delete( 'plg' )

Replace an edge by 4 faces, the new faces are rounding a smooth angle.
cmds.polyCube( n='plg' )
cmds.polyBevel3( 'plg.e[7]', segments=4, offset=0.4 )
cmds.delete( 'plg' )

Replace an edge by 4 faces, the new faces are rounding an angle specified by the default value of roundness (i.e 0.5).
cmds.polyCube( n='plg' )
cmds.polyBevel3( 'plg.e[7]', segments=4, autoFit=Flase )
cmds.delete( 'plg' )

---
Return:
---


    string: The node name.

Flags:
---


---
angleTolerance(at): float
    properties: create, query, edit
    Angular tolerance for creation of extra triangles
Note this attribute is for compatability only and should not be modified in Maya 7.0 files
Default: 20.0

---
autoFit(af): boolean
    properties: create, query, edit
    If autoFit is on, it computes a smooth roundness :  new facets round off a smooth angle.
Default: true

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
chamfer(c): boolean
    properties: create, query, edit
    If chamfer is on, the surface is smoothed out at bevels. When it is off, the shape of the surface remains the same.
Default: true

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
depth(d): float
    properties: create, query, edit
    The depth of bevel. One means a smooth surface, -1 means maximum depth.
Default: 1.0

---
fillNgons(fn): boolean
    properties: create, query, edit
    Subdivide new faces with more than 4 edges
Default: false

---
mergeVertexTolerance(mvt): linear
    properties: create, query, edit
    Tolerance within which to merge vertices
Default: 0.0

---
mergeVertices(mv): boolean
    properties: create, query, edit
    Merge vertices within a tolerance
Default: false

---
miterAlong(mia): int
    properties: create, query, edit
    Controls in which direction new vertices should we offseted.
Default: 0

---
mitering(m): int
    properties: create, query, edit
    Controls how the topology should look like at corners.
Default: 0

---
miteringAngle(ma): float
    properties: create, query, edit
    Miter faces that have angles less than this value
Default: 0.0

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
offset(o): linear
    properties: create, query, edit
    The offset for bevel.
Default: 0.2

---
offsetAsFraction(oaf): boolean
    properties: create, query, edit
    If on, the offset value is treated as a fraction between zero and one.
Default: false

---
roundness(r): float
    properties: create, query, edit
    The roundness of bevel, it is taken into account when autoFit is off.
Default: 0.5

---
segments(sg): int
    properties: create, query, edit
    The number of segments used for beveling.
Default: 1

---
smoothingAngle(sa): float
    properties: create, query, edit
    Create new edges as hard edges if the angle between adjacent faces exceeds this value
Default: 0.0

---
uvAssignment(ua): int
    properties: create, query, edit
    Technique used to compute UVs on new faces
0 computes new UVs by projecting along surface normal of original mesh onto new mesh
1 computes new UVs by projecting along surface normal of new mesh onto original mesh
Default: 0

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyBevel3.html 
    """


def polyBlendColor(flagbaseColorName: string, flagblendFunc: int, flagblendWeightA: float, flagblendWeightB: float, flagblendWeightC: float, flagblendWeightD: float, flagcaching: boolean, flagconstructionHistory: boolean, flagdstColorName: string, flagname: string, flagnodeState: int, flagsrcColorName: string) -> string:
    """Synopsis:
---
---
 polyBlendColor([baseColorName=string], [blendFunc=int], [blendWeightA=float], [blendWeightB=float], [blendWeightC=float], [blendWeightD=float], [caching=boolean], [constructionHistory=boolean], [dstColorName=string], [name=string], [nodeState=int], [srcColorName=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyBlendColor is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

This example creates two poly color sets for pPlane1.
Apply red and green to the vertices of pPlane1 using two separate color sets, then blend their colors to the second color set
After that, delete the first color set

Create a poly plane pPlane1
cmds.polyPlane(w=10, h=10, sx=10, sy=10, n='pPlane1')

Create colorSet1, set to use RGBA channels
cmds.polyColorSet(create=True, clamped=0, rpt='RGBA', colorSet='colorSet1')
Apply red color to the vertices of pPlane1
cmds.polyColorPerVertex(r=1, g=0, b=0, a=1, cdo=True)

Create colorSet2, set to use RGBA channels
cmds.polyColorSet(create=True, clamped=0, rpt='RGBA', colorSet='colorSet2')
Apply green color to the vertices of pPlane1
cmds.polyColorPerVertex(r=0, g=1, b=0, a=1, cdo=True)

Blend the two color sets to colorSet2, set to use ColorChannel blend style, set all the blend weights to 0.5
cmds.polyBlendColor(bcn='colorSet1', src='colorSet2', dst='colorSet2', bfn=6, bwa=0.5, bwb=0.5, bwc=0.5, bwd=0.5)
Delete colorSet1
cmds.polyColorSet(delete=True, colorSet='colorSet1')

---
Return:
---


    string: The node name.

Flags:
---


---
baseColorName(bcn): string
    properties: query, edit
    Name of the color set to blend from

---
blendFunc(bfn): int
    properties: query, edit
    Type of blending function to use

---
blendWeightA(bwa): float
    properties: query, edit
    Blend weight for linear and bilinear blending functions

---
blendWeightB(bwb): float
    properties: query, edit
    Blend weight for bilinear and channel blending functions

---
blendWeightC(bwc): float
    properties: query, edit
    Blend weight for channel functions

---
blendWeightD(bwd): float
    properties: query, edit
    Blend weight for channel functions

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
dstColorName(dst): string
    properties: query, edit
    Name of the color set to copy to

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
srcColorName(src): string
    properties: query, edit
    Name of the color set to copy from

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyBlendColor.html 
    """


def polyBlindData(flagassociationType: string, flagbinaryData: string, flagbooleanData: boolean, flagdelete: boolean, flagdoubleData: float, flagint64Data: int64, flagintData: int, flaglongDataName: string, flagrescan: boolean, flagreset: boolean, flagshape: boolean, flagshortDataName: string, flagstringData: string, flagtypeId: int) -> string:
    """Synopsis:
---
---
 polyBlindData([associationType=string], [binaryData=string], [booleanData=boolean], [delete=boolean], [doubleData=float], [int64Data=int64], [intData=int], [longDataName=string], [rescan=boolean], [reset=boolean], [shape=boolean], [shortDataName=string], [stringData=string], [typeId=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyBlindData is undoable, NOT queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.polyBlindData( 'pPlane1.vtx[2]', 'pPlane1.vtx[8]', id=9001, associationType='vertex', ldn='bdFloat', dbd=234 )

---
Return:
---


    string: Name of nodes created

Flags:
---


---
associationType(at): string
    properties: create, edit
    Specifies the dataTypes that are part of BlindData node being created.
Allowable associations are "object" for any object, and "vertex" "edge" and
"face" for mesh objects. Other associations for other geometry types may
be added.

---
binaryData(bnd): string
    properties: create, edit, multiuse
    Specifies the data type is a binary data value

---
booleanData(bd): boolean
    properties: create, edit, multiuse
    Specifies the data type is a boolean logic value

---
delete(delete): boolean
    properties: create, edit
    Specifies that this will remove the blind data if found

---
doubleData(dbd): float
    properties: create, edit, multiuse
    Specifies the data type is a floating point double value

---
int64Data(lid): int64
    properties: create, edit, multiuse
    Specifies the data type is an 64-bit integer value

---
intData(ind): int
    properties: create, edit, multiuse
    Specifies the data type is an integer value

---
longDataName(ldn): string
    properties: create, edit, multiuse
    Specifies the long name of the data that is being modified by this command.

---
rescan(res): boolean
    properties: create, edit
    Enables a rescan of blind data nodes for cached information

---
reset(rst): boolean
    properties: create, edit
    Specifies that this command will reset the given attribute to default value

---
shape(sh): boolean
    properties: create, edit
    For object association only, apply blind data to the shape(s) below
this node instead of the node itself

---
shortDataName(sdn): string
    properties: create, edit, multiuse
    Specifies the short name of the data that is being modified by this command.

---
stringData(sd): string
    properties: create, edit, multiuse
    Specifies the data type is a string value

---
typeId(id): int
    properties: create, edit
    Specifies the typeId of the BlindData type being created

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyBlindData.html 
    """


def polyBoolOp(flagcaching: boolean, flagfaceAreaThreshold: linear, flagmergeUVSets: int, flagnodeState: int, flagoperation: int, flagpreserveColor: boolean, flaguseThresholds: boolean, flagvertexDistanceThreshold: linear) -> list[string]:
    """Synopsis:
---
---
 polyBoolOp(
poly poly
    , [caching=boolean], [faceAreaThreshold=linear], [mergeUVSets=int], [nodeState=int], [operation=int], [preserveColor=boolean], [useThresholds=boolean], [vertexDistanceThreshold=linear])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyBoolOp is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Union
cmds.polyCube( n='Cube1', w=1, h=10, d=1 )
cmds.polyCube( n='cub1', w=3, h=3, d=3 )
cmds.polyBoolOp( 'cub1', 'Cube1', op=1, n='result1' )

Difference
cmds.polyCube( n='Cube2', w=1, h=10, d=1 )
cmds.polyCube( n='cub2', w=3, h=3, d=3 )
cmds.polyBoolOp( 'cub2', 'Cube2', op=2, n='result2' )
cmds.move( 5, 0, 0, 'result2' )

Intersection
cmds.polyCube( n='Cube3', w=1, h=10, d=1 )
cmds.polyCube( n='cub3', w=3, h=3, d=3 )
cmds.polyBoolOp( 'cub3', 'Cube3', op=3, n='result3' )
cmds.move( 10, 0, 0, 'result3' )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
faceAreaThreshold(fat): linear
    properties: create, query, edit
    Area threshold to determine whether faces should
be collapsed before boolean. Attribute is ignored unless
useThresholds is set to true
Default: 0.0001

---
operation(op): int
    properties: create, query, edit
    Boolean operation type. 1=union, 2=difference, 3=intersection.
Default type is union.
Default: kBoolOpUnion

---
preserveColor(pcr): boolean
    properties: create, query, edit
    If true, boolean op will compute color for the
new mesh. If false, the new mesh won't have any color
set.
Default: false

---
useThresholds(uth): boolean
    properties: create, query, edit
    If true, merge vertices with separations less then
vertexDistanceThreshold and collapse faces with areas
less then faceAreaThreshold. If false, do not merge
vertices or collapse faces
Default: false

---
vertexDistanceThreshold(vdt): linear
    properties: create, query, edit
    Tolerance to determine whether vertices (and edges) should
be merged before boolean operation is applied. Attribute is
ignored unless useThresholds is set to true
Default: 0.001

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
mergeUVSets(muv): int
    properties: create, query, edit
    Specify how UV sets will be merged on the output mesh.

0 = "No Merge": Each UV set on each mesh will become a new UV set in the output.
1 = "Merge By Name": UV sets with the same name will be merged.
2 = "Merge By UV Links": UV sets will be merged so that UV linking on the input meshes continues to work.

The default is merge by name.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyBoolOp.html 
    """


def polyBooleanCmd(flagaddMesh: name, flagchangeSmoothMesh: tuple[name, boolean], flagclassification: int, flaginteractiveUpdate: boolean, flagnewInputDisplay: int, flagnewInputOperation: int, flagoperation: int, flagremoveMesh: name, flagreorderMesh: tuple[name, int]) -> string:
    """Synopsis:
---
---
 polyBooleanCmd([addMesh=name], [changeSmoothMesh=[name, boolean]], [classification=int], [interactiveUpdate=boolean], [newInputDisplay=int], [newInputOperation=int], [operation=int], [removeMesh=name], [reorderMesh=[name, int]])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyBooleanCmd is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

import maya.cmds as cmds

Create a few objects
cmds.polyTorus()
cmds.polySphere()
cmds.polyCube()

Diff A-B boolean between the torus and sphere
cmds.polyBooleanCmd( ["pTorus1", "pSphere1"], operation=2 )

Now add the cube to the existing boolean as a Union
cmds.polyBooleanCmd( "polyBoolean1", edit=True, addMesh="pCube1", operation=1 )

---
Return:
---


    string: The node name.

Flags:
---


---
addMesh(am): name
    properties: edit
    Add a new mesh to the boolean stack.

---
changeSmoothMesh(csm): [name, boolean]
    properties: edit
    Set one of the inputs to use a smoothed version of the mesh.

---
classification(cls): int
    properties: query, edit
    Changes how intersections of open and closed manifolds are treated.
1 = Edge.  2 = Normal.  3 = Auto

---
interactiveUpdate(iu): boolean
    properties: query, edit
    Changes how interactive manipulation of input meshes trigger updates of the boolean node.
If true, will trigger compute while dragging a manipulator.
If false, will not trigger a compute until the manipulator is released.

---
newInputDisplay(nid): int
    properties: query, edit
    Default display mode to apply to new inputs.
0 = Wireframe.  1 = Shaded.  2 = Bounding Box.  3 = X-Ray.  4 = Hidden.

---
newInputOperation(nio): int
    properties: query, edit
    Default boolean operation to apply to new inputs if not specified.  Values are:
1=Union, 2=Difference A-B, 3=Intersection, 4=Difference B-A, 5=Split, 6=Split Edges, 7=Hole Punch, 8=Cut Out

---
operation(op): int
    properties: create, multiuse
    Specifies the boolean operation to run.  Values are:
1=Union, 2=Difference A-B, 3=Intersection, 4=Difference B-A, 5=Split, 6=Split Edges, 7=Hole Punch, 8=Cut Out

---
removeMesh(rm): name
    properties: edit
    Remove a  mesh from the boolean stack.

---
reorderMesh(rom): [name, int]
    properties: edit
    Change the position of a mesh in the boolean stack to a specific index.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyBooleanCmd.html 
    """


def polyBridgeEdge(flagbridgeOffset: int, flagcaching: boolean, flagconstructionHistory: boolean, flagcurveType: int, flagdivisions: int, flaginputCurve: name, flagname: string, flagnodeState: int, flagsmoothingAngle: angle, flagstartVert1: int, flagstartVert2: int, flagtaper: float, flagtaperCurve_FloatValue: float, flagtaperCurve_Interp: int, flagtaperCurve_Position: float, flagtwist: angle, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyBridgeEdge([bridgeOffset=int], [caching=boolean], [constructionHistory=boolean], [curveType=int], [divisions=int], [inputCurve=name], [name=string], [nodeState=int], [smoothingAngle=angle], [startVert1=int], [startVert2=int], [taper=float], [taperCurve_FloatValue=float], [taperCurve_Interp=int], [taperCurve_Position=float], [twist=angle], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyBridgeEdge is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.file( f=True, new=True )
cmds.polyCube( sx=3, sy=3, sz=3 )
cmds.delete( 'pCube1.f[9:17]' )
cmds.move( -2, 0, 0, r=True )
cmds.rotate( 0, 0, -90, r=True, os=True )
cmds.polyCube( sx=3, sy=3, sz=3 )
cmds.delete( 'pCube2.f[9:17]' )
cmds.move( 2, 0, 0, r=True )
cmds.rotate( 0, 0, 90, r=True, os=True )
cmds.polyUnite( 'pCube1', 'pCube2', ch=1 )

Now bridge the two sets of border edges
cmds.polyBridgeEdge( 'polySurface1.e[9:14]', 'polySurface1.e[42:47]', 'polySurface1.e[105:110]', 'polySurface1.e[138:143]', sv1=12, sv2=67, divisions=10 )

---
Return:
---


    string: The node name.

Flags:
---


---
bridgeOffset(bo): int
    properties: create, query, edit
    Add offset to which vertices are connected.
Default: 0

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
curveType(ctp): int
    properties: create, query, edit
    Format: 0 - Linear, 1 - Blend, 2 - Curve
Default: TdnpolyBridgeEdge::Linear

---
divisions(dv): int
    properties: create, query, edit
    The number of subdivisions in the bridging faces
(resulting in (divisions+1) row of faces).
Default: 1

---
inputCurve(inc): name
    properties: create
    This flag specifies the name of the curve to be used as input for the operation.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
smoothingAngle(sma): angle
    properties: create, query, edit
    Angle below which new edges will be smoothed
Default: kPi/6.0

---
startVert1(sv1): int
    properties: create, query, edit
    The start vertex from the first set of edges
Default: -1

---
startVert2(sv2): int
    properties: create, query, edit
    The start vertex from the second set of edges
Default: -1

---
taper(tp): float
    properties: create, query, edit
    Taper or Scale along the extrusion path
Default: 1.0

---
taperCurve_FloatValue(cfv): float
    properties: create, query, edit
    Value for taperCurve;
Curve control for taper along extrusion
Using this curve, the taper along extrusion
can be changed from a simple linear scaling to
custom scaling along the extrusion path.

---
taperCurve_Interp(ci): int
    properties: create, query, edit
    Interpolation type for taperCurve;
Curve control for taper along extrusion
Using this curve, the taper along extrusion
can be changed from a simple linear scaling to
custom scaling along the extrusion path.

---
taperCurve_Position(cp): float
    properties: create, query, edit
    Position for taperCurve;
Curve control for taper along extrusion
Using this curve, the taper along extrusion
can be changed from a simple linear scaling to
custom scaling along the extrusion path.

---
twist(twt): angle
    properties: create, query, edit
    Twist or Rotation along the extrusion path
Default: 0.0

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyBridgeEdge.html 
    """


def polyCBoolOp(flagcaching: boolean, flagclassification: int, flagfaceAreaThreshold: linear, flagmergeUVSets: int, flagnodeState: int, flagoperation: int, flagpreserveColor: boolean, flagtagIntersection: boolean, flaguseCarveBooleans: boolean, flaguseThresholds: boolean, flagvertexDistanceThreshold: linear) -> list[string]:
    """Synopsis:
---
---
 polyCBoolOp(
poly poly
    , [caching=boolean], [classification=int], [faceAreaThreshold=linear], [mergeUVSets=int], [nodeState=int], [operation=int], [preserveColor=boolean], [tagIntersection=boolean], [useCarveBooleans=boolean], [useThresholds=boolean], [vertexDistanceThreshold=linear])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCBoolOp is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Union
cmds.polyCube( n='Cube1', w=1, h=10, d=1 )
cmds.polyCube( n='cub1', w=3, h=3, d=3 )
cmds.polyCBoolOp( 'cub1', 'Cube1', op=1, n='result1' )

Difference
cmds.polyCube( n='Cube2', w=1, h=10, d=1 )
cmds.polyCube( n='cub2', w=3, h=3, d=3 )
cmds.polyCBoolOp( 'cub2', 'Cube2', op=2, n='result2' )
cmds.move( 5, 0, 0, 'result2' )

Intersection
cmds.polyCube( n='Cube3', w=1, h=10, d=1 )
cmds.polyCube( n='cub3', w=3, h=3, d=3 )
cmds.polyCBoolOp( 'cub3', 'Cube3', op=3, n='result3' )
cmds.move( 10, 0, 0, 'result3' )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
classification(cls): int
    properties: create, query, edit
    Changes how intersections of open and closed manifolds are treated.
1 for "Edge", 2 for "Normal".

---
faceAreaThreshold(fat): linear
    properties: create, query, edit
    Area threshold to determine whether faces should
be collapsed before boolean. Attribute is ignored unless
useThresholds is set to true
Default: 0.0001

---
operation(op): int
    properties: create, query, edit
    Boolean operation type. 1=union, 2=difference, 3=intersection.
Default type is union.
Default: kBoolOpUnion

---
preserveColor(pcr): boolean
    properties: create, query, edit
    If true, boolean op will compute color for the
new mesh. If false, the new mesh won't have any color
set.
Default: false

---
useCarveBooleans(ucb): boolean
    properties: create, query, edit
    If true, use the Carve Boolean library

---
useThresholds(uth): boolean
    properties: create, query, edit
    If true, merge vertices with separations less then
vertexDistanceThreshold and collapse faces with areas
less then faceAreaThreshold. If false, do not merge
vertices or collapse faces
Default: false

---
vertexDistanceThreshold(vdt): linear
    properties: create, query, edit
    Tolerance to determine whether vertices (and edges) should
be merged before boolean operation is applied. Attribute is
ignored unless useThresholds is set to true
Default: 0.001

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
mergeUVSets(muv): int
    properties: create, query, edit
    Specify how UV sets will be merged on the output mesh.

0 = "No Merge": Each UV set on each mesh will become a new UV set in the output.
1 = "Merge By Name": UV sets with the same name will be merged.
2 = "Merge By UV Links": UV sets will be merged so that UV linking on the input meshes continues to work.

The default is merge by name.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
tagIntersection(ti): boolean
    properties: create, query, edit
    If set the operation creates custom component tags that contain
vertices on the intersection.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCBoolOp.html 
    """


def polyCacheMonitor(flagcacheValue: boolean, flagnodeName: string) -> None:
    """Synopsis:
---
---
 polyCacheMonitor([cacheValue=boolean], [nodeName=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCacheMonitor is NOT undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

increment cache counter on polyExtrudeFace1 node
cmds.polyCacheMonitor( nodeName='polyExtrudeFace1' )

update/edit manipulate nodes which are present downstream
with respect to polyExtrudeFace1

decrement cache counter on polyExtrudeFace1 node
so that the cache is set free
cmds.polyCacheMonitor( nodeName='polyExtrudeFace1', cacheValue=False )

---


Flags:
---


---
cacheValue(chv): boolean
    properties: create
    Flag to indicate whether the node's cache counter should be incremented or decremented.
True increments the counter, false decrements the counter.

---
nodeName(nm): string
    properties: create
    Name of the node whose cache counter needs to be changed.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCacheMonitor.html 
    """


def polyCanBridgeEdge() -> boolean:
    """Synopsis:
---
---
 polyCanBridgeEdge(
poly poly...
    )  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCanBridgeEdge is undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

cmds.polyCanBridgeEdge()

---
Return:
---


    boolean: Success or Failure.

Flags:
---


URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCanBridgeEdge.html 
    """


def polyCheck(flagedge: boolean, flagface: boolean, flagfaceOffset: boolean, flagopenFile: string) -> int:
    """Synopsis:
---
---
 polyCheck(
poly poly...
    , [edge=boolean], [face=boolean], [faceOffset=boolean], [openFile=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCheck is undoable, NOT queryable, and NOT editable.




Example:
---
import maya.cmds as cmds

cmds.polyPlane()
cmds.polyCheck()
cmds.polyCheck( f=True )

---
Return:
---


    int: The number of errors.

Flags:
---


---
edge(e): boolean
    properties: create
    Check edge descriptions.
If no flag is set, a complete check is performed.

---
face(f): boolean
    properties: create
    Check face descriptions.
If no flag is set, a complete check is performed.

---
faceOffset(fo): boolean
    properties: create
    Check face offset descriptions.
If no flag is set, a complete check is performed.

---
openFile(of): string
    properties: create
    Opens a file that contains a poly description,
as dumped out by the debug commands.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCheck.html 
    """


def polyChipOff(flagattraction: float, flagcaching: boolean, flagconstructionHistory: boolean, flagduplicate: boolean, flaggain: float, flaggravity: tuple[linear, linear, linear], flaggravityX: linear, flaggravityY: linear, flaggravityZ: linear, flagkeepFacesTogether: boolean, flagkeepFacetTogether: boolean, flaglocalCenter: int, flaglocalDirection: tuple[linear, linear, linear], flaglocalDirectionX: linear, flaglocalDirectionY: linear, flaglocalDirectionZ: linear, flaglocalRotate: tuple[angle, angle, angle], flaglocalRotateX: angle, flaglocalRotateY: angle, flaglocalRotateZ: angle, flaglocalScale: tuple[float, float, float], flaglocalScaleX: float, flaglocalScaleY: float, flaglocalScaleZ: float, flaglocalTranslate: tuple[linear, linear, linear], flaglocalTranslateX: linear, flaglocalTranslateY: linear, flaglocalTranslateZ: linear, flagmagnX: linear, flagmagnY: linear, flagmagnZ: linear, flagmagnet: tuple[linear, linear, linear], flagname: string, flagnodeState: int, flagoffset: float, flagpivot: tuple[linear, linear, linear], flagpivotX: linear, flagpivotY: linear, flagpivotZ: linear, flagrandom: float, flagscale: tuple[float, float, float], flagscaleX: float, flagscaleY: float, flagscaleZ: float, flagtranslate: tuple[linear, linear, linear], flagtranslateX: linear, flagtranslateY: linear, flagtranslateZ: linear, flagweight: float, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyChipOff([attraction=float], [caching=boolean], [constructionHistory=boolean], [duplicate=boolean], [gain=float], [gravity=[linear, linear, linear]], [gravityX=linear], [gravityY=linear], [gravityZ=linear], [keepFacesTogether=boolean], [keepFacetTogether=boolean], [localCenter=int], [localDirection=[linear, linear, linear]], [localDirectionX=linear], [localDirectionY=linear], [localDirectionZ=linear], [localRotate=[angle, angle, angle]], [localRotateX=angle], [localRotateY=angle], [localRotateZ=angle], [localScale=[float, float, float]], [localScaleX=float], [localScaleY=float], [localScaleZ=float], [localTranslate=[linear, linear, linear]], [localTranslateX=linear], [localTranslateY=linear], [localTranslateZ=linear], [magnX=linear], [magnY=linear], [magnZ=linear], [magnet=[linear, linear, linear]], [name=string], [nodeState=int], [offset=float], [pivot=[linear, linear, linear]], [pivotX=linear], [pivotY=linear], [pivotZ=linear], [random=float], [scale=[float, float, float]], [scaleX=float], [scaleY=float], [scaleZ=float], [translate=[linear, linear, linear]], [translateX=linear], [translateY=linear], [translateZ=linear], [weight=float], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyChipOff is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Duplicate
cmds.polyPlane( n='plg', w=10, h=10 )
cmds.polyChipOff( 'plg.f[71:72]', 'plg.f[81:82]', dup=True, ltz=1 )
---
facets are duplicated and translated in local space

Extract
cmds.polyChipOff( 'plg.f[11:12]', 'plg.f[21:22]', dup=False, ty=1 )
---
facets are extracted and translated in world space

Separate
cmds.polyChipOff( 'plg.f[15:16]', 'plg.f[23:24]', dup=False, kft=False, ls=(.5, .5, 0) )
---
facets are extracted then scaled separately

Together
cmds.polyChipOff( 'plg.f[73:74]', 'plg.f[83:84]', dup=False, kft=True, ls=(.5, .5, 0) )
---
facets are extracted then scaled together

---
Return:
---


    string: The node name.

Flags:
---


---
attraction(att): float
    properties: create, query, edit
    Attraction, related to magnet.
The range is [-2.0, 2.0].
Default: 0.0

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
duplicate(dup): boolean
    properties: create, query, edit
    If "on", facets are duplicated, otherwise original facets are removed.
C: Default is "on".
Q: When queried, this flag returns an int.

---
gain(ga): float
    properties: create, query, edit, multiuse
    Gain factor per component. Can be painted using Artisan.
Default: 1.0

---
gravity(g): [linear, linear, linear]
    properties: create, query, edit
    The gravity vector.
Default: 0.0, -1.0, 0.0

---
gravityX(gx): linear
    properties: create, query, edit
    Gravity X coord.

---
gravityY(gy): linear
    properties: create, query, edit
    Gravity Y coord.

---
gravityZ(gz): linear
    properties: create, query, edit
    Gravity Z coord.

---
keepFacesTogether(kft): boolean
    properties: create, query, edit
    How to extrude edges.
If "on", extruded faces produced from the edges being extruded
will be kept together. Otherwise they are pulled independently.
Default: true

---
keepFacetTogether(xft): boolean
    properties: create, query, edit
    How to extrude edges.
If "on", extruded faces produced from the edges being extruded
will be kept together. Otherwise they are pulled independently.
Default: true

---
localCenter(lc): int
    properties: create, query, edit
    Local center on the edge : 0=Middle point, 1=Start point, 2=End point.
Default: 0

---
localDirection(ld): [linear, linear, linear]
    properties: create, query, edit
    Direction to determine X axis for local space.
Default: 1.0, 0.0, 0.0

---
localDirectionX(ldx): linear
    properties: create, query, edit
    X coord of the X axis.

---
localDirectionY(ldy): linear
    properties: create, query, edit
    Y coord of the X axis.

---
localDirectionZ(ldz): linear
    properties: create, query, edit
    Z coord of the X axis.

---
localRotate(lr): [angle, angle, angle]
    properties: create, query, edit
    The local rotations.
Default: 0.0, 0.0, 0.0

---
localRotateX(lrx): angle
    properties: create, query, edit
    Local rotate X coord.
The range is [0, 360].

---
localRotateY(lry): angle
    properties: create, query, edit
    Local rotate Y coord.
The range is [0, 360].

---
localRotateZ(lrz): angle
    properties: create, query, edit
    Local rotate Z coord : Rotation along the normal.
The range is [0, 360].

---
localScale(ls): [float, float, float]
    properties: create, query, edit
    Local Scale.
Default: 1.0, 1.0, 1.0

---
localScaleX(lsx): float
    properties: create, query, edit
    Scale X coord.

---
localScaleY(lsy): float
    properties: create, query, edit
    Scale Y coord.

---
localScaleZ(lsz): float
    properties: create, query, edit
    Scale Z coord.

---
localTranslate(lt): [linear, linear, linear]
    properties: create, query, edit
    Local translate.
Default: 0.0, 0.0, 0.0

---
localTranslateX(ltx): linear
    properties: create, query, edit
    Local translation X coord.

---
localTranslateY(lty): linear
    properties: create, query, edit
    Local translation Y coord.

---
localTranslateZ(ltz): linear
    properties: create, query, edit
    Local translation Z coord : Move along the normal.

---
magnX(mx): linear
    properties: create, query, edit
    Magnet X coord.

---
magnY(my): linear
    properties: create, query, edit
    Magnet Y coord.

---
magnZ(mz): linear
    properties: create, query, edit
    Magnet Z coord.

---
magnet(m): [linear, linear, linear]
    properties: create, query, edit
    The magnet vector.
Default: 0.0, 0.0, 0.0

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
offset(off): float
    properties: create, query, edit
    Local offset. Faces are moved this distance towards the inside of the face.
Default: 0.0

---
pivot(pvt): [linear, linear, linear]
    properties: create, query, edit
    The pivot for scaling and rotation.
Default: 0.0, 0.0, 0.0

---
pivotX(pvx): linear
    properties: create, query, edit
    Pivot X coord.

---
pivotY(pvy): linear
    properties: create, query, edit
    Pivot Y coord.

---
pivotZ(pvz): linear
    properties: create, query, edit
    Pivot Z coord.

---
random(ran): float
    properties: create, query, edit
    Random value for all parameters.
Default: 0.0

---
scale(s): [float, float, float]
    properties: create, query, edit
    Scaling vector.
Default: 1.0, 1.0, 1.0

---
scaleX(sx): float
    properties: create, query, edit
    Scale X coord.

---
scaleY(sy): float
    properties: create, query, edit
    Scale Y coord.

---
scaleZ(sz): float
    properties: create, query, edit
    Scale Z coord.

---
translate(t): [linear, linear, linear]
    properties: create, query, edit
    Translation vector.
Default: 0.0, 0.0, 0.0

---
translateX(tx): linear
    properties: create, query, edit
    Translation X coord.

---
translateY(ty): linear
    properties: create, query, edit
    Translation Y coord.

---
translateZ(tz): linear
    properties: create, query, edit
    Translation Z coord.

---
weight(w): float
    properties: create, query, edit
    The weight, related to gravity.
Default: 0.0

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyChipOff.html 
    """


def polyCircularize(flagalignment: int, flagcaching: boolean, flagconstructionHistory: boolean, flagcreateCurve: boolean, flagevenlyDistribute: boolean, flaginputCurve: name, flagname: string, flagnodeState: int, flagnormalOrientation: int, flagradialOffset: float, flagsmoothingAngle: float, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyCircularize([alignment=int], [caching=boolean], [constructionHistory=boolean], [createCurve=boolean], [evenlyDistribute=boolean], [inputCurve=name], [name=string], [nodeState=int], [normalOrientation=int], [radialOffset=float], [smoothingAngle=float], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCircularize is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.polyCube( name='poly1' )
cmds.polyCircularize( 'poly1' )

---
Return:
---


    string: The node name.

Flags:
---


---
alignment(al): int
    properties: create, query, edit
    How the circle should be  oriented relative to the surface
Default: 0

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createCurve(cc): boolean
    properties: create
    If true then the operation can create a curve.

---
evenlyDistribute(ed): boolean
    properties: create, query, edit
    Should the point be evenly distributed around the circle
Default: true

---
inputCurve(inc): name
    properties: create
    This flag specifies the name of the curve to be used as input for the operation.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
normalOrientation(nor): int
    properties: create, query, edit
    What calculation to use to get circle plane normal
Default: 0

---
radialOffset(ro): float
    properties: create, query, edit
    The amount the circle points should be translated along radius
Default: 0.0

---
smoothingAngle(sa): float
    properties: create, query, edit
    The angle that decides which resulting faces are hard or soft
Default: 30.0

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCircularize.html 
    """


def polyCircularizeEdge(flagalignment: int, flagcaching: boolean, flagconstructionHistory: boolean, flagcreateCurve: boolean, flagevenlyDistribute: boolean, flaginputCurve: name, flagname: string, flagnodeState: int, flagnormalOrientation: int, flagradialOffset: float, flagsmoothingAngle: float, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyCircularizeEdge([alignment=int], [caching=boolean], [constructionHistory=boolean], [createCurve=boolean], [evenlyDistribute=boolean], [inputCurve=name], [name=string], [nodeState=int], [normalOrientation=int], [radialOffset=float], [smoothingAngle=float], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCircularizeEdge is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.polyCube( name='poly1' )
cmds.polyCircularizeEdge( 'poly1' )

---
Return:
---


    string: The node name.

Flags:
---


---
alignment(al): int
    properties: create, query, edit
    How the circle should be  oriented relative to the surface
Default: 0

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createCurve(cc): boolean
    properties: create
    If true then the operation can create a curve.

---
evenlyDistribute(ed): boolean
    properties: create, query, edit
    Should the point be evenly distributed around the circle
Default: true

---
inputCurve(inc): name
    properties: create
    This flag specifies the name of the curve to be used as input for the operation.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
normalOrientation(nor): int
    properties: create, query, edit
    What calculation to use to get circle plane normal
Default: 0

---
radialOffset(ro): float
    properties: create, query, edit
    The amount the circle points should be translated along radius
Default: 0.0

---
smoothingAngle(sa): float
    properties: create, query, edit
    The angle that decides which resulting faces are hard or soft
Default: 30.0

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCircularizeEdge.html 
    """


def polyCircularizeFace(flagalignment: int, flagcaching: boolean, flagconstructionHistory: boolean, flagcreateCurve: boolean, flagevenlyDistribute: boolean, flaginputCurve: name, flagname: string, flagnodeState: int, flagnormalOrientation: int, flagradialOffset: float, flagsmoothingAngle: float, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyCircularizeFace([alignment=int], [caching=boolean], [constructionHistory=boolean], [createCurve=boolean], [evenlyDistribute=boolean], [inputCurve=name], [name=string], [nodeState=int], [normalOrientation=int], [radialOffset=float], [smoothingAngle=float], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCircularizeFace is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.polyCube( name='poly1' )
cmds.polyCircularizeFace( 'poly1' )

---
Return:
---


    string: The node name.

Flags:
---


---
alignment(al): int
    properties: create, query, edit
    How the circle should be  oriented relative to the surface
Default: 0

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createCurve(cc): boolean
    properties: create
    If true then the operation can create a curve.

---
evenlyDistribute(ed): boolean
    properties: create, query, edit
    Should the point be evenly distributed around the circle
Default: true

---
inputCurve(inc): name
    properties: create
    This flag specifies the name of the curve to be used as input for the operation.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
normalOrientation(nor): int
    properties: create, query, edit
    What calculation to use to get circle plane normal
Default: 0

---
radialOffset(ro): float
    properties: create, query, edit
    The amount the circle points should be translated along radius
Default: 0.0

---
smoothingAngle(sa): float
    properties: create, query, edit
    The angle that decides which resulting faces are hard or soft
Default: 30.0

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCircularizeFace.html 
    """


def polyClean(flagcaching: boolean, flagcleanEdges: boolean, flagcleanPartialUVMapping: boolean, flagcleanUVs: boolean, flagcleanVertices: boolean, flagconstructionHistory: boolean, flagfrozen: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyClean([caching=boolean], [cleanEdges=boolean], [cleanPartialUVMapping=boolean], [cleanUVs=boolean], [cleanVertices=boolean], [constructionHistory=boolean], [frozen=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyClean is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

import maya.cmds as cmds

cmds.polyCube()
cmds.polyClean()

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
cleanEdges(ce): boolean
    properties: create, query, edit
    If true, the operation will look for and delete edges that are
not associated with any face in the mesh.

---
cleanPartialUVMapping(cpm): boolean
    properties: create, query, edit
    If true, the operation will look for any faces on the mesh that do
not have complete UV mapping.  Maya requires that all vertices that
make up a mesh face have valid UV data associated with them, or that
none of the vertices withing the face have associated UVs.

---
cleanUVs(cuv): boolean
    properties: create, query, edit
    If true, the operation will look for and delete UVs that are
not associated with any face in the mesh.

---
cleanVertices(cv): boolean
    properties: create, query, edit
    If true, the operation will look for and delete vertices that are
not associated with any face in the mesh.

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
frozen(fzn): boolean
    properties: create, query, edit
    Toggle frozen state for a particular node to keep current evaluation
state and prevent any other indirect changes to it.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyClean.html 
    """


def polyClipboard(flagclear: boolean, flagcolor: boolean, flagcopy: boolean, flagpaste: boolean, flagshader: boolean, flaguvCoordinates: boolean) -> boolean:
    """Synopsis:
---
---
 polyClipboard([clear=boolean], [color=boolean], [copy=boolean], [paste=boolean], [shader=boolean], [uvCoordinates=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyClipboard is undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

Copy uv, color and shader attributes
cmds.polyClipboard( copy=True, uv=True, color=True, shader=True )

Paste only shader attribute
cmds.polyClipboard( paste=True, shader=True )

Copy color attribute only
cmds.polyClipboard( copy=True, color=True )

Clear all the clipboard attributes
cmds.polyClipboard( clear=True, uv=True, color=True, shader=True )

---
Return:
---


    boolean: Success or Failure

Flags:
---


---
clear(cl): boolean
    properties: create
    When used, will mean to clear the specified attribute argument(s).

---
color(clr): boolean
    properties: create
    When used, will be to copy or paste color attributes

---
copy(cp): boolean
    properties: create
    When used, will mean to copy the specified attribute argument(s).

---
paste(ps): boolean
    properties: create
    When used, will mean to paste the specified attribute argument(s).

---
shader(sh): boolean
    properties: create
    When used, will be to copy or paste shader attributes

---
uvCoordinates(uv): boolean
    properties: create
    When used, will be to copy or paste texture coordinate attributes

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyClipboard.html 
    """


def polyCloseBorder(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyCloseBorder([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCloseBorder is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Creation of a plane.
cmds.polyPlane( n='plg', sx=10, sy=10, h=20, w=20 )

Display the poly Borders
cmds.polyOptions( db=True )

Delete some facets of the plane.
cmds.delete( 'plg.f[33:36]', 'plg.f[43:46]', 'plg.f[53:56]', 'plg.f[63:66]' )

Close the border on one of the edges of the hole
Note that only one edge for each hole needs to be given
cmds.select( 'plg.e[89]', r=True )
cmds.polyCloseBorder()
There is now a face where the hole was

---
Reset display
cmds.polyOptions( db=False )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCloseBorder.html 
    """


def polyCollapseEdge(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyCollapseEdge([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCollapseEdge is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a plane.
cmds.polyPlane( n='plg', sx=10, sy=10, h=20, w=20 )

Collapse one edge,
cmds.polyCollapseEdge( 'plg.e[200]' )

Or multiple edges:
cmds.select( 'plg.e[74]', 'plg.e[92]', 'plg.e[94:95]' )
Command works on selection list if
no command line arguments are given.
cmds.polyCollapseEdge()

Note that the command works on one edge at a time, so the
resulting vertex from a selection of multiple edges will
not typically be in the center of the selection.

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCollapseEdge.html 
    """


def polyCollapseFacet(flagareaThreshold: float, flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int, flaguseAreaThreshold: boolean) -> string:
    """Synopsis:
---
---
 polyCollapseFacet([areaThreshold=float], [caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int], [useAreaThreshold=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCollapseFacet is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a plane.
cmds.polyPlane( n='plg', sx=10, sy=10, h=20, w=20 )

You can collapse a facet,
cmds.polyCollapseFacet( 'plg.f[54]' )

Or several ones.
cmds.polyCollapseFacet( 'plg.f[33:35]', 'plg.f[43:45]', 'plg.f[53:55]' )

---
Return:
---


    string: The node name.

Flags:
---


---
areaThreshold(at): float
    properties: create, query, edit
    Area threshold to determine whether faces should
be collapsed. Attribute is ignored unless useAreaThreshold is
set to true.
Default: 0.1

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
useAreaThreshold(uat): boolean
    properties: create, query, edit
    If true only collapse faces with area less than the area threshold,
otherwise collapse all faces regardless of area
Default: false

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCollapseFacet.html 
    """


def polyCollapseTweaks(flaghasVertexTweaks: boolean) -> None:
    """Synopsis:
---
---
 polyCollapseTweaks([hasVertexTweaks=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCollapseTweaks is undoable, queryable, and NOT editable.
This command is only useful in cases where no construction history is associated
with the shape node.

If a mesh name is not specified as input, a singly selected mesh (if any) will
have its tweaked vertices baked.




Example:
---
import maya.cmds as cmds

Create a plane.
cmds.polyPlane( sx=10, sy=10, h=20, w=20, ch=0 )

Query the existence of vertex tweaks for pPlane1
cmds.polyCollapseTweaks ( 'pPlane1', q=True, hvt=True )
Result: 0

Move a vertex,
cmds.select( 'pPlane1.vtx[8]', r=True )
cmds.move( 10, 20, 30, r=True )

Query vertex tweaks for vertex id 8
cmds.getAttr( 'pPlane1.vtx[8]' );
Result: [(10.0, 20.0, 30.0)]

Query the existence of vertex tweaks for pPlane1
cmds.polyCollapseTweaks ( 'pPlane1', q=True, hvt=True )
Result: 1

Bake all vertex tweaks into their respective vertices.
cmds.polyCollapseTweaks( 'pPlane1' )

Query vertex tweaks for vertex id 8
cmds.getAttr( 'pPlane1.vtx[8]' );
Result: [(0.0, 0.0, 0.0)]

Query the existence of vertex tweaks for pPlane1
cmds.polyCollapseTweaks ( 'pPlane1', q=True, hvt=True )
Result: 0

---


Flags:
---


---
hasVertexTweaks(hvt): boolean
    properties: create, query
    Determines whether an individual mesh has vertex tweaks.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCollapseTweaks.html 
    """


def polyColorBlindData(flagaboveMaxColorBlue: float, flagaboveMaxColorGreen: float, flagaboveMaxColorRed: float, flagattrName: string, flagbelowMinColorBlue: float, flagbelowMinColorGreen: float, flagbelowMinColorRed: float, flagclashColorBlue: float, flagclashColorGreen: float, flagclashColorRed: float, flagcolorBlue: float, flagcolorGreen: float, flagcolorRed: float, flagdataType: string, flagenableFalseColor: boolean, flagmaxColorBlue: float, flagmaxColorGreen: float, flagmaxColorRed: float, flagmaxValue: float, flagminColorBlue: float, flagminColorGreen: float, flagminColorRed: float, flagminValue: float, flagmode: int, flagnoColorBlue: float, flagnoColorGreen: float, flagnoColorRed: float, flagnumIdTypes: int, flagqueryMode: boolean, flagtypeId: int, flaguseMax: boolean, flaguseMin: boolean, flagvalue: string) -> list[string]:
    """Synopsis:
---
---
 polyColorBlindData([aboveMaxColorBlue=float], [aboveMaxColorGreen=float], [aboveMaxColorRed=float], [attrName=string], [belowMinColorBlue=float], [belowMinColorGreen=float], [belowMinColorRed=float], [clashColorBlue=float], [clashColorGreen=float], [clashColorRed=float], [colorBlue=float], [colorGreen=float], [colorRed=float], [dataType=string], [enableFalseColor=boolean], [maxColorBlue=float], [maxColorGreen=float], [maxColorRed=float], [maxValue=float], [minColorBlue=float], [minColorGreen=float], [minColorRed=float], [minValue=float], [mode=int], [noColorBlue=float], [noColorGreen=float], [noColorRed=float], [numIdTypes=int], [queryMode=boolean], [typeId=int], [useMax=boolean], [useMin=boolean], [value=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyColorBlindData is NOT undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

In these examples we have type 1000, with one double attribute
called "fluffy", and type 1001 with attributes "grimy" and "slimy".

Color all items of id 1000 red. Note that we must also specify
None color (black) and Clash color(cyan). Note that we must also
specify the names of the attributes, even if we don't care about
the attribute values:
cmds.polyColorBlindData( ncr=0, ncg=0, ncb=0, ccr=0, ccg=1, ccb=1, id=1000, num=1, m=0, n='fluffy', cr=1, cg=0, cb=0 )

Now color only those values of "fluffy" between 2 and 5:
cmds.polyColorBlindData( ncr=0, ncg=0, ncb=0, ccr=0, ccg=1, ccb=1, id=1000, num=1, m=2, dt='double', n='fluffy', umn=1, mnv=2, umx=1, mxv=5, cr=1, cg=0, cb=0 )

Note for a continuous range query we must specify min, max and
out of range color instead of just color (here values between 2 and 5
are colored between white and gray, out of range values are yellow):
cmds.polyColorBlindData( ncr=0, ncg=0, ncb=0, ccr=0, ccg=1, ccb=1, id=1000, num=1, m=6, dt='double', n='fluffy', bmr=1, bmg=1, bmb=0, amr=1, amg=1, amb=0, mnr=0.250980407, mng=0.250980407, mnb=0.250980407, mxr=1, mxg=1, mxb=1, mnv=2, mxv=5 )

Now, for attribute "fluffy", color values of 2 red and values of 2 green:
cmds.polyColorBlindData( ncr=0, ncg=0, ncb=0, ccr=0, ccg=1, ccb=1, id=1000, num=1, m=1, dt='double', n='fluffy', v='2', cr=1, cg=0, cb=0, id=1000, num=1, m=1, dt='double', n='fluffy', v='3', cr=0, cg=1, cb=0 )

To just query and not color, filter the active selection list
and return the list of components that meet the criteria (in this
case having blind data of type 1000)
cmds.polyColorBlindData( 1000, '-num', 1, '-m', 0, '-n', 'fluffy', query=True, id=True )

Now if we have 2 attributes:
cmds.polyColorBlindData( ncr=0, ncg=0, ncb=0, ccr=0, ccg=1, ccb=1, id=1001, num=2, m=0, n='grimy', n='slimy', cr=1, cg=0, cb=0 )

Note that when querying for value, values of all attrs must be specified
here we set (grimy = 22, slimy = 1) to be red, and (grimy = 55, slimy = 2)
to be green

cmds.polyColorBlindData( ncr=0, ncg=0, ncb=0, ccr=0, ccg=1, ccb=1, id=1001, num=2, m=1, dt='double', n='grimy', v='22', cr=1, cg=0, cb=0, dt='int', n='slimy', v='1', cr=1, cg=0, cb=0, id=1001, num=2, m=1, dt='double', n='grimy', v='55', cr=0, cg=1, cb=0, dt='int', n='slimy', v='2', cr=0, cg=1, cb=0 )

---
Return:
---


    list[string]: Command result

Flags:
---


---
aboveMaxColorBlue(amb): float
    properties: create, multiuse
    Specifies blue component of color to use for data that is above max

---
aboveMaxColorGreen(amg): float
    properties: create, multiuse
    Specifies green component of color to use for data that is above max

---
aboveMaxColorRed(amr): float
    properties: create, multiuse
    Specifies red component of color to use for data that is above max

---
attrName(n): string
    properties: create, multiuse
    Specifies the name of the data that is being examined by this command.

---
belowMinColorBlue(bmb): float
    properties: create, multiuse
    Specifies blue component of color to use for data that is below min

---
belowMinColorGreen(bmg): float
    properties: create, multiuse
    Specifies green component of color to use for data that is below min

---
belowMinColorRed(bmr): float
    properties: create, multiuse
    Specifies red component of color to use for data that is below min

---
clashColorBlue(ccb): float
    properties: create
    Specifies blue component color to use for data which clashes

---
clashColorGreen(ccg): float
    properties: create
    Specifies green component color to use for data which clashes

---
clashColorRed(ccr): float
    properties: create
    Specifies red component color to use for data which clashes

---
colorBlue(cb): float
    properties: create, multiuse
    Specifies blue component of color to use for given data

---
colorGreen(cg): float
    properties: create, multiuse
    Specifies green component of color to use for given data

---
colorRed(cr): float
    properties: create, multiuse
    Specifies red component of color to use for given data

---
dataType(dt): string
    properties: create, multiuse
    Specifies the type for this id

---
enableFalseColor(efc): boolean
    properties: create
    Turns false coloring on or off for all poly objects in the scene

---
maxColorBlue(mxb): float
    properties: create, multiuse
    Specifies blue component of color to use for max value for grayscale

---
maxColorGreen(mxg): float
    properties: create, multiuse
    Specifies green component of color to use for max value for grayscale

---
maxColorRed(mxr): float
    properties: create, multiuse
    Specifies red component of color to use for max value for grayscale

---
maxValue(mxv): float
    properties: create, multiuse
    Specifies the max value for grayscale or discrete range data

---
minColorBlue(mnb): float
    properties: create, multiuse
    Specifies blue component of color to use for min value for grayscale

---
minColorGreen(mng): float
    properties: create, multiuse
    Specifies green component of color to use for min value for grayscale

---
minColorRed(mnr): float
    properties: create, multiuse
    Specifies red component of color to use for min value for grayscale

---
minValue(mnv): float
    properties: create, multiuse
    Specifies the min value for grayscale or discrete range data

---
mode(m): int
    properties: create, multiuse
    Specifies the mode:

0 : binary - only components and objects that have the data will be colored
1 : discrete value - a value is specified. Data that matches this value will be colored
2 : discrete range - values that fall within the given range will be colored
3 : unsigned set mode - if ( givenValue & actualValue ) then data will be colored
4 : unsigned not set mode - if ( !(givenValue & actualValue) ) then data will be colored
5 : unsigned equal mode - if ( givenValue == actualValue ) then data will be colored
6 : grayscale mode - a min value, max value, min color, max color, below min color, and
    above max color are given. Data is colored according to how it relates to these values.
7 : as color mode - if the blind data consists of 3 doubles, ranged 0-1, the components are colored as the data specifies

---
noColorBlue(ncb): float
    properties: create
    Specifies blue component of color to use for no data assigned

---
noColorGreen(ncg): float
    properties: create
    Specifies green component of color to use for no data assigned

---
noColorRed(ncr): float
    properties: create
    Specifies red component of color to use for no data assigned

---
numIdTypes(num): int
    properties: create, multiuse
    Specifies how many attrs are in this id type

---
queryMode(q): boolean
    properties: create
    If on, do not color and return selection as string array instead.
Any data that would be colored normally (except for 'no color' and
out of range colors) is returned

---
typeId(id): int
    properties: create, multiuse
    Specifies the typeId of the BlindData type being created

---
useMax(umx): boolean
    properties: create, multiuse
    Specifies whether the max should be used for discrete ranges

---
useMin(umn): boolean
    properties: create, multiuse
    Specifies whether the min should be used for discrete ranges

---
value(v): string
    properties: create, multiuse
    The value of the data

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyColorBlindData.html 
    """


def polyColorDel(flagcaching: boolean, flagcolorSetName: string, flagconstructionHistory: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyColorDel([caching=boolean], [colorSetName=string], [constructionHistory=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyColorDel is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a plane.
cmds.polyPlane( n='plg', sx=5, sy=5, w=20, h=20 )
polyColorPerVertex -r 0 -g 0 -b 1 -a 1 -cdo;

Delete the color from the given faces.
cmds.polyColorDel( 'plg.f[11:13]', 'plg.f[16:18]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
colorSetName(cls): string
    properties: create, query, edit
    The name of the color set to work on

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyColorDel.html 
    """


def polyColorMod(flagalphaScale_FloatValue: float, flagalphaScale_Interp: int, flagalphaScale_Position: float, flagbaseColorName: string, flagblueScale_FloatValue: float, flagblueScale_Interp: int, flagblueScale_Position: float, flagcaching: boolean, flagconstructionHistory: boolean, flaggreenScale_FloatValue: float, flaggreenScale_Interp: int, flaggreenScale_Position: float, flaghuev: float, flagintensityScale_FloatValue: float, flagintensityScale_Interp: int, flagintensityScale_Position: float, flagname: string, flagnodeState: int, flagredScale_FloatValue: float, flagredScale_Interp: int, flagredScale_Position: float, flagsatv: float, flagvalue: float) -> string:
    """Synopsis:
---
---
 polyColorMod([alphaScale_FloatValue=float], [alphaScale_Interp=int], [alphaScale_Position=float], [baseColorName=string], [blueScale_FloatValue=float], [blueScale_Interp=int], [blueScale_Position=float], [caching=boolean], [constructionHistory=boolean], [greenScale_FloatValue=float], [greenScale_Interp=int], [greenScale_Position=float], [huev=float], [intensityScale_FloatValue=float], [intensityScale_Interp=int], [intensityScale_Position=float], [name=string], [nodeState=int], [redScale_FloatValue=float], [redScale_Interp=int], [redScale_Position=float], [satv=float], [value=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyColorMod is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a poly plane pPlane1
cmds.polyPlane(w=10, h=10, sx=10, sy=10, n='pPlane1')

Create colorSet1 , set to use RGBA channel
cmds.polyColorSet(create=True, clamped=0, rpt='RGBA', colorSet='colorSet1')
Apply red color to the vertices of pPlane1
cmds.polyColorPerVertex(r=1, g=0, b=0, a=1, cdo=True)

Modified the color of colorSet1 to green
cmds.polyColorMod('pPlane1',huev=120, bcn='colorSet1')

---
Return:
---


    string: The node name.

Flags:
---


---
alphaScale_FloatValue(afv): float
    properties: create, query, edit
    ?????

---
alphaScale_Interp(ai): int
    properties: create, query, edit
    ?????
Default: 0

---
alphaScale_Position(ap): float
    properties: create, query, edit
    ?????

---
baseColorName(bcn): string
    properties: create
    The name of the color set to be modified.

---
blueScale_FloatValue(bfv): float
    properties: create, query, edit
    ?????

---
blueScale_Interp(bi): int
    properties: create, query, edit
    ?????
Default: 0

---
blueScale_Position(bp): float
    properties: create, query, edit
    ?????

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
greenScale_FloatValue(gfv): float
    properties: create, query, edit
    ?????

---
greenScale_Interp(gi): int
    properties: create, query, edit
    ?????
Default: 0

---
greenScale_Position(gp): float
    properties: create, query, edit
    ?????

---
huev(h): float
    properties: create, query, edit
    Hue  rotates hue value of the final color.
Default: 0.0

---
intensityScale_FloatValue(nfv): float
    properties: create, query, edit
    ?????

---
intensityScale_Interp(ni): int
    properties: create, query, edit
    ?????
Default: 0

---
intensityScale_Position(np): float
    properties: create, query, edit
    ?????

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
redScale_FloatValue(rfv): float
    properties: create, query, edit
    ?????

---
redScale_Interp(ri): int
    properties: create, query, edit
    ?????
Default: 0

---
redScale_Position(rp): float
    properties: create, query, edit
    ?????

---
satv(s): float
    properties: create, query, edit
    Sat scales the staturation of the final color.
Default: 1.0

---
value(v): float
    properties: create, query, edit
    Value scales the final color value.
Default: 1.0

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyColorMod.html 
    """


def polyColorPerVertex(flagalpha: float, flagclamped: boolean, flagcolorB: float, flagcolorDisplayOption: boolean, flagcolorG: float, flagcolorR: float, flagcolorRGB: tuple[float, float, float], flagnotUndoable: boolean, flagrelative: boolean, flagremove: boolean, flagrepresentation: int) -> boolean:
    """Synopsis:
---
---
 polyColorPerVertex([alpha=float], [clamped=boolean], [colorB=float], [colorDisplayOption=boolean], [colorG=float], [colorR=float], [colorRGB=[float, float, float]], [notUndoable=boolean], [relative=boolean], [remove=boolean], [representation=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyColorPerVertex is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

To set the rgb channels of selected vertices:
cmds.polyColorPerVertex( rgb=(0.8, 0.0, 0.4) )

To set just the "g" channel of selected vertices:
cmds.polyColorPerVertex( g =0.5 )

To add to the current value of just the "g" channel of selected vertices:
cmds.polyColorPerVertex( rel=True, g =0.2 )

To query the "g" and "b" channels of color on selected vertices:
cmds.polyColorPerVertex( query=True, g=True, b=True )

---
Return:
---


    boolean: Success or Failure.

Flags:
---


---
alpha(a): float
    properties: create, query, edit
    Specifies the alpha channel of color

---
clamped(cla): boolean
    properties: create, query, edit
    This flag specifies if the color set will truncate any value that is
outside 0 to 1 range.

---
colorB(b): float
    properties: create, query, edit
    Specifies the B channel of color

---
colorDisplayOption(cdo): boolean
    properties: create, query, edit
    Change the display options on the mesh to display the vertex colors.

---
colorG(g): float
    properties: create, query, edit
    Specifies the G channel of color

---
colorR(r): float
    properties: create, query, edit
    Specifies the R channel of color

---
colorRGB(rgb): [float, float, float]
    properties: create, query, edit
    Specifies the RGB channels of color

---
notUndoable(nun): boolean
    properties: create, query, edit
    Execute the command, but without having the command
be undoable. This option will greatly improve performance
for large numbers of object. This will make the command
not undoable regardless of whether undo has been
enabled or not.

---
relative(rel): boolean
    properties: create, query, edit
    When used, the color values specified are added relative to the current values.

---
remove(rem): boolean
    properties: create, query, edit
    When used, the color values are removed from the selected or specified objects
or components. This option only supports meshes with no construction history, or meshes
whose construction history includes a recent polyColorPerVertexNode. For meshes whose construction
history includes a polgon operation the polyColorPerVertexNode, consider using the polyColorDel command instead

---
representation(rpt): int
    properties: create, query, edit
    This flag corresponds to the color channels to used, for example
A(alpha only), RGB, and RGBA.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyColorPerVertex.html 
    """


def polyColorSet(flagallColorSets: boolean, flagclamped: boolean, flagcolorSet: string, flagcopy: boolean, flagcreate: boolean, flagcurrentColorSet: boolean, flagcurrentPerInstanceSet: boolean, flagdelete: boolean, flagnewColorSet: string, flagperInstance: boolean, flagrename: boolean, flagrepresentation: string, flagshareInstances: boolean, flagunshared: boolean) -> boolean:
    """Synopsis:
---
---
 polyColorSet([allColorSets=boolean], [clamped=boolean], [colorSet=string], [copy=boolean], [create=boolean], [currentColorSet=boolean], [currentPerInstanceSet=boolean], [delete=boolean], [newColorSet=string], [perInstance=boolean], [rename=boolean], [representation=string], [shareInstances=boolean], [unshared=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyColorSet is undoable, queryable, and editable.

 delete an existing color set. 
 rename an existing color set. 
 create a new empty color set. 
 set the current color set to a pre-existing color set. 
 modify sharing between instances of per-instance color sets. 
 query the current color set. 
 query the names of all color sets. 
 query the name(s) along with representation value(s) or clamped value(s) of all color sets. 
 query the representation value or clamped value of the current color set. 




Example:
---
import maya.cmds as cmds


To set the current color set to be "color2".
cmds.polyColorSet(currentColorSet=True, colorSet= 'color2' )

To query the current color set.
cmds.polyColorSet( query=True, currentColorSet=True )

To create a per-instance color set family with one set member
per selected instance.
cmds.polyColorSet(create=True,colorSet='perInst',perInstance=True,unshared=True)

To create a per-instance color set family with one set member
for all selected instances.
cmds.polyColorSet(create=True,colorSet='perInst',perInstance=True)

To rename a currently existing color set from "color3" to "color4".
cmds.polyColorSet( rename=True, colorSet= 'color3', newColorSet= 'color4' )

Rename the current color set (if any) to "color3".
cmds.polyColorSet( rename=True, newColorSet= 'color3')

To delete a currently existing color set "color3".
cmds.polyColorSet( delete= True, colorSet= 'color3')

To delete the current color set (if any)
cmds.polyColorSet( delete=True )

Copy values of color set "color1" to "color2"
Note if the second color set exist it will be overwriten by
the copy. Leaving the destination color blank and the command
will generate a new unique name based on the source name.
cmds.polyColorSet( copy= True, colorSet='color1', newColorSet ='color2')

Copy values of the current color set to "color2"
cmds.polyColorSet( copy= True, newColorSet='color2')

Make a copy of "color1" to a new color set. The
name of which is automatically generated and returned.
cmds.polyColorSet( copy= True, colorSet='color1' )

Create a new empty color set
cmds.polyColorSet( create=True, colorSet='newColor')

To query all of the color sets
cmds.polyColorSet( query=True, allColorSets=True )

To query all of the color set names and their representation values
cmds.polyColorSet( query=True, allColorSets=True, representation=True )

To query the clamped value of the current color set
cmds.polyColorSet( query=True, currentColorSet=True, clamped=True )

---
Return:
---


    boolean: Success or Failure.

Flags:
---


---
allColorSets(acs): boolean
    properties: create, query, edit
    This flag when used in a query will return a list of all
of the color set names

---
clamped(cla): boolean
    properties: create, query, edit
    This flag specifies if the color set will truncate any value that is
outside 0 to 1 range.

---
colorSet(cs): string
    properties: create, query, edit
    Specifies the name of the color set that this command needs to work on.
This flag has to be specified for this command to do anything meaningful
other than query the current color set.

---
copy(cp): boolean
    properties: create, query, edit
    This flag when used will result in the copying of the color set corresponding
to name specified with the colorSet flag to the colorSet corresponding
to the name specified with the newcolorSet flag

---
create(cr): boolean
    properties: create, query, edit
    This flag when used will result in the creation of an empty color set
corresponding to the name specified with the colorSet flag. If
a color set with that name already exists, then no new color set will
be created.

---
currentColorSet(ccs): boolean
    properties: create, query, edit
    This flag when used will set the current color set that the object needs to
work on, to be the color set corresponding to the name specified with the
colorSet flag. This does require that a colorSet with the specified name exist.
When queried, this returns the current color set.

---
currentPerInstanceSet(cpi): boolean
    properties: query, edit
    This is a query-only flag for use when the current color set is a per-instance
color set family. This returns the member of the set family that corresponds
to the currently select instance.

---
delete(d): boolean
    properties: create, query, edit
    This flag when used will result in the deletion of the color set corresponding
to the name specified with the colorSet flag.

---
newColorSet(nc): string
    properties: create, query, edit
    Specifies the name that the color set corresponding to the name specified with
the colorSet flag, needs to be renamed to.

---
perInstance(pi): boolean
    properties: create, query, edit
    This flag can be used in conjunction with the create flag to indicate
whether or not the color set is per-instance. When you create a per-instance
color set, the set will be applied as shared between all selected instances
of the shape unless the unshared flag is used. The perInstance flag can
be used in query mode with the currentColorSet or allColorSets flag to indicate
that the set family names (i.e. not containing instance identifiers) will
be returned by the query.
                        In query mode, this flag can accept a value.

---
rename(rn): boolean
    properties: create, query, edit
    This flag when used will result in the renaming of the color set corresponding
to the name specified with the colorSet flag to the name specified using the
newColorSet flag.

---
representation(rpt): string
    properties: create, query, edit
    This flag corresponds to the color channels to used, for example
A(alpha only), RGB, and RGBA.

---
shareInstances(si): boolean
    properties: create, query, edit
    This flag is used to modify the sharing of per-instance color sets within
a given color set family so that all selected instances share the specified
set. In query mode, it returns a list of the instances that share the
set specified by the colorSet flag.

---
unshared(us): boolean
    properties: create, query, edit
    This flag can be used in conjunction with the create and perInstance flags
to indicate that the newly created per-instance set should be created with
a separate set per instance.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyColorSet.html 
    """


def polyCompare(flagcolorSetIndices: boolean, flagcolorSets: boolean, flagedges: boolean, flagfaceDesc: boolean, flaguserNormals: boolean, flaguvSetIndices: boolean, flaguvSets: boolean, flagvertices: boolean) -> int:
    """Synopsis:
---
---
 polyCompare(
poly poly
    , [colorSetIndices=boolean], [colorSets=boolean], [edges=boolean], [faceDesc=boolean], [userNormals=boolean], [uvSetIndices=boolean], [uvSets=boolean], [vertices=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCompare is undoable, NOT queryable, and NOT editable.




Example:
---
import maya.cmds as cmds

cmds.polySphere()
cmds.polySphere()
cmds.select( cl=True )
cmds.select( 'pSphere1', 'pSphere2', r=True )
cmds.polyCompare()

---
Return:
---


    int: 0 if successful, non-zero if poly1 and poly2 are not determined to be equal based on requested flags.
The non-zero value depends on which attributes are different:Vertices = 1Edges = 2Face Descriptions = 4UV Sets = 8UV Indices = 16Color Sets = 32Color Indices = 64User Normals = 128So a return value of 3, for example, indicates both vertices and edges are different.

Flags:
---


---
colorSetIndices(ic): boolean
    properties: create
    Compare poly1, poly2 for matching Color Indices.

---
colorSets(c): boolean
    properties: create
    Compare poly1, poly2 for matching Color Sets.

---
edges(e): boolean
    properties: create
    Compare poly1, poly2 for matching Edges.

---
faceDesc(fd): boolean
    properties: create
    Compare poly1, poly2 for matching Face Descriptions. Face descriptions describe the topology of a face, for example number and orientation of edges, number of topology of any holes in the face etc.

---
userNormals(un): boolean
    properties: create
    Compare poly1, poly2 for matching User Normals.

---
uvSetIndices(iuv): boolean
    properties: create
    Compare poly1, poly2 for matching UV Indices.

---
uvSets(uv): boolean
    properties: create
    Compare poly1, poly2 for matching UV Sets.

---
vertices(v): boolean
    properties: create
    Compare poly1, poly2 for matching Vertices.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCompare.html 
    """


def polyCone(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: int, flagheight: linear, flagname: string, flagnodeState: int, flagobject: boolean, flagradius: linear, flagroundCap: boolean, flagsubdivisionsAxis: int, flagsubdivisionsCap: int, flagsubdivisionsHeight: int, flagsubdivisionsX: int, flagsubdivisionsY: int, flagsubdivisionsZ: int, flagtexture: boolean) -> list[string]:
    """Synopsis:
---
---
 polyCone([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=int], [height=linear], [name=string], [nodeState=int], [object=boolean], [radius=linear], [roundCap=boolean], [subdivisionsAxis=int], [subdivisionsCap=int], [subdivisionsHeight=int], [subdivisionsX=int], [subdivisionsY=int], [subdivisionsZ=int], [texture=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCone is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a cone, with 10 subdivisions in the X direction,
15 subdivisions in the Y direction and 20 subdivisions in the Z direction,
the radius of the cone is 20, the height of the cone is 10.
cmds.polyCone( sx=10, sy=15, sz=5, r=20, h=10)

Create a cone, called "myCone", on each direction there are 5 subdivisions.
cmds.polyCone( n='myCone', sx=5, sy=5, sz=5)

Query the radius of "myCone"
r = cmds.polyCone( 'myCone', q=True, r=True )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the cone.
Q: When queried, this flag returns a float[3].

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createUVs(cuv): int
    properties: create, query, edit
    Create UVs or not.
0: No UVs
1: No Normalization
2: Normalize
3: Normalize and Preserve Aspect Ratio
Default: 2

---
height(h): linear
    properties: create, query, edit
    Height of the cone.
Default: 2.0

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
radius(r): linear
    properties: create, query, edit
    Radius of the cone.
Default: 1.0

---
roundCap(rcp): boolean
    properties: create, query, edit
    To indicate whether we need a round cap
Default: false

---
subdivisionsAxis(sa): int
    properties: create, query, edit
    Subdivisions around the axis.
Default: 20

---
subdivisionsCap(sc): int
    properties: create, query, edit
    Subdivisions on the bottom cap.
Default: 0

---
subdivisionsHeight(sh): int
    properties: create, query, edit
    Subdivisions along the height.
Default: 1

---
subdivisionsX(sx): int
    properties: create, query, edit
    This specifies the number of subdivisions in the X direction for the cone.
C: Default is 20.
Q: When queried, this flag returns an int.

---
subdivisionsY(sy): int
    properties: create, query, edit
    This flag specifies the number of subdivisions in the Y direction for the cone.
C: Default is 1.
Q: When queried, this flag returns an int.

---
subdivisionsZ(sz): int
    properties: create, query, edit
    This flag specifies the number of subdivisions in the Z direction for the cone.
C: Default is 0.
Q: When queried, this flag returns an int.

---
texture(tx): boolean
    properties: create, query, edit
    Apply texture or not.
Default: true

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCone.html 
    """


def polyConnectComponents(flagadjustEdgeFlow: float, flagcaching: boolean, flagconstructionHistory: boolean, flaginsertWithEdgeFlow: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyConnectComponents([adjustEdgeFlow=float], [caching=boolean], [constructionHistory=boolean], [insertWithEdgeFlow=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyConnectComponents is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

make a sphere
cmds.polySphere( r=1, sx=20, sy=20, ax=(0,1,0), cuv=2, ch=1, name='sph' )
split two faces by specifying 3 vertices
cmds.polyConnectComponents( 'sph.vtx[254]', 'sph.vtx[256]', 'sph.vtx[275]', ch=1 )
split two faces by specifying 3 edges
cmds.polyConnectComponents( 'sph.e[278]', 'sph.e[637:638]', ch=1 )
split three faces
cmds.polyConnectComponents( 'sph.f[66]', 'sph.f[215:217]', ch=1 )
a complex split involving vertices, edges and faces, in a loop
cmds.polyConnectComponents( 'sph.f[270:271]', 'sph.vtx[273]', 'sph.e[232]', 'sph.e[252]',  'sph.e[592]', 'sph.f[210]', 'sph.vtx[229]', 'sph.e[249]', 'sph.e[269]', ch=1 )

---
Return:
---


    string: The node name.

Flags:
---


---
adjustEdgeFlow(aef): float
    properties: create, query, edit
    The weight value of the edge vertices to be positioned.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
insertWithEdgeFlow(ief): boolean
    properties: create, query, edit
    True to enable edge flow. Otherwise, the edge flow is disabled.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyConnectComponents.html 
    """


def polyContourProjection(flagcaching: boolean, flagconstructionHistory: boolean, flagcreateNewMap: boolean, flagflipRails: boolean, flaginsertBeforeDeformers: boolean, flagmethod: int, flagname: string, flagnodeState: int, flagoffset0: linear, flagoffset1: linear, flagoffset2: linear, flagoffset3: linear, flagreduceShear: float, flagsmoothness0: float, flagsmoothness1: float, flagsmoothness2: float, flagsmoothness3: float, flaguserDefinedCorners: boolean, flaguvSetName: string, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyContourProjection([caching=boolean], [constructionHistory=boolean], [createNewMap=boolean], [flipRails=boolean], [insertBeforeDeformers=boolean], [method=int], [name=string], [nodeState=int], [offset0=linear], [offset1=linear], [offset2=linear], [offset3=linear], [reduceShear=float], [smoothness0=float], [smoothness1=float], [smoothness2=float], [smoothness3=float], [userDefinedCorners=boolean], [uvSetName=string], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyContourProjection is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a plane.
cmds.polyPlane( n='plane', sx=10, sy=10 )

Deform the plane and planar project UVs onto it.
cmds.softMod( 'plane', falloffRadius=1 )
cmds.move( 0, 0, -0.5, r=True, os=True, wd=True )
cmds.select( 'plane', r=True )
cmds.delete( 'plane', ch=True )
cmds.polyProjection( 'plane.f[0:99]', ch=1, type='Planar', ibd=0, md='y' )

Create a lambert node.
cmds.shadingNode( 'lambert', n='myLambert', asShader=True )
cmds.sets( renderable=True, noSurfaceShader=True, empty=True, name='myLambertSG' )
cmds.connectAttr( 'myLambert.outColor', 'myLambertSG.surfaceShader', f=True )

Create a texture checker.
cmds.shadingNode( 'checker', asTexture=True )
cmds.shadingNode( 'place2dTexture', asUtility=True )
cmds.connectAttr( 'place2dTexture1.outUV', 'checker1.uv' )
cmds.setAttr( 'place2dTexture1.repeatU', 4 )
cmds.setAttr( 'place2dTexture1.repeatV', 4 )

Assign the texture the the lambert node.
cmds.connectAttr( 'checker1.outColor', 'myLambert.color', f=True )

Set the textured display mode.
currentPanel = cmds.getPanel(withFocus= True)
if currentPanel != '':
        cmds.modelEditor(currentPanel, edit=True, da='smoothShaded', displayTextures=True, dl='default')

Assign the lambert shader to the plane.
cmds.sets('plane', edit=True, forceElement= 'myLambertSG' )

Use the contour stretch projection to assign 'rectangular' UVs to a strip of faces
cmds.polyContourProjection( 'plane.f[30:69]', ch=1, m=0 )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createNewMap(cm): boolean
    properties: create
    Set to true if a new map should be created

---
flipRails(fr): boolean
    properties: create, query, edit
    If true, flip which curves are the rails of the birail surface.

---
insertBeforeDeformers(ibd): boolean
    properties: create
    Set to true if the new node created should inserted before any deformer nodes.

---
method(m): int
    properties: create, query, edit
    Sets which projection method to use. Valid values are
0: Walk Contours
1: NURBS Projection

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
offset0(o0): linear
    properties: create, query, edit
    Sets the offset on edge 0 of the NURBS surface.

---
offset1(o1): linear
    properties: create, query, edit
    Sets the offset on edge 1 of the NURBS surface.

---
offset2(o2): linear
    properties: create, query, edit
    Sets the offset on edge 2 of the NURBS surface.

---
offset3(o3): linear
    properties: create, query, edit
    Sets the offset on edge 3 of the NURBS surface.

---
reduceShear(rs): float
    properties: create, query, edit
    Sets the 'reduce shear' parameter of the projection.

---
smoothness0(s0): float
    properties: create, query, edit
    Sets the smoothness of edge 0 of the NURBS surface.

---
smoothness1(s1): float
    properties: create, query, edit
    Sets the smoothness of edge 1 of the NURBS surface.

---
smoothness2(s2): float
    properties: create, query, edit
    Sets the smoothness of edge 2 of the NURBS surface.

---
smoothness3(s3): float
    properties: create, query, edit
    Sets the smoothness of edge 3 of the NURBS surface.

---
userDefinedCorners(udc): boolean
    properties: create, query, edit
    If true, the four vertices specified by user will be taken as corners to do the projection.

---
uvSetName(uvs): string
    properties: create
    Name of the UV set to be created

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyContourProjection.html 
    """


def polyCopyUV(flagcaching: boolean, flagconstructionHistory: boolean, flagcreateNewMap: boolean, flagname: string, flagnodeState: int, flaguvSetName: string, flaguvSetNameInput: string, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyCopyUV(
[selectionList]
    , [caching=boolean], [constructionHistory=boolean], [createNewMap=boolean], [name=string], [nodeState=int], [uvSetName=string], [uvSetNameInput=string], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCopyUV is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a poly sphere, with default UVset.
cmds.polySphere()

Create a second UV set
cmds.select( 'pSphere1.f[0:399]', r=True )
cmds.polyProjection( type='Planar', ra=0, isu=1, isv=1, cm=True, uvSetName='newUVs' )

Copy the UVs of the fisrt 200 faces from the new set to the default one
cmds.polyCopyUV( 'pSphere1.f[0:199]', uvi='newUVs', uvs='map1' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createNewMap(cm): boolean
    properties: create
    Set to true if a new map should be created

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
uvSetName(uvs): string
    properties: create
    Name of the UV set to be created

---
uvSetNameInput(uvi): string
    properties: create, query, edit
    Specifies name of the input uv set to
read the UV description from. Default is the current UV set.

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCopyUV.html 
    """


def polyCrease(flagcreateHistory: boolean, flagoperation: uint, flagrelativeValue: float, flagvalue: float, flagvertexValue: float) -> boolean:
    """Synopsis:
---
---
 polyCrease([createHistory=boolean], [operation=uint], [relativeValue=float], [value=float], [vertexValue=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCrease is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

To set a crease value of 0.9 on the selected edges or vertices
cmds.polyCrease( value=0.9 )

---
Return:
---


    boolean: Success or Failure.

Flags:
---


---
createHistory(ch): boolean
    properties: create, query, edit
    For objects that have no construction history, this flag can be used
to force the creation of construction history for creasing.  By default,
history is not created if the object has no history.  Regardless of this
flag, history is always created if the object already has history.

---
operation(op): uint
    properties: create, query, edit
    Operation to perform.  Valid values are:
0: Crease the specified components.
1: Remove the crease values for the specified components.
2: Remove all crease values from the mesh.
Default is 0.

---
relativeValue(rv): float
    properties: create, query, edit
    Specifies a new relative value for all selected vertex and edge components.
This flag can not be used at the same time as either the value or vertexValue
flags.

---
value(v): float
    properties: create, query, edit, multiuse
    Specifies the crease value for the selected edge components.
When specified multiple times, the values are assigned respectively to
the specified edges.

---
vertexValue(vv): float
    properties: create, query, edit, multiuse
    Specifies the crease value for the selected vertex components.
When specified multiple times, the values are assigned respectively to
the specified vertices.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCrease.html 
    """


def polyCreaseCtx(flagcreateSet: string, flagexists: boolean, flagextendSelection: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flagrelative: boolean) -> None:
    """Synopsis:
---
---
 polyCreaseCtx([createSet=string], [exists=boolean], [extendSelection=boolean], [image1=string], [image2=string], [image3=string], [relative=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCreaseCtx is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a poly plane
cmds.polyPlane(w=10, h=10, sx=1, sy=1, n='pPlane1')

Create a new poly crease context, then switch to it
cmds.polyCreaseCtx('polyCreaseCtx1')
cmds.setToolTo('polyCreaseCtx1')

---


Flags:
---


---
createSet(cs): string
    properties: edit
    Creates a set for the selected components.

---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
extendSelection(es): boolean
    properties: create, query, edit
    Enable/disable extending selection to all connected creased components.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
relative(r): boolean
    properties: create, query, edit
    Enable/disable applying value relative to existing crease value.
If disabled, absolute value is applied.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCreaseCtx.html 
    """


def polyCreateFacet(flagconstructionHistory: boolean, flaghole: boolean, flagname: string, flagpoint: tuple[int | tuple[float, ...], ...], flagsubdivision: int, flagtexture: int) -> list[string]:
    """Synopsis:
---
---
 polyCreateFacet([constructionHistory=boolean], [hole=boolean], [name=string], [point=[[, float, float, float, ]]], [subdivision=int], [texture=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCreateFacet is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a triangular facet
cmds.polyCreateFacet( p=[(0.0, 0.0, 0.0), (10.0, 0.0, 0.0), (10.0, 10.0, 0.0)] )

Create a quadrangular facet with two triangular holes inside
Note that, in Python, specifying an empty tuple in the point list marks the
beginning of a hole specification
cmds.polyCreateFacet( p=[(0, 0, 0), (10, 0, 0), (10, 10, 0), (0, 10, 0), (), (4, 2, 0), (5, 4, 0), (6, 2, 0), (), (5, 6, 0), (4, 8, 0), (6, 8, 0)] )
cmds.move( 0, 0, 10, r=True )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
hole(hl): boolean
    properties: create, multiuse
    Add a hole. The following points will define a hole.
Holes can be defined either clockwise or counterclockwise.

Note that this flag is not recommended for use in Python.  When specifying facets
with the point flag in Python, pass in an empty point "()" when you want to
start specifying a hole.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
point(p): [[, float, float, float, ]]
    properties: create, multiuse
    Adds a new point to the face.
Coordinates of points are given in world reference.

The point flag may also be passed with no arguments.  That indicates that the
following points will specify a hole.  Passing the point flag with no
arguments is the same as using the "hole" flag, except that it will work
in Python.

---
subdivision(s): int
    properties: create, query, edit
    This flag specifies the level of subdivision.
Subdivides edges into the given number of edges.
C: Default is 1 (no subdivision).
Q: When queried, this flag returns an int.

---
texture(tx): int
    properties: create, query, edit
    Specifies how the face is mapped.
 0 - None; 1 - Normalize; 2 - Unitize
C: Default is 0 (no mapping).
Q: When queried, this flag returns an int

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCreateFacet.html 
    """


def polyCreateFacetCtx(flagappend: boolean, flagexists: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flagmaximumNumberOfPoints: int, flagplanarConstraint: boolean, flagsubdivision: int, flagtexture: int) -> None:
    """Synopsis:
---
---
 polyCreateFacetCtx([append=boolean], [exists=boolean], [image1=string], [image2=string], [image3=string], [maximumNumberOfPoints=int], [planarConstraint=boolean], [subdivision=int], [texture=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCreateFacetCtx is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a new poly facet create context, set it to add four vertices per new edge, then switch to it
cmds.polyCreateFacetCtx('polyCreateFacetCtx1', s=4)
cmds.setToolTo('polyCreateFacetCtx1')

---


Flags:
---


---
append(ap): boolean
    properties: create, query, edit
    Allows to switch to polyAppendFacetCtx tool

---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
maximumNumberOfPoints(mp): int
    properties: create, query, edit
    Allows the ability to set a upper bound on the number of
points in interactively place before polygon is
created. A value less than 2 will mean that there is no
upper bound.

---
planarConstraint(pc): boolean
    properties: create, query, edit
    allows/avoid new facet to be non-planar.
If on, all new points will be projected onto
current facet plane.

---
subdivision(s): int
    properties: create, query, edit
    Number of subdivisions for each edge.
Default: 1

---
texture(tx): int
    properties: create, query, edit
    What texture mechanism to be applied
0=No textures, 1=Normalized, Undistorted textures
2=Unitized textures
Default: 0

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCreateFacetCtx.html 
    """


def polyCube(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: int, flagdepth: linear, flagheight: linear, flagname: string, flagnodeState: int, flagobject: boolean, flagsubdivisionsDepth: int, flagsubdivisionsHeight: int, flagsubdivisionsWidth: int, flagsubdivisionsX: int, flagsubdivisionsY: int, flagsubdivisionsZ: int, flagtexture: int, flagwidth: linear) -> list[string]:
    """Synopsis:
---
---
 polyCube([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=int], [depth=linear], [height=linear], [name=string], [nodeState=int], [object=boolean], [subdivisionsDepth=int], [subdivisionsHeight=int], [subdivisionsWidth=int], [subdivisionsX=int], [subdivisionsY=int], [subdivisionsZ=int], [texture=int], [width=linear])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCube is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.polyCube( sx=10, sy=15, sz=5, h=20 )
---
result is a 20 units height rectangular box
---
with 10 subdivisions along X, 15 along Y and 20 along Z.

cmds.polyCube( sx=5, sy=5, sz=5 )
---
result has 5 subdivisions along all directions, default size

query the width of a cube
w = cmds.polyCube( 'polyCube1', q=True, w=True )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the cube.
Q: When queried, this flag returns a float[3].

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createUVs(cuv): int
    properties: create, query, edit
    Create UVs or not.
0: No UVs
1: No Normalization
2: Normalize Each Face Separately
3: Normalize Collectively
4: Normalize and Preserve Aspect Ratio
Default: 3

---
depth(d): linear
    properties: create, query, edit
    Depth of the cube.
Default: 1.0

---
height(h): linear
    properties: create, query, edit
    Height of the cube.
Default: 1.0

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
subdivisionsDepth(sd): int
    properties: create, query, edit
    Subdivisions along the depth of the cube.
Default: 1

---
subdivisionsHeight(sh): int
    properties: create, query, edit
    Subdivisions along the height of the cube.
Default: 1

---
subdivisionsWidth(sw): int
    properties: create, query, edit
    Subdivisions along the width of the cube.
Default: 1

---
subdivisionsX(sx): int
    properties: create, query, edit
    This specifies the number of subdivisions in the X direction for the cube.
C: Default is 1.
Q: When queried, this flag returns an int.

---
subdivisionsY(sy): int
    properties: create, query, edit
    This flag specifies the number of subdivisions in the Y direction for the cube.
C: Default is 1.
Q: When queried, this flag returns an int.

---
subdivisionsZ(sz): int
    properties: create, query, edit
    This flag specifies the number of subdivisions in the Z direction for the cube.
C: Default is 1.
Q: When queried, this flag returns an int.

---
texture(tx): int
    properties: create, query, edit
    What texture mechanism to be applied
0=No textures; 1=Object; 2=Faces
Default: 1

---
width(w): linear
    properties: create, query, edit
    Width of the cube.
Default: 1.0

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCube.html 
    """


def polyCut(flagcaching: boolean, flagconstructionHistory: boolean, flagcutPlaneCenter: tuple[linear, linear, linear], flagcutPlaneCenterX: linear, flagcutPlaneCenterY: linear, flagcutPlaneCenterZ: linear, flagcutPlaneHeight: linear, flagcutPlaneRotate: tuple[angle, angle, angle], flagcutPlaneRotateX: angle, flagcutPlaneRotateY: angle, flagcutPlaneRotateZ: angle, flagcutPlaneSize: tuple[linear, linear], flagcutPlaneWidth: linear, flagcuttingDirection: string, flagdeleteFaces: boolean, flagextractFaces: boolean, flagextractOffset: tuple[linear, linear, linear], flagextractOffsetX: linear, flagextractOffsetY: linear, flagextractOffsetZ: linear, flagname: string, flagnodeState: int, flagonObject: boolean, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyCut([caching=boolean], [constructionHistory=boolean], [cutPlaneCenter=[linear, linear, linear]], [cutPlaneCenterX=linear], [cutPlaneCenterY=linear], [cutPlaneCenterZ=linear], [cutPlaneHeight=linear], [cutPlaneRotate=[angle, angle, angle]], [cutPlaneRotateX=angle], [cutPlaneRotateY=angle], [cutPlaneRotateZ=angle], [cutPlaneSize=[linear, linear]], [cutPlaneWidth=linear], [cuttingDirection=string], [deleteFaces=boolean], [extractFaces=boolean], [extractOffset=[linear, linear, linear]], [extractOffsetX=linear], [extractOffsetY=linear], [extractOffsetZ=linear], [name=string], [nodeState=int], [onObject=boolean], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCut is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Introduce new edges at the middle of a cylinder
---

cmds.polyCylinder( r=1, h=2, sx=20, sy=1, sz=1, ax=(0, 1, 0), cuv=1, ch=1, name='pCylA' )
cmds.polyCut( 'pCylA.f[0:59]', cd='Y', ch=1 )

Delete the bottom half of the cylinder
---

cmds.select( cl=True )
cmds.polyCylinder( r=1, h=2, sx=20, sy=1, sz=1, ax=(0, 1, 0), cuv=1, ch=1, name='pCylB' )
cmds.move( 3, 0, 0, r=True )
cmds.polyCut( 'pCylB.f[0:59]', cd='Y', df=1, ch=1 )
cmds.select( cl=True )


Split the bottom half of the cylinder
---

cmds.select( cl=True )
cmds.polyCylinder( r=1, h=2, sx=20, sy=1, sz=1, ax=(0, 1, 0), cuv=1, ch=1, name='pCylC' )
cmds.move( 6, 0, 0, r=True )
cmds.polyCut( 'pCylC.f[0:59]', cd='Y', ef=1, ch=1 )

select one of the cylinders, and select the polyCut node from the
channel box, and enter the showManipulator Tool, on the Toolbar.
You can interactively place the cutting plane, and the result of
cut operation will adjust accordingly.

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
cutPlaneCenter(pc): [linear, linear, linear]
    properties: create, query, edit
    The position of the cutting plane.
Default: 0.0, 0.0, 0.0

---
cutPlaneCenterX(pcx): linear
    properties: create, query, edit
    Cutting plane center X coord.

---
cutPlaneCenterY(pcy): linear
    properties: create, query, edit
    Cutting plane center Y coord.

---
cutPlaneCenterZ(pcz): linear
    properties: create, query, edit
    Cutting plane center Z coord.

---
cutPlaneHeight(ph): linear
    properties: create, query, edit
    The height of the cutting plane

---
cutPlaneRotate(ro): [angle, angle, angle]
    properties: create, query, edit
    The orientation of the cutting plane.
Default: 0.0, 0.0, 0.0

---
cutPlaneRotateX(rx): angle
    properties: create, query, edit
    cutting plane X rotate angle.

---
cutPlaneRotateY(ry): angle
    properties: create, query, edit
    cutting plane Y rotate angle.

---
cutPlaneRotateZ(rz): angle
    properties: create, query, edit
    cutting plane Z rotate angle.

---
cutPlaneSize(ps): [linear, linear]
    properties: create, query, edit
    The width and the height of the cutting plane
Default: 1.0, 1.0

---
cutPlaneWidth(pw): linear
    properties: create, query, edit
    The width of the cutting plane

---
cuttingDirection(cd): string
    properties: create
    This flag specifies the direction of the cutting plane.
Valid values are "x", "y", "z"
A value of "x" will cut the object along the YZ plane
cutting through the center of the bounding box.
A value of "y" will cut the object along the ZX plane
cutting through the center of the bounding box.
A value of "z" will cut the object along the XY plane
cutting through the center of the bounding box.

---
deleteFaces(df): boolean
    properties: create, query, edit
    whether to delete the one-half of the cut-faces
of the poly.  If true, they are deleted.
Default: false

---
extractFaces(ef): boolean
    properties: create, query, edit
    whether to extract the cut-faces of the poly
into a separate shell.  If true, they are extracted.
Default: false

---
extractOffset(eo): [linear, linear, linear]
    properties: create, query, edit
    The displacement offset of the cut faces.
Default: 0.5, 0.5, 0.5

---
extractOffsetX(eox): linear
    properties: create, query, edit
    The X-displacement offset of the cut faces.

---
extractOffsetY(eoy): linear
    properties: create, query, edit
    The Y-displacement offset of the cut faces.

---
extractOffsetZ(eoz): linear
    properties: create, query, edit
    The Z-displacement offset of the cut faces.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
onObject(oo): boolean
    properties: create, query, edit
    whether to act on the entire polyObject
or its selected face components
Default: true

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCut.html 
    """


def polyCutCtx(flagdeleteFaces: boolean, flagexists: boolean, flagextractFaces: boolean, flagextractOffset: tuple[linear, linear, linear], flagimage1: string, flagimage2: string, flagimage3: string) -> None:
    """Synopsis:
---
---
 polyCutCtx([deleteFaces=boolean], [exists=boolean], [extractFaces=boolean], [extractOffset=[linear, linear, linear]], [image1=string], [image2=string], [image3=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCutCtx is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a poly plane
cmds.polyPlane(w=10, h=10, sx=1, sy=1, n='pPlane1')

Create a new cut facets context, then switch to it
cmds.polyCutCtx('polyCutCtx1')
cmds.setToolTo('polyCutCtx1')

---


Flags:
---


---
deleteFaces(df): boolean
    properties: create, query, edit
    whether to delete the one-half of the cut-faces
of the poly.  If true, they are deleted.
Default: false

---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
extractFaces(ef): boolean
    properties: create, query, edit
    whether to extract the cut-faces of the poly
into a separate shell.  If true, they are extracted.
Default: false

---
extractOffset(eo): [linear, linear, linear]
    properties: create, query, edit
    The displacement offset of the cut faces.
Default: 0.5, 0.5, 0.5

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCutCtx.html 
    """


def polyCutUVCtx(flagloopSpeed: int, flagmapBordersColor: tuple[float, float, float], flagshowCheckerMap: boolean, flagshowTextureBorders: boolean, flagshowUVShellColoring: boolean, flagsteadyStroke: boolean, flagsteadyStrokeDistance: float, flagsymmetry: int) -> boolean | float:
    """Synopsis:
---
---
 polyCutUVCtx(
contextName
    , [loopSpeed=int], [mapBordersColor=[float, float, float]], [showCheckerMap=boolean], [showTextureBorders=boolean], [showUVShellColoring=boolean], [steadyStroke=boolean], [steadyStrokeDistance=float], [symmetry=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCutUVCtx is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a new cut facets context, then switch to it
cmds.polyCutUVCtx('polyCutUVCtx1')
cmds.setToolTo('polyCutUVCtx1')

---
Return:
---


    boolean: Whether steady stroke is on or not, when querying the steadyStroke flag.
    float: The distance for a steady stroke, when querying the steadyStrokeDistance flag.

Flags:
---


---
loopSpeed(ls): int
    properties: query, edit
    Edit the speed of loop cutting.

---
mapBordersColor(mbc): [float, float, float]
    properties: query, edit
    Color of UV map border edges in 3d view.

---
showCheckerMap(scm): boolean
    properties: query, edit
    Display checker map.

---
showTextureBorders(stb): boolean
    properties: query, edit
    Display texture border edges.

---
showUVShellColoring(ssc): boolean
    properties: query, edit
    Turn on UV shell coloring or not.

---
steadyStroke(ss): boolean
    properties: query, edit
    Turn on steady stroke or not.

---
steadyStrokeDistance(ssd): float
    properties: query, edit
    The distance for steady stroke.

---
symmetry(sym): int
    properties: query, edit
    Symmetric modeling.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCutUVCtx.html 
    """


def polyCylinder(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: int, flagheight: linear, flagname: string, flagnodeState: int, flagobject: boolean, flagradius: linear, flagroundCap: boolean, flagsubdivisionsAxis: int, flagsubdivisionsCaps: int, flagsubdivisionsHeight: int, flagsubdivisionsX: int, flagsubdivisionsY: int, flagsubdivisionsZ: int, flagtexture: int) -> list[string]:
    """Synopsis:
---
---
 polyCylinder([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=int], [height=linear], [name=string], [nodeState=int], [object=boolean], [radius=linear], [roundCap=boolean], [subdivisionsAxis=int], [subdivisionsCaps=int], [subdivisionsHeight=int], [subdivisionsX=int], [subdivisionsY=int], [subdivisionsZ=int], [texture=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCylinder is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a rectangle, with 10 subdivisions in the X direction,
15 subdivisions in the Y direction and 20 subdivisions in the Z direction,
the height of the cylinder is 20.
cmds.polyCylinder( sx=10, sy=15, sz=5, h=20)

Create a cylinder, called "myCylinder", on each direction there are 5 subdivisions.
cmds.polyCylinder(n='myCylinder', sx=5, sy=5, sz=5)

Query the radius of "myCylinder"
r = cmds.polyCylinder( 'myCylinder', q=True, r=True )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the cylinder.
Q: When queried, this flag returns a float[3].

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createUVs(cuv): int
    properties: create, query, edit
    Create UVs or not.
0: No UVs
1: No Normalization
2: Normalize
3: Normalize and Preserve Aspect Ratio
Default: 2

---
height(h): linear
    properties: create, query, edit
    Height of the cylinder.
Default: 2.0

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
radius(r): linear
    properties: create, query, edit
    Radius of the cylinder.
Default: 1.0

---
roundCap(rcp): boolean
    properties: create, query, edit
    To indicate whether we need a round cap
Default: false

---
subdivisionsAxis(sa): int
    properties: create, query, edit
    Subdivisions around the axis.
Default: 20

---
subdivisionsCaps(sc): int
    properties: create, query, edit
    Subdivisions on the caps
Default: 0

---
subdivisionsHeight(sh): int
    properties: create, query, edit
    Subdivisions along the height.
Default: 1

---
subdivisionsX(sx): int
    properties: create, query, edit
    This specifies the number of subdivisions in the X direction for the cylinder.
C: Default is 20.
Q: When queried, this flag returns an int.

---
subdivisionsY(sy): int
    properties: create, query, edit
    This flag specifies the number of subdivisions in the Y direction for the cylinder.
C: Default is 1.
Q: When queried, this flag returns an int.

---
subdivisionsZ(sz): int
    properties: create, query, edit
    This flag specifies the number of subdivisions in the Z direction for the cylinder.
C: Default is 1.
Q: When queried, this flag returns an int.

---
texture(tx): int
    properties: create, query, edit
    What texture mechanism to be applied
0=No textures, 1=Object, 2=Faces
Default: 2

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCylinder.html 
    """


def polyCylindricalProjection(flagcaching: boolean, flagconstructionHistory: boolean, flagcreateNewMap: boolean, flagimageCenter: tuple[float, float], flagimageCenterX: float, flagimageCenterY: float, flagimageScale: tuple[float, float], flagimageScaleU: float, flagimageScaleV: float, flaginsertBeforeDeformers: boolean, flagkeepImageRatio: boolean, flagmapDirection: string, flagname: string, flagnodeState: int, flagperInstance: boolean, flagprojectionCenter: tuple[linear, linear, linear], flagprojectionCenterX: linear, flagprojectionCenterY: linear, flagprojectionCenterZ: linear, flagprojectionHeight: linear, flagprojectionHorizontalSweep: linear, flagprojectionScale: tuple[linear, linear], flagprojectionScaleU: linear, flagprojectionScaleV: linear, flagradius: linear, flagrotationAngle: angle, flagseamCorrect: boolean, flagsmartFit: boolean, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyCylindricalProjection([caching=boolean], [constructionHistory=boolean], [createNewMap=boolean], [imageCenter=[float, float]], [imageCenterX=float], [imageCenterY=float], [imageScale=[float, float]], [imageScaleU=float], [imageScaleV=float], [insertBeforeDeformers=boolean], [keepImageRatio=boolean], [mapDirection=string], [name=string], [nodeState=int], [perInstance=boolean], [projectionCenter=[linear, linear, linear]], [projectionCenterX=linear], [projectionCenterY=linear], [projectionCenterZ=linear], [projectionHeight=linear], [projectionHorizontalSweep=linear], [projectionScale=[linear, linear]], [projectionScaleU=linear], [projectionScaleV=linear], [radius=linear], [rotationAngle=angle], [seamCorrect=boolean], [smartFit=boolean], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyCylindricalProjection is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a sphere with default UVs.
cmds.polySphere( n='sphere', r=10 )

Create a lambert node.
cmds.shadingNode( 'lambert', n='myLambert', asShader=True )
cmds.sets( renderable=True, noSurfaceShader=True, empty=True, name='myLambertSG' )
cmds.connectAttr( 'myLambert.outColor', 'myLambertSG.surfaceShader', f=True )

Create a texture checker.
cmds.shadingNode( 'checker', asTexture=True )
cmds.shadingNode( 'place2dTexture', asUtility=True )
cmds.connectAttr( 'place2dTexture1.outUV', 'checker1.uv' )

Assign the texture the the lambert node.
cmds.connectAttr( 'checker1.outColor', 'myLambert.color', f=True )

Set the textured display mode.
currentPanel = cmds.getPanel(withFocus= True)
if currentPanel != '':
        cmds.modelEditor(currentPanel, edit=True, da='smoothShaded', displayTextures=True, dl='default')

Assign the lambert shader to all faces of the sphere.
cmds.sets('sphere.f[0:399]', edit=True, forceElement= 'myLambertSG' )

Replace default UVs on the top of the sphere :
Rotates the map of 90 degrees, reduces its U aperture to 36 degrees, and its V scale to 0.1
cmds.polyCylindricalProjection( 'sphere.f[180:359]', 'sphere.f[380:399]', ra=90.0, pc=(0, 0, 0), psu=36, isv=0.1 )

Set the wireframe display mode.
currentPanel = cmds.getPanel(withFocus= True)
if currentPanel != '':
        cmds.modelEditor(currentPanel, edit=True, da='wireframe')

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createNewMap(cm): boolean
    properties: create, query
    This flag when set true will create a new map with
a the name passed in, if the map does not already exist.

---
imageCenter(ic): [float, float]
    properties: create, query, edit
    The center point of the 2D model layout.
Default: 0.5, 0.5

---
imageCenterX(icx): float
    properties: create, query, edit
    Image center X coord.

---
imageCenterY(icy): float
    properties: create, query, edit
    Image center Y coord.

---
imageScale(imageScale): [float, float]
    properties: create, query, edit
    Specifies the UV scale : Enlarges or reduces the 2D version of the
model in U or V space relative to the 2D centerpoint.
Default: 1.0, 1.0

---
imageScaleU(isu): float
    properties: create, query, edit
    Specifies the UV scale : Enlarges or reduces the 2D version of the
model in U or V space relative to the 2D centerpoint.

---
imageScaleV(isv): float
    properties: create, query, edit
    The V scale : Enlarges or reduces the 2D version of the model
in V space relative to the 2D centerpoint.

---
insertBeforeDeformers(ibd): boolean
    properties: create
    This flag specifies if the projection node should be inserted before
or after deformer nodes already applied to the shape. Inserting the
projection after the deformer leads to texture swimming during
animation and is most often undesirable.
C: Default is on.

---
keepImageRatio(kir): boolean
    properties: create
    True means keep any image ratio

---
mapDirection(md): string
    properties: create
    This flag specifies the mapping direction.
'x', 'y' and 'z' projects the map along the corresponding axis.
'c' projects along the current camera viewing direction.
'p' does perspective projection if current camera is perspective.
'b' projects along the best plane fitting the objects selected.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
perInstance(pi): boolean
    properties: create
    True if the new map is per-instance, otherwise it is shared.

---
projectionCenter(pc): [linear, linear, linear]
    properties: create, query, edit
    The origin point from which the map is projected.
Default: 0.0, 0.0, 0.0

---
projectionCenterX(pcx): linear
    properties: create, query, edit
    Projection center X coord.

---
projectionCenterY(pcy): linear
    properties: create, query, edit
    Projection center Y coord.

---
projectionCenterZ(pcz): linear
    properties: create, query, edit
    Projection center Z coord.

---
projectionHeight(ph): linear
    properties: create, query, edit
    The height of the map relative to the 3D projection axis

---
projectionHorizontalSweep(phs): linear
    properties: create, query, edit
    The angle swept by the 3D projection axis

---
projectionScale(ps): [linear, linear]
    properties: create, query, edit
    The width and the height of the map relative to the 3D projection axis.
Default: 180.0, 1.0

---
projectionScaleU(psu): linear
    properties: create, query, edit
    The width of the map relative to the 3D projection axis.

---
projectionScaleV(psv): linear
    properties: create, query, edit
    The height of the map relative to the 3D projection axis.

---
radius(r): linear
    properties: create, query, edit
    Used by the UI : Manipulator.
Default: 10.0

---
rotationAngle(ra): angle
    properties: create, query, edit
    The for the rotation.
When the angle is positive, then the map rotates counterclockwise on
the mapped model, whereas when it is negative then the map rotates
lockwise on the mapped model.
Default: 0.0

---
seamCorrect(sc): boolean
    properties: create, query, edit
    Used to indicate fixing UV seams.
Default: false

---
smartFit(sf): boolean
    properties: create
    True means use the smart fit algorithm

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyCylindricalProjection.html 
    """


def polyDelEdge(flagcaching: boolean, flagcleanVertices: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyDelEdge([caching=boolean], [cleanVertices=boolean], [constructionHistory=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyDelEdge is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Without cleanup
cmds.polyPlane( n='plg1', w=10, h=10 )
cmds.move( -6, 0, 0 )
cmds.select( 'plg1.e[26]', 'plg1.e[28]', 'plg1.e[30]', 'plg1.e[32]', 'plg1.e[34]', 'plg1.e[36]', 'plg1.e[38]', 'plg1.e[47]', 'plg1.e[49]', 'plg1.e[51]', 'plg1.e[53]', 'plg1.e[55]', 'plg1.e[57]', 'plg1.e[59]' )
cmds.polyDelEdge( cv=False )

With cleanup
cmds.polyPlane( n='plg2', w=10, h=10 )
cmds.move( 6, 0, 0 )
cmds.select( 'plg2.e[26]', 'plg2.e[28]', 'plg2.e[30]', 'plg2.e[32]', 'plg2.e[34]', 'plg2.e[36]', 'plg2.e[38]', 'plg2.e[47]', 'plg2.e[49]', 'plg2.e[51]', 'plg2.e[53]', 'plg2.e[55]', 'plg2.e[57]', 'plg2.e[59]' )
cmds.polyDelEdge( cv=True )

cmds.select( 'plg1', 'plg2' )
cmds.polyOptions( ao=True, dv=True )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
cleanVertices(cv): boolean
    properties: create, query, edit
    If on : delete resulting winged vertices.
C: Default is "off".
Q: When queried, this flag returns an int.

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyDelEdge.html 
    """


def polyDelFacet(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyDelFacet([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyDelFacet is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polySphere( n='plg', sx=10, sy=20, r=10 )
cmds.polyDelFacet( 'plg.f[115]', 'plg.f[125]', 'plg.f[117]', 'plg.f[127]', 'plg.f[55:57]', 'plg.f[65]', 'plg.f[67]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyDelFacet.html 
    """


def polyDelVertex(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyDelVertex([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyDelVertex is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polyPlane( n='plg' )
cmds.select( 'plg.vtx[59:61]' )
These vertices are not winged, so they can not be deleted
cmds.polyDelVertex()

cmds.select( 'plg.e[93]', 'plg.e[95]', 'plg.e[97]', 'plg.e[114]', 'plg.e[116]', 'plg.e[118]' )
cmds.delete()
cmds.select( 'plg.vtx[59:61]' )
Now they are winged, as they are only connected to two edges.
cmds.polyDelVertex()

Corners are winged, so they can be deleted
cmds.select( 'plg.vtx[0]', 'plg.vtx[10]', 'plg.vtx[107]', 'plg.vtx[117]' )
cmds.polyDelVertex()

cmds.select( 'plg' )
cmds.polyOptions( ao=True, dv=True )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyDelVertex.html 
    """


def polyDuplicateAndConnect(flagremoveOriginalFromShaders: boolean, flagrenameChildren: boolean) -> None:
    """Synopsis:
---
---
 polyDuplicateAndConnect(
object
    , [removeOriginalFromShaders=boolean], [renameChildren=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyDuplicateAndConnect is undoable, NOT queryable, and NOT editable.
The command will fail if no objects are selected or sent as
argument or if the object sent as argument is not a polygonal
object.





Example:
---
import maya.cmds as cmds

cmds.polyDuplicateAndConnect( 'pPlane1' )

---


Flags:
---


---
removeOriginalFromShaders(ros): boolean
    properties: create
    Used to specify if the original object should be removed from
the shaders (shadingGroups) that it is a member of. The shader
associations will get transferred to the duplicated object, before
they are removed from the original. If this flag is specified
then the original polygonal object will be drawn in wireframe
mode even if all objects are being drawn in shaded mode.

---
renameChildren(rc): boolean
    properties: create
    rename the children nodes of the hierarchy, to make them unique.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyDuplicateAndConnect.html 
    """


def polyDuplicateEdge(flagadjustEdgeFlow: float, flagcaching: boolean, flagconstructionHistory: boolean, flagdeleteEdge: boolean, flagendVertexOffset: float, flaginsertWithEdgeFlow: boolean, flagname: string, flagnodeState: int, flagoffset: float, flagsmoothingAngle: angle, flagsplitType: int, flagstartVertexOffset: float) -> string:
    """Synopsis:
---
---
 polyDuplicateEdge([adjustEdgeFlow=float], [caching=boolean], [constructionHistory=boolean], [deleteEdge=boolean], [endVertexOffset=float], [insertWithEdgeFlow=boolean], [name=string], [nodeState=int], [offset=float], [smoothingAngle=angle], [splitType=int], [startVertexOffset=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyDuplicateEdge is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.polyTorus()
cmds.polyDuplicateEdge( 'pTorus1.e[121:126]', of=0.5 )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
adjustEdgeFlow(aef): float
    properties: create, query, edit
    The weight value of the edge vertices to be positioned.

---
deleteEdge(de): boolean
    properties: create, query, edit
    When true, the end edges are deleted so the end triangles are converted to quads.

---
endVertexOffset(evo): float
    properties: create, query, edit
    Weight value controlling the offset of the end vertex of the edgeloop.

---
insertWithEdgeFlow(ief): boolean
    properties: create, query, edit
    True to enable edge flow. Otherwise, the edge flow is disabled.

---
offset(of): float
    properties: create
    Weight value controlling the relative positioning of the new
edges. The range of values is [0.0, 1.0].

---
smoothingAngle(sma): angle
    properties: create, query, edit
    Angle below which new edges will be smoothed

---
splitType(stp): int
    properties: create, query, edit
    Format: 0 - Absolute, 1 - Relative, 2 - Multi

---
startVertexOffset(svo): float
    properties: create, query, edit
    Weight value controlling the offset of the start vertex of the edgeloop.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyDuplicateEdge.html 
    """


def polyEditEdgeFlow(flagadjustEdgeFlow: float, flagcaching: boolean, flagconstructionHistory: boolean, flagedgeFlow: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyEditEdgeFlow([adjustEdgeFlow=float], [caching=boolean], [constructionHistory=boolean], [edgeFlow=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyEditEdgeFlow is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a sphere.
cmds.polySphere( n='plg', r=5 )

cmds.select( 'plg.e[200:219]' )
Flow selected edges by default
cmds.polyEditEdgeFlow()

Flow selected edge (convex, 20)
cmds.polyEditEdgeFlow( 'plg.e[200:219]', adjustEdgeFlow = 20 )

---
Return:
---


    string: The node name.

Flags:
---


---
adjustEdgeFlow(aef): float
    properties: create
    The weight value of the edge vertices to be positioned.
<0: Concave
0:  Middle point
1:  Surface continuity
>1: Convex
Default is 1.0

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
edgeFlow(ef): boolean
    properties: create
    True to enable edge flow. Otherwise, the edge flow is disabled.
Default is true.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyEditEdgeFlow.html 
    """


def polyEditUV(flagangle: float, flagpivotU: float, flagpivotV: float, flagrelative: boolean, flagrotateRatio: float, flagrotation: boolean, flagscale: boolean, flagscaleU: float, flagscaleV: float, flaguValue: float, flaguvSetName: string, flagvValue: float) -> boolean:
    """Synopsis:
---
---
 polyEditUV([angle=float], [pivotU=float], [pivotV=float], [relative=boolean], [rotateRatio=float], [rotation=boolean], [scale=boolean], [scaleU=float], [scaleV=float], [uValue=float], [uvSetName=string], [vValue=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyEditUV is undoable, queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

To query the u and v values of selected uvs:
cmds.polyEditUV( query=True )

To tweak the u and v values of selected uvs:
cmds.polyEditUV( relative=True, uValue=0.05925926, vValue=0.05555556 )

To set absolute values for u and v values of selected uvs:
cmds.polyEditUV( relative=False, uValue=0.556, vValue=0.56 )

To rotate selected uv points about a pivot:
cmds.polyEditUV( pivotU=0.5, pivotV=0.5, angle=-15 )

To scale selected uv points about a pivot:
cmds.polyEditUV( pivotU=0.5, pivotV=0.5, scaleU=-0.06, scaleV=-0.06 )

---
Return:
---


    boolean: Success or Failure.

Flags:
---


---
angle(a): float
    properties: create, query
    Specifies the angle value (in degrees) that the uv values are to be rotated
by.

---
pivotU(pu): float
    properties: create, query
    Specifies the pivot value, in the u direction, about which the scale or
rotate is to be performed.

---
pivotV(pv): float
    properties: create, query
    Specifies the pivot value, in the v direction, about which the scale or
rotate is to be performed.

---
relative(r): boolean
    properties: create, query
    Specifies whether this command is editing the values relative to the currently
existing values. Default is true;

---
rotateRatio(rr): float
    properties: create, query
    Specifies the ratio value that the uv values are to be rotated by
Default is 1.0

---
rotation(rot): boolean
    properties: create, query
    Specifies whether this command is editing the values with rotation values

---
scale(s): boolean
    properties: create, query
    Specifies whether this command is editing the values with scale values

---
scaleU(su): float
    properties: create, query
    Specifies the scale value in the u direction.

---
scaleV(sv): float
    properties: create, query
    Specifies the scale value in the v direction.

---
uValue(u): float
    properties: create, query
    Specifies the value, in the u direction - absolute if relative flag is false..

---
uvSetName(uvs): string
    properties: create, query
    Specifies the name of the uv set to edit uvs on. If not specified
will use the current uv set if it exists.

---
vValue(v): float
    properties: create, query
    Specifies the value, in the v direction - absolute if relative flag is false..

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyEditUV.html 
    """


def polyEditUVShell(flagangle: float, flagpivotU: float, flagpivotV: float, flagrelative: boolean, flagrotateRatio: float, flagrotation: boolean, flagscale: boolean, flagscaleU: float, flagscaleV: float, flaguValue: float, flaguvSetName: string, flagvValue: float) -> boolean:
    """Synopsis:
---
---
 polyEditUVShell([angle=float], [pivotU=float], [pivotV=float], [relative=boolean], [rotateRatio=float], [rotation=boolean], [scale=boolean], [scaleU=float], [scaleV=float], [uValue=float], [uvSetName=string], [vValue=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyEditUVShell is undoable, queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

To query the u and v values of selected uvs:
cmds.polyEditUVShell( query=True )

To tweak the u and v values of selected uvs:
cmds.polyEditUVShell( relative=True, uValue=0.05925926, vValue=0.05555556 )

To rotate selected uv points about a pivot:
cmds.polyEditUVShell( pivotU=0.5, pivotV=0.5, angle=-15 )

---
Return:
---


    boolean: Success or Failure.

Flags:
---


---
angle(a): float
    properties: create, query
    Specifies the angle value (in degrees) that the uv values are to be rotated
by.

---
pivotU(pu): float
    properties: create, query
    Specifies the pivot value, in the u direction, about which the scale or
rotate is to be performed.

---
pivotV(pv): float
    properties: create, query
    Specifies the pivot value, in the v direction, about which the scale or
rotate is to be performed.

---
relative(r): boolean
    properties: create, query
    Specifies whether this command is editing the values relative to the currently
existing values. Default is true;

---
rotateRatio(rr): float
    properties: create, query
    Specifies the ratio value that the uv values are to be rotated by
Default is 1.0

---
rotation(rot): boolean
    properties: create, query
    Specifies whether this command is editing the values with rotation values

---
scale(s): boolean
    properties: create, query
    Specifies whether this command is editing the values with scale values

---
scaleU(su): float
    properties: create, query
    Specifies the scale value in the u direction.

---
scaleV(sv): float
    properties: create, query
    Specifies the scale value in the v direction.

---
uValue(u): float
    properties: create, query
    Specifies the value, in the u direction - absolute if relative flag is false..

---
uvSetName(uvs): string
    properties: create, query
    Specifies the name of the uv set to edit uvs on. If not specified
will use the current uv set if it exists.

---
vValue(v): float
    properties: create, query
    Specifies the value, in the v direction - absolute if relative flag is false..

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyEditUVShell.html 
    """


def polyEvaluate(flagaccurateEvaluation: boolean, flagactiveShells: boolean, flagactiveUVShells: boolean, flagarea: boolean, flagboundingBox: boolean, flagboundingBox2d: boolean, flagboundingBoxComponent: boolean, flagboundingBoxComponent2d: boolean, flagdisplayStats: boolean, flagedge: boolean, flagedgeComponent: boolean, flagface: boolean, flagfaceArea: boolean, flagfaceComponent: boolean, flagformat: boolean, flagshell: boolean, flagtriangle: boolean, flagtriangleComponent: boolean, flaguvArea: boolean, flaguvComponent: boolean, flaguvEdgePairs: boolean, flaguvFaceArea: boolean, flaguvSetName: string, flaguvShell: boolean, flaguvShellIds: boolean, flaguvcoord: boolean, flaguvsInShell: int, flagvertex: boolean, flagvertexComponent: boolean, flagworldArea: boolean, flagworldFaceArea: boolean) -> Any:
    """Synopsis:
---
---
 polyEvaluate(
[poly poly...]
    , [accurateEvaluation=boolean], [activeShells=boolean], [activeUVShells=boolean], [area=boolean], [boundingBox=boolean], [boundingBox2d=boolean], [boundingBoxComponent=boolean], [boundingBoxComponent2d=boolean], [displayStats=boolean], [edge=boolean], [edgeComponent=boolean], [face=boolean], [faceArea=boolean], [faceComponent=boolean], [format=boolean], [shell=boolean], [triangle=boolean], [triangleComponent=boolean], [uvArea=boolean], [uvComponent=boolean], [uvEdgePairs=boolean], [uvFaceArea=boolean], [uvSetName=string], [uvShell=boolean], [uvShellIds=boolean], [uvcoord=boolean], [uvsInShell=int], [vertex=boolean], [vertexComponent=boolean], [worldArea=boolean], [worldFaceArea=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyEvaluate is undoable, NOT queryable, and NOT editable.
In MEL, the values are returned in the same order as the flags are set.
Under Python, there is no concept of argument ordering, so the items are
returned in a dictionary keyed by the name of the flag.  In Python, if only
one item is requested, then it will not be returned in a dictionary.
For user convenience, if no flag is set, then all values are echoed.

All flags (except -fmt/format) are in fact query-flags. For
user convenience, the -q flag may be ommitted.

Some comments for non-formatted output :

3d bounding boxes are returned as 3 couples of floats,
2d ones as 2 couples of floats.

if a bounding box is queried and cannot be computed (for example
the component bounding box when no component is selected, or 2d bounding box for
and unmapped object) 0 is returned for each array element, so that
indices in the output array remain consistent.

int values (queried by topological flags) cannot be
mixed with float values (queried by bounding box flags).
Thus if no flag is set, only int values are returned.





Example:
---
import maya.cmds as cmds

cmds.polyPlane( n='plg', sx=4, sy=4, w=5, h=5 )
cmds.select( 'plg.f[2]', 'plg.f[4]' )

query the number of faces
cmds.polyEvaluate( f=True )
Result: 16

query the number of triangles
cmds.polyEvaluate( t=True )
Result: 32

query the number of selected faces
cmds.polyEvaluate( faceComponent=True )
Result: 2

query the number of vertices and faces
cmds.polyEvaluate( v=True, f=True )
Result: {'vertex': 25, 'face': 16}

formatted query of the number of vertices and faces
cmds.polyEvaluate( v=True, f=True, fmt=True )
Result: "face=16 vertex=25"

query all
cmds.polyEvaluate()
Result: {'edge': 40, 'edgeComponent': 0, 'face': 16, 'faceComponent': 2, 'shell': 1, 'triangle': 32, 'triangleComponent': 0, 'uvComponent': 0, 'uvShell': 1, 'uvcoord': 25, 'vertex': 25,'vertexComponent': 0}

---
formatted query of all information
cmds.polyEvaluate( fmt=True )
Result: vertex=25 edge=40 face=16 uvcoord=25 triangle=32 shell=1 uvShell=1
   vertexComponent=0 edgeComponent=0 faceComponent=2 uvComponent=0
   triangleComponent=4 activeShells= 0 activeUVShells= 0 uvShellIds= 0 0
   faceArea= 1.5625 1.5625 worldFaceArea= 1.5625 1.5625 uvFaceArea= 0.0625 0.0625
   boundingBox= X[-2.50,2.50] Y[-0.00,0.00] Z[-2.50,2.50]
   boundingBoxComponent= X[-2.50,1.25] Y[-0.00,0.00] Z[0.00,2.50]
   boundingBox2d= U[0.00,1.00] V[0.00,1.00]
   boundingBoxComponent2d= U[0.00,0.75] V[0.00,0.50]
   area=25.00 worldArea=25.00 uvArea=1.00

accurate bounding box evaluation
cmds.polyCylinder( r=1, h=2, sx=20, sy=1, sz=1, ax=(0, 1, 0), tx=1, ch=1 )
Result: pCylinder1 polyCylinder1 ---

cmds.rotate( 38.340875, 0, 0, r=True, os=True )
cmds.rotate( 0, 0, -36.177835, r=True, os=True )

cmds.polyEvaluate( b=True )
Result: ((-1.3974823703620598, 1.39748217791327), (-1.7164316223605844, -1.7164316223605844), (-1.6512467204212007, 1.6512465272260637)) ---

cmds.polyEvaluate( b=True, ae=True )
Result: ((-1.3974823951721191, 1.39748215675354), (-1.4071073532104492, -1.4071073532104492), (-1.3598332405090332, 1.3598330020904541)) ---


Local and World Space Area
cmds.polyCube( w=1, h=1, d=1, sx=1, sy=1, sz=1, ax=(0, 0, 1), cuv=1, ch=1 )
cmds.setAttr( 'pCube1.scaleY', 2 )
cmds.polyEvaluate( a=True )
Result: 6
cmds.polyEvaluate( wa=True )
Result: 10

UV Shell information
cmds.polySphere( sx=20, sy=20 )
cmds.polyAutoProjection()
cmds.hilite()
cmds.select( 'pSphere1.f[282]', 'pSphere1.f[189:192]', replace = True )

number of UV shells
cmds.polyEvaluate( uvShell=True )
Result: 6

active UV Shells
cmds.polyEvaluate( activeUVShells=True )
Result: [1, 4, 5]

UV shell IDs for selected faces
cmds.polyEvaluate( uvShellIds=True )
Result: [1, 1, 1, 4, 5]

UV edge pairs for selected edges
cmds.polyEvaluate( 'pSphere1.e[642]', uvEdgePairs=True )
Result: [u'pSphereShape1.map[67] pSphereShape1.map[74] pSphereShape1.map[307] pSphereShape1.map[300] ']

---
Return:
---


    Any: a MEL array of values, a Python dictionary, or a string, depending on
the format requested and the language called from.

Flags:
---


---
accurateEvaluation(ae): boolean
    properties: create
    used to get accurate results for the bounding box computation
For objects with large vertex counts, accurate evaluation takes more time

---
activeShells(activeShells): boolean
    properties: create
    returns the indices of active shells as an array of int

---
activeUVShells(aus): boolean
    properties: create
    returns the indices of active UV shells (for the current map if one
is not specified) as an array of int

---
area(a): boolean
    properties: create
    returns the surface area of the object's faces in local space as a float

---
boundingBox(b): boolean
    properties: create
    returns the object's bounding box in 3d space
as 6 floats in MEL: xmin xmax ymin ymax zmin zmax, or as
a tuple of three pairs in Python: ((xmin,xmax), (ymin,ymax), (zmin,zmax))

---
boundingBox2d(b2): boolean
    properties: create
    returns the object's uv bounding box (for the current map if one is not specified) in 2d space
as 4 floats in MEL : xmin xmax ymin ymax, or as
a tuple of three pairs in Python: ((xmin,xmax), (ymin,ymax), (zmin,zmax))

---
boundingBoxComponent(bc): boolean
    properties: create
    returns the bounding box of selected components in 3d space
as 6 floats in MEL : xmin xmax ymin ymax zmin zmax, or as
a tuple of three pairs in Python: ((xmin,xmax), (ymin,ymax), (zmin,zmax))

---
boundingBoxComponent2d(bc2): boolean
    properties: create
    returns the bounding box of selected/specified components uv coordinates in 2d space
as 4 floats in MEL : xmin xmax ymin ymax, or as
a tuple of two pairs in Python: ((xmin,xmax), (ymin,ymax))

---
displayStats(ds): boolean
    properties: create
    toggles the display of poly statistics for the active View.
All other flags are ignored if this flag is specified (Obsolete
- refer to the headsUpDisplay command)

---
edge(e): boolean
    properties: create
    returns the number of edges as an int

---
edgeComponent(ec): boolean
    properties: create
    returns the object's number of selected edges as an int

---
face(f): boolean
    properties: create
    returns the number of faces as an int

---
faceArea(fa): boolean
    properties: create
    returns the surface area of selected/specified faces in local space as an array of float

---
faceComponent(fc): boolean
    properties: create
    returns the object's number of selected faces as an int

---
format(fmt): boolean
    properties: create
    used to display the results as an explicit sentence

---
shell(s): boolean
    properties: create
    returns the number of shells (disconnected pieces) as an int

---
triangle(t): boolean
    properties: create
    returns the number of triangles as an int

---
triangleComponent(tc): boolean
    properties: create
    returns the number of triangles of selected components as an int

---
uvArea(uva): boolean
    properties: create
    returns the UV area of the object's faces in 2d space as a float

---
uvComponent(uvc): boolean
    properties: create
    returns the object's number of selected uv coordinates as an int

---
uvEdgePairs(uep): boolean
    properties: create
    returns the pairs of UVs that are on the selected/specified edges

---
uvFaceArea(ufa): boolean
    properties: create
    returns the UV area of selected/specified faces in 2d space as an array of float

---
uvSetName(uvs): string
    properties: create
    used when querying texture vertices to specify the uv set.  If a uv set
is not specified then the current map for the object will be used

---
uvShell(us): boolean
    properties: create
    returns the number of UV shells (for the current map if one is not
specified) as an int

---
uvShellIds(usi): boolean
    properties: create
    returns the UV shell indices for selected/specified faces or UVs as an array of int
(for the current map if one is not specified), one shell index per each face/UV.

---
uvcoord(uv): boolean
    properties: create
    returns the number of uv coordinates (for the current map if one is
not specified) as an int

---
uvsInShell(uis): int
    properties: create
    returns all UVs inside specified shell(for the current map if one is not specified), use activeUVShells
to get shell indices for current selection, use uvShellIds to get shell indices for specified faces or UVs

---
vertex(v): boolean
    properties: create
    returns the number of vertices as an int

---
vertexComponent(vc): boolean
    properties: create
    returns the object's number of selected vertices as an int

---
worldArea(wa): boolean
    properties: create
    returns the surface area of the object's faces in world space as a float

---
worldFaceArea(wfa): boolean
    properties: create
    returns the surface area of selected/specified faces in world space as an array of float

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyEvaluate.html 
    """


def polyExtrudeEdge(flagcaching: boolean, flagconstructionHistory: boolean, flagcreateCurve: boolean, flagdivisions: int, flaggain: float, flaginputCurve: name, flagkeepFacesTogether: boolean, flaglocalCenter: int, flaglocalDirection: tuple[linear, linear, linear], flaglocalDirectionX: linear, flaglocalDirectionY: linear, flaglocalDirectionZ: linear, flaglocalRotate: tuple[angle, angle, angle], flaglocalRotateX: angle, flaglocalRotateY: angle, flaglocalRotateZ: angle, flaglocalScale: tuple[float, float, float], flaglocalScaleX: float, flaglocalScaleY: float, flaglocalScaleZ: float, flaglocalTranslate: tuple[linear, linear, linear], flaglocalTranslateX: linear, flaglocalTranslateY: linear, flaglocalTranslateZ: linear, flagname: string, flagnodeState: int, flagoffset: float, flagpivot: tuple[linear, linear, linear], flagpivotX: linear, flagpivotY: linear, flagpivotZ: linear, flagrandom: float, flagrotate: tuple[angle, angle, angle], flagrotateX: angle, flagrotateY: angle, flagrotateZ: angle, flagscale: tuple[float, float, float], flagscaleX: float, flagscaleY: float, flagscaleZ: float, flagsmoothingAngle: angle, flagtaper: float, flagtaperCurve_FloatValue: float, flagtaperCurve_Interp: int, flagtaperCurve_Position: float, flagthickness: float, flagtranslate: tuple[linear, linear, linear], flagtranslateX: linear, flagtranslateY: linear, flagtranslateZ: linear, flagtwist: angle, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyExtrudeEdge([caching=boolean], [constructionHistory=boolean], [createCurve=boolean], [divisions=int], [gain=float], [inputCurve=name], [keepFacesTogether=boolean], [localCenter=int], [localDirection=[linear, linear, linear]], [localDirectionX=linear], [localDirectionY=linear], [localDirectionZ=linear], [localRotate=[angle, angle, angle]], [localRotateX=angle], [localRotateY=angle], [localRotateZ=angle], [localScale=[float, float, float]], [localScaleX=float], [localScaleY=float], [localScaleZ=float], [localTranslate=[linear, linear, linear]], [localTranslateX=linear], [localTranslateY=linear], [localTranslateZ=linear], [name=string], [nodeState=int], [offset=float], [pivot=[linear, linear, linear]], [pivotX=linear], [pivotY=linear], [pivotZ=linear], [random=float], [rotate=[angle, angle, angle]], [rotateX=angle], [rotateY=angle], [rotateZ=angle], [scale=[float, float, float]], [scaleX=float], [scaleY=float], [scaleZ=float], [smoothingAngle=angle], [taper=float], [taperCurve_FloatValue=float], [taperCurve_Interp=int], [taperCurve_Position=float], [thickness=float], [translate=[linear, linear, linear]], [translateX=linear], [translateY=linear], [translateZ=linear], [twist=angle], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyExtrudeEdge is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Separate
cmds.polyPlane( n='plg', w=10, h=10 )
cmds.polyExtrudeEdge( 'plg.e[71:72]', 'plg.e[81:82]', kft=False,, ltz=2, ls=(.5, .5, 0) )
Edges are extruded then scaled separately
cmds.delete( 'plg' )


Together
cmds.polyPlane( n='plg', w=10, h=10 )
cmds.polyExtrudeEdge( 'plg.e[71:72]', 'plg.e[81:82]', kft=True, ltz=2, ls=(.5, .5, 0) )
Edges are extruded then scaled together
cmds.delete( 'plg' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createCurve(cc): boolean
    properties: create
    If true then the operation can create a curve.

---
divisions(d): int
    properties: create, query, edit
    How many internal edges are creating when pulling.
Default: 1

---
gain(ga): float
    properties: create, query, edit, multiuse
    Gain factor per component. Can be painted using Artisan.
Default: 1.0

---
inputCurve(inc): name
    properties: create
    This flag specifies the name of the curve to be used as input for the operation.

---
keepFacesTogether(kft): boolean
    properties: create, query, edit
    How to extrude edges.
If "on", extruded faces produced from the edges being extruded
will be kept together. Otherwise they are pulled independently.
Default: true

---
localCenter(lc): int
    properties: create, query, edit
    Local center on the edge : 0=Middle point, 1=Start point, 2=End point.
Default: 0

---
localDirection(ld): [linear, linear, linear]
    properties: create, query, edit
    Direction to determine X axis for local space.
Default: 1.0, 0.0, 0.0

---
localDirectionX(ldx): linear
    properties: create, query, edit
    X coord of the X axis.

---
localDirectionY(ldy): linear
    properties: create, query, edit
    Y coord of the X axis.

---
localDirectionZ(ldz): linear
    properties: create, query, edit
    Z coord of the X axis.

---
localRotate(lr): [angle, angle, angle]
    properties: create, query, edit
    The local rotations.
Default: 0.0, 0.0, 0.0

---
localRotateX(lrx): angle
    properties: create, query, edit
    Local rotate X coord.
The range is [0, 360].

---
localRotateY(lry): angle
    properties: create, query, edit
    Local rotate Y coord.
The range is [0, 360].

---
localRotateZ(lrz): angle
    properties: create, query, edit
    Local rotate Z coord : Rotation along the normal.
The range is [0, 360].

---
localScale(ls): [float, float, float]
    properties: create, query, edit
    Local Scale.
Default: 1.0, 1.0, 1.0

---
localScaleX(lsx): float
    properties: create, query, edit
    Scale X coord.

---
localScaleY(lsy): float
    properties: create, query, edit
    Scale Y coord.

---
localScaleZ(lsz): float
    properties: create, query, edit
    Scale Z coord.

---
localTranslate(lt): [linear, linear, linear]
    properties: create, query, edit
    Local translate.
Default: 0.0, 0.0, 0.0

---
localTranslateX(ltx): linear
    properties: create, query, edit
    Local translation X coord.

---
localTranslateY(lty): linear
    properties: create, query, edit
    Local translation Y coord.

---
localTranslateZ(ltz): linear
    properties: create, query, edit
    Local translation Z coord : Move along the normal.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
offset(off): float
    properties: create, query, edit
    Edges are moved this distance in the opposite direction of the edge.
Default: 0.0

---
pivot(pvt): [linear, linear, linear]
    properties: create, query, edit
    The pivot for scaling and rotation.
Default: 0.0, 0.0, 0.0

---
pivotX(pvx): linear
    properties: create, query, edit
    Pivot X coord.

---
pivotY(pvy): linear
    properties: create, query, edit
    Pivot Y coord.

---
pivotZ(pvz): linear
    properties: create, query, edit
    Pivot Z coord.

---
random(ran): float
    properties: create, query, edit
    Random value for all parameters.
Default: 0.0

---
rotate(ro): [angle, angle, angle]
    properties: create, query, edit
    Rotation angles around X, Y, Z.
Default: 0.0, 0.0, 0.0

---
rotateX(rx): angle
    properties: create, query, edit
    Rotation angle around X.

---
rotateY(ry): angle
    properties: create, query, edit
    Rotation angle around Y.

---
rotateZ(rz): angle
    properties: create, query, edit
    Rotation angle around Z.

---
scale(s): [float, float, float]
    properties: create, query, edit
    Scaling vector.
Default: 1.0, 1.0, 1.0

---
scaleX(sx): float
    properties: create, query, edit
    Scale X coord.

---
scaleY(sy): float
    properties: create, query, edit
    Scale Y coord.

---
scaleZ(sz): float
    properties: create, query, edit
    Scale Z coord.

---
smoothingAngle(sma): angle
    properties: create, query, edit
    Angle below which new edges will be smoothed
Default: kPi/6.0

---
taper(tp): float
    properties: create, query, edit
    Taper or Scale along the extrusion path
Default: 1.0

---
taperCurve_FloatValue(cfv): float
    properties: create, query, edit
    ?????

---
taperCurve_Interp(ci): int
    properties: create, query, edit
    ?????
Default: 0

---
taperCurve_Position(cp): float
    properties: create, query, edit
    ?????

---
thickness(tk): float
    properties: create, query, edit
    Edges are moved this distance in the direction of the connected face normals.
Default: 0.0f

---
translate(t): [linear, linear, linear]
    properties: create, query, edit
    Translation vector.
Default: 0.0, 0.0, 0.0

---
translateX(tx): linear
    properties: create, query, edit
    Translation X coord.

---
translateY(ty): linear
    properties: create, query, edit
    Translation Y coord.

---
translateZ(tz): linear
    properties: create, query, edit
    Translation Z coord.

---
twist(twt): angle
    properties: create, query, edit
    Twist or Rotation along the extrusion path
Default: 0.0

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyExtrudeEdge.html 
    """


def polyExtrudeFacet(flagattraction: float, flagcaching: boolean, flagconstructionHistory: boolean, flagcreateCurve: boolean, flagdivisions: int, flaggain: float, flaggravity: tuple[linear, linear, linear], flaggravityX: linear, flaggravityY: linear, flaggravityZ: linear, flaginputCurve: name, flagkeepFacesTogether: boolean, flagkeepFacetTogether: boolean, flaglocalCenter: int, flaglocalDirection: tuple[linear, linear, linear], flaglocalDirectionX: linear, flaglocalDirectionY: linear, flaglocalDirectionZ: linear, flaglocalRotate: tuple[angle, angle, angle], flaglocalRotateX: angle, flaglocalRotateY: angle, flaglocalRotateZ: angle, flaglocalScale: tuple[float, float, float], flaglocalScaleX: float, flaglocalScaleY: float, flaglocalScaleZ: float, flaglocalTranslate: tuple[linear, linear, linear], flaglocalTranslateX: linear, flaglocalTranslateY: linear, flaglocalTranslateZ: linear, flagmagnX: linear, flagmagnY: linear, flagmagnZ: linear, flagmagnet: tuple[linear, linear, linear], flagname: string, flagnodeState: int, flagoffset: float, flagpivot: tuple[linear, linear, linear], flagpivotX: linear, flagpivotY: linear, flagpivotZ: linear, flagrandom: float, flagreverseAllFaces: boolean, flagrotate: tuple[angle, angle, angle], flagrotateX: angle, flagrotateY: angle, flagrotateZ: angle, flagscale: tuple[float, float, float], flagscaleX: float, flagscaleY: float, flagscaleZ: float, flagsmoothingAngle: angle, flagtaper: float, flagtaperCurve_FloatValue: float, flagtaperCurve_Interp: int, flagtaperCurve_Position: float, flagthickness: float, flagtranslate: tuple[linear, linear, linear], flagtranslateX: linear, flagtranslateY: linear, flagtranslateZ: linear, flagtwist: angle, flagweight: float, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyExtrudeFacet([attraction=float], [caching=boolean], [constructionHistory=boolean], [createCurve=boolean], [divisions=int], [gain=float], [gravity=[linear, linear, linear]], [gravityX=linear], [gravityY=linear], [gravityZ=linear], [inputCurve=name], [keepFacesTogether=boolean], [keepFacetTogether=boolean], [localCenter=int], [localDirection=[linear, linear, linear]], [localDirectionX=linear], [localDirectionY=linear], [localDirectionZ=linear], [localRotate=[angle, angle, angle]], [localRotateX=angle], [localRotateY=angle], [localRotateZ=angle], [localScale=[float, float, float]], [localScaleX=float], [localScaleY=float], [localScaleZ=float], [localTranslate=[linear, linear, linear]], [localTranslateX=linear], [localTranslateY=linear], [localTranslateZ=linear], [magnX=linear], [magnY=linear], [magnZ=linear], [magnet=[linear, linear, linear]], [name=string], [nodeState=int], [offset=float], [pivot=[linear, linear, linear]], [pivotX=linear], [pivotY=linear], [pivotZ=linear], [random=float], [reverseAllFaces=boolean], [rotate=[angle, angle, angle]], [rotateX=angle], [rotateY=angle], [rotateZ=angle], [scale=[float, float, float]], [scaleX=float], [scaleY=float], [scaleZ=float], [smoothingAngle=angle], [taper=float], [taperCurve_FloatValue=float], [taperCurve_Interp=int], [taperCurve_Position=float], [thickness=float], [translate=[linear, linear, linear]], [translateX=linear], [translateY=linear], [translateZ=linear], [twist=angle], [weight=float], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyExtrudeFacet is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Separate
cmds.polyPlane( n='plg', w=10, h=10 )
cmds.polyExtrudeFacet( 'plg.f[71:72]', 'plg.f[81:82]', kft=False, ltz=2, ls=(.5, .5, 0) )
Facets are extruded then scaled separately


Together
cmds.polyExtrudeFacet( 'plg.f[17:18]', 'plg.f[27:28]', kft=True, ltz=2, ls=(.5, .5, 0) )
Facets are extruded then scaled together

---
Return:
---


    string: The node name.

Flags:
---


---
attraction(att): float
    properties: create, query, edit
    Attraction, related to magnet.
The range is [-2.0, 2.0].
Default: 0.0

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createCurve(cc): boolean
    properties: create
    If true then the operation can create a curve.

---
divisions(d): int
    properties: create, query, edit
    How many divisions should the extrusion be broken-up into.
Default: 1

---
gain(ga): float
    properties: create, query, edit, multiuse
    Gain factor per component. Can be painted using Artisan.
Default: 1.0

---
gravity(g): [linear, linear, linear]
    properties: create, query, edit
    The gravity vector.
Default: 0.0, -1.0, 0.0

---
gravityX(gx): linear
    properties: create, query, edit
    Gravity X coord.

---
gravityY(gy): linear
    properties: create, query, edit
    Gravity Y coord.

---
gravityZ(gz): linear
    properties: create, query, edit
    Gravity Z coord.

---
inputCurve(inc): name
    properties: create
    This flag specifies the name of the curve to be used as input for the operation.

---
keepFacesTogether(kft): boolean
    properties: create, query, edit
    How to extrude faces.
If "on", faces are pulled together (connected ones stay connected),
otherwise they are pulled independently.
Default: true

---
keepFacetTogether(xft): boolean
    properties: create, query, edit
    How to extrude edges.
If "on", extruded faces produced from the edges being extruded
will be kept together. Otherwise they are pulled independently.
Default: true

---
localCenter(lc): int
    properties: create, query, edit
    Local center on the edge : 0=Middle point, 1=Start point, 2=End point.
Default: 0

---
localDirection(ld): [linear, linear, linear]
    properties: create, query, edit
    Direction to determine X axis for local space.
Default: 1.0, 0.0, 0.0

---
localDirectionX(ldx): linear
    properties: create, query, edit
    X coord of the X axis.

---
localDirectionY(ldy): linear
    properties: create, query, edit
    Y coord of the X axis.

---
localDirectionZ(ldz): linear
    properties: create, query, edit
    Z coord of the X axis.

---
localRotate(lr): [angle, angle, angle]
    properties: create, query, edit
    The local rotations.
Default: 0.0, 0.0, 0.0

---
localRotateX(lrx): angle
    properties: create, query, edit
    Local rotate X coord.
The range is [0, 360].

---
localRotateY(lry): angle
    properties: create, query, edit
    Local rotate Y coord.
The range is [0, 360].

---
localRotateZ(lrz): angle
    properties: create, query, edit
    Local rotate Z coord : Rotation along the normal.
The range is [0, 360].

---
localScale(ls): [float, float, float]
    properties: create, query, edit
    Local Scale.
Default: 1.0, 1.0, 1.0

---
localScaleX(lsx): float
    properties: create, query, edit
    Scale X coord.

---
localScaleY(lsy): float
    properties: create, query, edit
    Scale Y coord.

---
localScaleZ(lsz): float
    properties: create, query, edit
    Scale Z coord.

---
localTranslate(lt): [linear, linear, linear]
    properties: create, query, edit
    Local translate.
Default: 0.0, 0.0, 0.0

---
localTranslateX(ltx): linear
    properties: create, query, edit
    Local translation X coord.

---
localTranslateY(lty): linear
    properties: create, query, edit
    Local translation Y coord.

---
localTranslateZ(ltz): linear
    properties: create, query, edit
    Local translation Z coord : Move along the normal.

---
magnX(mx): linear
    properties: create, query, edit
    Magnet X coord.

---
magnY(my): linear
    properties: create, query, edit
    Magnet Y coord.

---
magnZ(mz): linear
    properties: create, query, edit
    Magnet Z coord.

---
magnet(m): [linear, linear, linear]
    properties: create, query, edit
    The magnet vector.
Default: 0.0, 0.0, 0.0

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
offset(off): float
    properties: create, query, edit
    Local offset. Faces are moved this distance towards the inside of the face.
Default: 0.0

---
pivot(pvt): [linear, linear, linear]
    properties: create, query, edit
    The pivot for scaling and rotation.
Default: 0.0, 0.0, 0.0

---
pivotX(pvx): linear
    properties: create, query, edit
    Pivot X coord.

---
pivotY(pvy): linear
    properties: create, query, edit
    Pivot Y coord.

---
pivotZ(pvz): linear
    properties: create, query, edit
    Pivot Z coord.

---
random(ran): float
    properties: create, query, edit
    Random value for all parameters.
Default: 0.0

---
reverseAllFaces(raf): boolean
    properties: create, query, edit
    If "on", original faces are reversed in case
of extruding all faces.
Default: true

---
rotate(ro): [angle, angle, angle]
    properties: create, query, edit
    Rotation angles around X, Y, Z.
Default: 0.0, 0.0, 0.0

---
rotateX(rx): angle
    properties: create, query, edit
    Rotation angle around X.

---
rotateY(ry): angle
    properties: create, query, edit
    Rotation angle around Y.

---
rotateZ(rz): angle
    properties: create, query, edit
    Rotation angle around Z.

---
scale(s): [float, float, float]
    properties: create, query, edit
    Scaling vector.
Default: 1.0, 1.0, 1.0

---
scaleX(sx): float
    properties: create, query, edit
    Scale X coord.

---
scaleY(sy): float
    properties: create, query, edit
    Scale Y coord.

---
scaleZ(sz): float
    properties: create, query, edit
    Scale Z coord.

---
smoothingAngle(sma): angle
    properties: create, query, edit
    Angle below which new edges will be smoothed
Default: kPi/6.0

---
taper(tp): float
    properties: create, query, edit
    Taper or Scale along the extrusion path
Default: 1.0

---
taperCurve_FloatValue(cfv): float
    properties: create, query, edit
    ?????

---
taperCurve_Interp(ci): int
    properties: create, query, edit
    ?????
Default: 0

---
taperCurve_Position(cp): float
    properties: create, query, edit
    ?????

---
thickness(tk): float
    properties: create, query, edit
    Faces are moved outwards from their original position to give
the object a consistent thickess.
Default: 0.0f

---
translate(t): [linear, linear, linear]
    properties: create, query, edit
    Translation vector.
Default: 0.0, 0.0, 0.0

---
translateX(tx): linear
    properties: create, query, edit
    Translation X coord.

---
translateY(ty): linear
    properties: create, query, edit
    Translation Y coord.

---
translateZ(tz): linear
    properties: create, query, edit
    Translation Z coord.

---
twist(twt): angle
    properties: create, query, edit
    Twist or Rotation along the extrusion path
Default: 0.0

---
weight(w): float
    properties: create, query, edit
    The weight, related to gravity.
Default: 0.0

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyExtrudeFacet.html 
    """


def polyExtrudeVertex(flagcaching: boolean, flagconstructionHistory: boolean, flagdivisions: int, flaglength: float, flagname: string, flagnodeState: int, flagwidth: float, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyExtrudeVertex([caching=boolean], [constructionHistory=boolean], [divisions=int], [length=float], [name=string], [nodeState=int], [width=float], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyExtrudeVertex is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.polyCube( h=10, w=10, d=10 )
cmds.polyExtrudeVertex( l=2, w=3, d=4 )
A cube is created and then all of its vertices are extruded into 4 divisions with length 2 and width 3

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
divisions(d): int
    properties: create, query, edit
    This flag specifies the number of subdivisions.
C: Default is 1
Q: When queried, this flag returns an int.

---
length(l): float
    properties: create, query, edit
    This flag specifies the length of the vertex extrusion.
C: Default is 0
Q: When queried, this flag returns a float.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
width(w): float
    properties: create, query, edit
    This flag specifies the width of the vertex extrusion.
C: Default is 0
Q: When queried, this flag returns a float.

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyExtrudeVertex.html 
    """


def polyFlipEdge() -> boolean:
    """Synopsis:
---
---
 polyFlipEdge()  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyFlipEdge is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

To flip the selected edge
cmds.polyFlipEdge()

---
Return:
---


    boolean: Success or Failure.

Flags:
---


URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyFlipEdge.html 
    """


def polyFlipUV(flagcaching: boolean, flagconstructionHistory: boolean, flagcreateNewMap: boolean, flagcutUV: boolean, flagflipType: int, flaginsertBeforeDeformers: boolean, flaglocal: boolean, flagname: string, flagnodeState: int, flagpivotU: float, flagpivotV: float, flagusePivot: boolean, flaguvSetName: string, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyFlipUV([caching=boolean], [constructionHistory=boolean], [createNewMap=boolean], [cutUV=boolean], [flipType=int], [insertBeforeDeformers=boolean], [local=boolean], [name=string], [nodeState=int], [pivotU=float], [pivotV=float], [usePivot=boolean], [uvSetName=string], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyFlipUV is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a poly sphere with default UVs.
cmds.polySphere( n='sph' )

Flip uvs on all faces of the sphere shape.
cmds.polyFlipUV( 'sphShape.f[*]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createNewMap(cm): boolean
    properties: create
    Set to true if a new map should be created

---
cutUV(cut): boolean
    properties: create, query, edit
    Cut UV edges when flipping some components on a UV shell
C: Default is on.
Q: When queried, returns an int.

---
flipType(ft): int
    properties: create, query, edit
    Flip along U or V direction.


0 Horizontal


1 Vertical


C: Default is 0.
Q: When queried, returns an int.

---
insertBeforeDeformers(ibd): boolean
    properties: create
    Set to true if the new node created should inserted before any deformer nodes.

---
local(l): boolean
    properties: create, query, edit
    Flips in the local space of the input faces.
C: Default is on.
Q: When queried, returns an int.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
pivotU(pu): float
    properties: create, query, edit
    Specifies the pivot value, in the U direction.

---
pivotV(pv): float
    properties: create, query, edit
    Specifies the pivot value, in the V direction.

---
usePivot(up): boolean
    properties: create, query, edit
    Flip using pivot or not.
C: Default is off.
Q: When queried, returns an int.

---
uvSetName(uvs): string
    properties: create
    Name of the UV set to be created

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyFlipUV.html 
    """


def polyForceUV(flagcameraProjection: boolean, flagcreateNewMap: boolean, flagflipHorizontal: boolean, flagflipVertical: boolean, flagg: boolean, flaglocal: boolean, flagnormalize: string, flagnumItems: uint, flagpreserveAspectRatio: boolean, flagunitize: boolean, flagunshare: boolean, flaguvSetName: string) -> boolean:
    """Synopsis:
---
---
 polyForceUV([cameraProjection=boolean], [createNewMap=boolean], [flipHorizontal=boolean], [flipVertical=boolean], [g=boolean], [local=boolean], [normalize=string], [numItems=uint], [preserveAspectRatio=boolean], [unitize=boolean], [unshare=boolean], [uvSetName=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyForceUV is undoable, NOT queryable, and NOT editable.Project UVs based on the camera:(UV creation) Best Plane Projection:     (UV creation) Unitize:     (UV creation) Unshare:(UV creation) 


Example:
---
import maya.cmds as cmds

cmds.polyForceUV( uni=True )
unitize the UV values of the selected faces separately

cmds.polyForceUV( cp=True )
create UVs on the selected faces based on the current camera

cmds.polyForceUV( 'pCylinder1.f[11:14]', 'pCylinder1.vtx[33:34]', 'pCylinder1.vtx[13:14]', ni=1 )
create the UVs for the first item (ie, 4 polygonal faces, in this case)
in the selection list, by computing the plane using the rest of the
items in the list

---
Return:
---


    boolean: true/false

Flags:
---


---
cameraProjection(cp): boolean
    properties: create
    Project the UVs based on the camera position/orientation

---
createNewMap(cm): boolean
    properties: create
    Create new map if it does not exist.

---
flipHorizontal(fh): boolean
    properties: create
    OBSOLETE flag.  Use polyFlipUV instead.

---
flipVertical(fv): boolean
    properties: create
    OBSOLETE flag.  Use polyFlipUV instead.

---
g(g): boolean
    properties: create
    OBSOLETE flag.

---
local(l): boolean
    properties: create
    OBSOLETE flag.

---
normalize(nor): string
    properties: create
    OBSOLETE flag.  Use polyNormalizeUV instead.

---
numItems(ni): uint
    properties: create
    This flag is only used for the best plane texturing
        of polygonal faces.  This flag should be followed by a
        selection list. If not specified, the selected objects will
        be used (in the order they were selected). 
        This flag specifies the number of items (leading) in the
        selection list that should be used for the mapping.
        The trailing items will be used for computing the
        plane (See example below).  The best plane texturing
        is better suited for using interactively from within its context.
        You can type "BestPlaneTexturingTool"
        in the command window OR (EditPolygons->Texture->BestPlaneTexturing
        from the Menu) to enter its context.

---
preserveAspectRatio(par): boolean
    properties: create
    OBSOLETE flag.

---
unitize(uni): boolean
    properties: create
    To unitize the UVs of the selected faces

---
unshare(u): boolean
    properties: create
    To unshare tye specified UV

---
uvSetName(uvs): string
    properties: create
    Specifies name of the uv set to work on

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyForceUV.html 
    """


def polyGeoSampler(flagalphaBlend: string, flagaverageColor: boolean, flagclampAlphaMax: float, flagclampAlphaMin: float, flagclampRGBMax: tuple[float, float, float], flagclampRGBMin: tuple[float, float, float], flagcolorBlend: string, flagcolorDisplayOption: boolean, flagcomputeShadows: boolean, flagdisplaceGeometry: boolean, flagflatShading: boolean, flagignoreDoubleSided: boolean, flaglightingOnly: boolean, flagreuseShadows: boolean, flagsampleByFace: boolean, flagscaleFactor: float, flagshareUV: boolean, flaguseLightShadows: boolean) -> boolean:
    """Synopsis:
---
---
 polyGeoSampler([alphaBlend=string], [averageColor=boolean], [clampAlphaMax=float], [clampAlphaMin=float], [clampRGBMax=[float, float, float]], [clampRGBMin=[float, float, float]], [colorBlend=string], [colorDisplayOption=boolean], [computeShadows=boolean], [displaceGeometry=boolean], [flatShading=boolean], [ignoreDoubleSided=boolean], [lightingOnly=boolean], [reuseShadows=boolean], [sampleByFace=boolean], [scaleFactor=float], [shareUV=boolean], [useLightShadows=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyGeoSampler is undoable, NOT queryable, and editable.
        resulting-RGB = (sampled-RGB * scale-factor);
        if (color blend is none)
                resulting-RGB = geometry-RGB
        else if (color blend is add)
                resulting-RGB = geometry-RGB + sampled-RGB;
        else if (color blend is subtract)
                resulting-RGB = geometry-RGB - sampled-RGB;
        else if (color blend is multiply)
                resulting-RGB = geometry-RGB * sampled-RGB;
        else if (color blend is divide)
                resulting-RGB = geometry-RGB / sampled-RGB;
        else if (color blend is average)
                resulting-RGB = (geometry-RGB * 1/2) + (sampled-RGB * 1/2);
        if (clamp option set)
                clamp resulting-RGB between minimum-RGB and maximum-RGB,



Example:
---
import maya.cmds as cmds

Example 1. Sample for color values.

   a. No arguments. Will perform sampling of color + transparency at
    the vertex level, and store color values for affected vertices.
    No shadows will be computed.

cmds.polyGeoSampler()

b. With shadows and illumination only

cmds.polyGeoSampler( lightingOnly=True, computeShadows=True )

c. Sampling only complete selected faces

cmds.polyGeoSampler( sampleByFace=True )

d. "Flat shading".

Example 2. Sample for displacement values.

a. Using displace option

cmds.polyGeoSampler( displaceGeometry=True )

Example 3. Scaling the sampled data.

a. Scaling option

cmds.polyGeoSampler( scaleFactor=0.1 )

Example 4. Don't force unshared UV value usage, and force
the storage of shared colors for vertices.

cmds.polyGeoSampler( shareUV=True, averageColor=True )

Example 5. Clamping colors. In this example the alpha and
RGB channels of the colors are clamped between a min of 0,0,0,1
and a max of 1,2,1,0.5 .

cmds.polyGeoSampler( amn=0.0, amx=0.5, cmn=[0.0,0.0,0.0], cmx=[1.0,2.0,1.0] )

Example 6. Multiply the new sample color values    with the existing
colors stored on the geometry, but leave the alpha values
as they were on the geometry.

cmds.polyGeoSampler( colorBlend='multiply', alphaBlend='none' )

---
Return:
---


    boolean: Success or Failure

Flags:
---


---
alphaBlend(abl): string
    properties: create, edit
    When specified, indicates the type of alpha blend to
be applied. Options are: "none", "overwrite", "add",
"subtract", "multiply", "divide", "average".
This option only applies when colors are being
set. The default if this argument is not
specified is "overwrite".
The "none" options
to not overwrite the existing value.

---
averageColor(ac): boolean
    properties: create, edit
    When used, will mean to force the storage of shared colors
for vertex level sampling. By default vertex level sampling
stores unshared colors.

---
clampAlphaMax(amx): float
    properties: create, edit
    When used, will mean to clamp the storage of alpha
to a maximum

---
clampAlphaMin(amn): float
    properties: create, edit
    When used, will mean to clamp the storage of alpha
to a minimum

---
clampRGBMax(cmx): [float, float, float]
    properties: create, edit
    When used, will mean to clamp the storage of RGB
color to a maximum

---
clampRGBMin(cmn): [float, float, float]
    properties: create, edit
    When used, will mean to clamp the storage of RGB
color to a minimum

---
colorBlend(cbl): string
    properties: create, edit
    When specified, indicates the type of color blend to
be applied. Options are: "none", "overwrite", "add",
"subtract", "multiply", "divide", "average".
This option only applies when colors are being
set. The default if this argument is not
specified is "overwrite".
The "none" options
to not overwrite the existing value.

---
colorDisplayOption(cdo): boolean
    properties: create, edit
    Change the display options on the mesh to display the vertex colors.

---
computeShadows(cs): boolean
    properties: create, edit
    When used, shadow maps will be computed, saved, and reused during the sampling
process.

---
displaceGeometry(dg): boolean
    properties: create, edit
    When used, geometry will be displaced along the normals at
the sampling positions, as opposed to storing color values. The
default is to store colors.

---
flatShading(fs): boolean
    properties: create, edit
    When used, flat shaded sampling will be computed. The default
is smooth shading.

---
ignoreDoubleSided(ids): boolean
    properties: create, edit
    When specified, the double sided flag will be ignored
for prelighting.

---
lightingOnly(lo): boolean
    properties: create, edit
    When used, incoming illumination will be computed as opposed to
surface color an tranparency

---
reuseShadows(rs): boolean
    properties: create, edit
    When used, if shadow maps were previosly computed and saved, then
they will be reused during the sampling process. The computeShadows
option must be enabled for this option to apply.

---
sampleByFace(bf): boolean
    properties: create, edit
    When used, sample will occur at a per face level versus a per
vertex level, which is the default behaviour

---
scaleFactor(sf): float
    properties: create, edit
    When used, will scale the sampled value by the specified amount.
The default scale factor is 1.0. Negative values are acceptable
for displacement, but not for color values.

---
shareUV(su): boolean
    properties: create, edit
    When used, UVs are shared at a vertex when sampled.
By default UVs are forced to be unshared.

---
useLightShadows(ul): boolean
    properties: create, edit
    When used, will use each lights shadow map options. Otherwise
these options will be overrridden when the computeShadows, and/or
reusedShadows option is enabled.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyGeoSampler.html 
    """


def polyHelix(flagcaching: boolean, flagcoils: float, flagconstructionHistory: boolean, flagcreateUVs: int, flagdirection: int, flagheight: linear, flagname: string, flagnodeState: int, flagobject: boolean, flagradius: linear, flagroundCap: boolean, flagsubdivisionsAxis: int, flagsubdivisionsCaps: int, flagsubdivisionsCoil: int, flagtexture: int, flaguseOldInitBehaviour: boolean, flagwidth: linear) -> list[string]:
    """Synopsis:
---
---
 polyHelix([caching=boolean], [coils=float], [constructionHistory=boolean], [createUVs=int], [direction=int], [height=linear], [name=string], [nodeState=int], [object=boolean], [radius=linear], [roundCap=boolean], [subdivisionsAxis=int], [subdivisionsCaps=int], [subdivisionsCoil=int], [texture=int], [useOldInitBehaviour=boolean], [width=linear])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyHelix is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a helix with radius 1.0 in anti clockwise direction with no UV's for texture.
cmds.polyHelix(r=1, d=1, cuv=0)

Create a helix, called "myHelix" with default values.
cmds.polyHelix(n='myHelix')

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
coils(c): float
    properties: create, query, edit
    Number of coils.
Default: 3

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createUVs(cuv): int
    properties: create, query, edit
    Create UVs or not.
0: No UVs
1: No Normalization
2: Normalize
3: Normalize and Preserve Aspect Ratio
Default: 2

---
direction(d): int
    properties: create, query, edit
    What should be the direction of the coil.
0=Clockwise; 1=Counterclockwise
Default: 1

---
height(h): linear
    properties: create, query, edit
    Height of the helix.
Default: 2.0

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
radius(r): linear
    properties: create, query, edit
    Radius of tube.
Default: 0.4

---
roundCap(rcp): boolean
    properties: create, query, edit
    To indicate whether we need a round cap
Default: false

---
subdivisionsAxis(sa): int
    properties: create, query, edit
    Subdivisions around the axis.
Default: 8

---
subdivisionsCaps(sc): int
    properties: create, query, edit
    Subdivisions along the thickness caps.
Default: 0

---
subdivisionsCoil(sco): int
    properties: create, query, edit
    Subdivisions along the coil.
Default: 50

---
texture(tx): int
    properties: create, query, edit
    What texture mechanism to be applied
0=No textures; 1=Object; 2=Faces
Default: 2

---
useOldInitBehaviour(oib): boolean
    properties: create, query, edit
    Create the helix with base on the origin as in Maya V8.0 and below
Otherwise create helix centred at origin
Default: false

---
width(w): linear
    properties: create, query, edit
    Width of the helix.
Default: 2.0

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyHelix.html 
    """


def polyHole(flagassignHole: boolean, flagcreateHistory: boolean) -> boolean:
    """Synopsis:
---
---
 polyHole([assignHole=boolean], [createHistory=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyHole is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

To toggle hole on/off on the selected faces
cmds.polyHole( )

---
Return:
---


    boolean: Success or Failure.

Flags:
---


---
assignHole(ah): boolean
    properties: create, query, edit
    Assign the selected faces to be hole or unassign the hole faces to be non-hole. By default, the command will
assign faces to be hole.

---
createHistory(ch): boolean
    properties: create, query, edit
    For objects that have no construction history, this flag can be used
to force the creation of construction history for hole.  By default,
history is not created if the object has no history.  Regardless of this
flag, history is always created if the object already has history.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyHole.html 
    """


def polyInfo(flagedgeToFace: boolean, flagedgeToVertex: boolean, flagfaceNormals: boolean, flagfaceToEdge: boolean, flagfaceToVertex: boolean, flaginvalidEdges: boolean, flaginvalidVertices: boolean, flaglaminaFaces: boolean, flagnonManifoldEdges: boolean, flagnonManifoldUVEdges: boolean, flagnonManifoldUVs: boolean, flagnonManifoldVertices: boolean, flagvertexToEdge: boolean, flagvertexToFace: boolean) -> string:
    """Synopsis:
---
---
 polyInfo([edgeToFace=boolean], [edgeToVertex=boolean], [faceNormals=boolean], [faceToEdge=boolean], [faceToVertex=boolean], [invalidEdges=boolean], [invalidVertices=boolean], [laminaFaces=boolean], [nonManifoldEdges=boolean], [nonManifoldUVEdges=boolean], [nonManifoldUVs=boolean], [nonManifoldVertices=boolean], [vertexToEdge=boolean], [vertexToFace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyInfo is NOT undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

To find all non-manifold edges on a polygonal object called pPlane1
cmds.polyInfo( nme=True )
Result: pPlane1.e[74] ---


To find all non-manifold vertices on a polygonal object called pPlane1
cmds.polyInfo( nmv=True )
Result: pPlane1.vtx[38] pPlane1.vtx[49] ---


---
Return:
---


    string: Components

Flags:
---


---
edgeToFace(ef): boolean
    properties: create
    Returns the faces that share the specified edge. Requires edges to be selected.

---
edgeToVertex(ev): boolean
    properties: create
    Returns the vertices defining an edge. Requires edges to be selected.

---
faceNormals(fn): boolean
    properties: create
    Returns face normals of the specified object. If faces are selected the command
returns the face normals of selected faces. Else it returns the face normals
of all the faces of the object.

---
faceToEdge(fe): boolean
    properties: create
    Returns the edges defining a face. Requires faces to be selected.

---
faceToVertex(fv): boolean
    properties: create
    Returns the vertices defining a face. Requires faces to be selected.

---
invalidEdges(ie): boolean
    properties: create
    Find all edges that are not associated with any face in the mesh.

---
invalidVertices(iv): boolean
    properties: create
    Find all vertices that are not associated with any face in the mesh.

---
laminaFaces(lf): boolean
    properties: create
    Find all lamina faces in the specified objects.

---
nonManifoldEdges(nme): boolean
    properties: create
    Find all non-manifold edges in the specified objects.

---
nonManifoldUVEdges(nue): boolean
    properties: create
    Find all non-manifold UV edges in the specified objects.

---
nonManifoldUVs(nuv): boolean
    properties: create
    Find all non-manifold UVs in the specified objects.

---
nonManifoldVertices(nmv): boolean
    properties: create
    Find all non-manifold vertices in the specified objects.

---
vertexToEdge(ve): boolean
    properties: create
    Returns the Edges connected to a vertex. Requires vertices to be selected.

---
vertexToFace(vf): boolean
    properties: create
    Returns the faces that share the specified vertex. Requires vertices to
be selected.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyInfo.html 
    """


def polyInstallAction(flagcommandName: boolean, flagconvertSelection: boolean, flaginstallConstraint: boolean, flaginstallDisplay: boolean, flagkeepInstances: boolean, flaguninstallConstraint: boolean, flaguninstallDisplay: boolean) -> list[string]:
    """Synopsis:
---
---
 polyInstallAction(
name
    , [commandName=boolean], [convertSelection=boolean], [installConstraint=boolean], [installDisplay=boolean], [keepInstances=boolean], [uninstallConstraint=boolean], [uninstallDisplay=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyInstallAction is undoable, queryable, and NOT editable.
Pickmask
Internal selection constraints
Display attributes




Example:
---
import maya.cmds as cmds

Will set pickmask to edges, install internal constraint
so that only border edges may be selected.
cmds.polyInstallAction( 'polyCloseBorder', ic=True )

Same as previous, plus force the display of borders if the
user didn't asked explicitely for it before.
cmds.polyInstallAction( 'polyCloseBorder', ic=True, id=True )

Shortcut for polyInstallAction -ic -id polyCloseBorder;
cmds.polyInstallAction( 'polyCloseBorder' )

Assuming the previous install was for closeBorder,
will release internal border constraint, but go on displaying
borders if the user didn't asked explicitely for it before.
cmds.polyInstallAction( uc=True )

Assuming the previous install was for closeBorder,
will release internal border constraint, stop displaying
borders if the user didn't asked explicitely for it before.
cmds.polyInstallAction( uc=True, ud=True )

Shortcut for polyInstallAction -uc -ud;
cmds.polyInstallAction()

---
Return:
---


    list[string]: When installing constraint, returns as an array of strings the
items on which the installed command will act on. otherwise, returns nothing

Flags:
---


---
commandName(cn): boolean
    properties: query
    return as a string the name of the command previously installed

---
convertSelection(cs): boolean
    properties: create
    convert all polys selected in object mode
into their full matching component selection. For example : if a polyMesh is selected,
polyInstallAction -cs polyCloseBorder
will select all border edges.

---
installConstraint(ic): boolean
    properties: create, query
    C: install selection pickmask and internal constraints for actionname
Q: returns 1 if any internal constraint is set for current action

---
installDisplay(id): boolean
    properties: create, query
    C: install display attributes for actionname
Q: returns 1 if any display is set for current action

---
keepInstances(ki): boolean
    properties: create
    Convert components for all selected instances rather than only the first selected instance.

---
uninstallConstraint(uc): boolean
    properties: create
    uninstall internal constraints previously installed

---
uninstallDisplay(ud): boolean
    properties: create
    uninstall display attributes previously installed

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyInstallAction.html 
    """


def polyLayoutUV(flagcaching: boolean, flagconstructionHistory: boolean, flagflipReversed: boolean, flaglayout: int, flaglayoutMethod: int, flagname: string, flagnodeState: int, flagpercentageSpace: float, flagrotateForBestFit: int, flagscale: int, flagseparate: int, flaguvSetName: string, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyLayoutUV([caching=boolean], [constructionHistory=boolean], [flipReversed=boolean], [layout=int], [layoutMethod=int], [name=string], [nodeState=int], [percentageSpace=float], [rotateForBestFit=int], [scale=int], [separate=int], [uvSetName=string], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyLayoutUV is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a sphere.
cmds.polySphere( n='sph' )

Use a plane projection on half the faces
cmds.select( 'sph.f[0:200]' )
cmds.polyProjection( type='Planar' )

Layout all UVs in the texture plane.
cmds.polyLayoutUV( 'sph.f[*]', l=2, fr=True, se=2, sc=1 )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
flipReversed(fr): boolean
    properties: create, query, edit
    If this flag is turned on, the reversed UV pieces are fliped.

---
layout(l): int
    properties: create, query, edit
    How to move the UV pieces, after cuts are applied:
0 No move is applied.
1 Layout the pieces along the U axis.
2 Layout the pieces in a square shape.

---
layoutMethod(lm): int
    properties: create, query, edit
    Which layout method to use:
0 Block Stacking.
1 Shape Stacking.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
percentageSpace(ps): float
    properties: create, query, edit
    When layout is set to square, this value is a percentage of
the texture area which is added around each UV piece. It can be
used to ensure each UV piece uses different pixels in the texture.
Maximum value is 5 percent.

---
rotateForBestFit(rbf): int
    properties: create, query, edit
    0 No rotation is applied.
1 Only allow 90 degree rotations.
2 Allow free rotations.

---
scale(sc): int
    properties: create, query, edit
    How to scale the pieces, after move and cuts:
0 No scale is applied.
1 Uniform scale to fit in unit square.
2 Non proportional scale to fit in unit square.

---
separate(se): int
    properties: create, query, edit
    Which UV edges should be cut:
0 No cuts.
1 Cut only along folds.
2 Make all necessary cuts to avoid all intersections.

---
uvSetName(uvs): string
    properties: create
    Name of the UV set to be created

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyLayoutUV.html 
    """


def polyListComponentConversion(flagborder: boolean, flagfromEdge: boolean, flagfromFace: boolean, flagfromUV: boolean, flagfromVertex: boolean, flagfromVertexFace: boolean, flaginternal: boolean, flagtoEdge: boolean, flagtoFace: boolean, flagtoUV: boolean, flagtoVertex: boolean, flagtoVertexFace: boolean, flaguvShell: boolean, flagvertexFaceAllEdges: boolean) -> selectionItem[]:
    """Synopsis:
---
---
 polyListComponentConversion(
selectionItem[]
    , [border=boolean], [fromEdge=boolean], [fromFace=boolean], [fromUV=boolean], [fromVertex=boolean], [fromVertexFace=boolean], [internal=boolean], [toEdge=boolean], [toFace=boolean], [toUV=boolean], [toVertex=boolean], [toVertexFace=boolean], [uvShell=boolean], [vertexFaceAllEdges=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyListComponentConversion is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

Convert the vertices to envolved poly face(s) and list results.
cmds.polyListComponentConversion( 'plg.vtx[5:6]', 'plg.vtx[9:10]', fv=True, tf=True, internal=True )
Result: plg.f[4] ---


Convert anything to related poly face(s) and list results.
cmds.polyListComponentConversion( 'plg.vtx[0]', 'plg.vtx[3]', 'plg.vtx[8]', tf=True )
Result: plg.f[0] plg.f[2] plg.f[3] plg.f[6] ---


Convert an object to faces and list results.
cmds.polyListComponentConversion( 'plg', tf=True )
Result: plg.f[*] ---


Convert vertices to faces on selectionList and list results.
cmds.select( 'plg.vtx[0]', 'plg.vtx[3]', 'plg.vtx[8]', r=True )
cmds.polyListComponentConversion( fv=True, tf=True )
Result: plg.f[0] plg.f[2] plg.f[3] plg.f[6] ---


Use several calls of the command to list edges in the order
in which they appear in a face.
cmds.polyPlane( w=1, h=1, sx=1, sy=1 )
Will return the edges in numeric order:
cmds.polyListComponentConversion( 'pPlane1.f[0]', ff=True, te=True )
Result: pPlane1.e[0:3]
Now convert to vertexFace and then to edge to get the edges in the order they
appear within the face:
vfList = cmds.polyListComponentConversion( 'pPlane1.f[0]', ff=True, tvf=True )
vfList = cmds.ls( vfList, flatten=True )
Result: pPlane1.vtxFace[0][0] pPlane1.vtxFace[1][0] pPlane1.vtxFace[3][0] pPlane1.vtxFace[2][0]
for vf in vfList:
        edge = cmds.polyListComponentConversion( vf, fvf=True, te=True )
        print edge
Prints out the edges in the order they show up in the face.
pPlane1.e[0]
pPlane1.e[2]
pPlane1.e[3]
pPlane1.e[1]

Illustrate the vertexFaceAllEdges flag
cmds.polyPlane( w=1, h=1, sx=1, sy=1 )
cmds.select( 'pPlane1.vtxFace[0][0]', r=True )
Get the edge that originates at the selected face vertex
print cmds.polyListComponentConversion( fvf=True, te=True )
Result: pPlane1.e[0]
Get both edges that adjoin the selected face vertex
print cmds.polyListComponentConversion( fvf=True, te=True, vfa=True )
Result: pPlane1.e[0:1]

---
Return:
---


    selectionItem[]: List of poly components

Flags:
---


---
border(bo): boolean
    properties: create
    Indicates that the converted components must
be on the border of the selection. If it is not provided, the
converted components will be the related ones.

---
fromVertexFace(fvf): boolean
    properties: create
    Indicates the component type to convert from.
If none of them is provided, it is assumed to be
all of them, including poly objects.

---
internal(internal): boolean
    properties: create
    Indicates that the converted components must
be totally envolved by the source components. E.g.
a converted face must have all of its surrounding
vertices being given. If it is not provided, the
converted components will be the related ones.

---
toVertexFace(tvf): boolean
    properties: create
    Indicates the component type to convert to.
If none of them is provided, it is assumed to
the object.

---
uvShell(uvs): boolean
    properties: create
    Will return UV components within the same UV shell. Only works with -tuv and -fuv flags.

---
vertexFaceAllEdges(vfa): boolean
    properties: create
    When converting from face vertices to edges, indicates
that all edges with an end at the face vertex should be included.
Without this flag, the default behaviour is to only include
one edge per face vertex.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyListComponentConversion.html 
    """


def polyMapCut(flagcaching: boolean, flagconstructionHistory: boolean, flagmoveratio: float, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyMapCut([caching=boolean], [constructionHistory=boolean], [moveratio=float], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMapCut is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Opening up the textureView will make this example much easier to visualize.

Create a plane and select it.
cmds.polyPlane( n='plg', sx=5, sy=5, w=10, h=10 )
cmds.select( 'plg' )

Display map borders.
cmds.polyOptions( ao=True, dmb=True )

Cut the map.
cmds.polyMapCut( 'plg.e[44]', 'plg.e[46]', 'plg.e[48]', 'plg.e[50]', 'plg.e[52]' )
now that it's cut, we may move the row separately

Move some UVs
cmds.polyMoveUV('plg.map[24:28]', 'plg.map[30:35]', 'plg.map[37]', tv=0.3 )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
moveratio(mvr): float
    properties: query, edit
    Cut open ratio related to the neighbor edge length of cut edge.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMapCut.html 
    """


def polyMapDel(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyMapDel([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMapDel is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a plane.
cmds.polyPlane( n='plg', sx=5, sy=5, w=20, h=20 )

Delete the mapping from the given faces.
cmds.polyMapDel( 'plg.f[11:13]', 'plg.f[16:18]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMapDel.html 
    """


def polyMapSew(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyMapSew([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMapSew is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Opening the texture view will make this example much clearer.

Create a plane and select it.
cmds.polyPlane( n='plg', sx=5, sy=5, w=10, h=10 )
cmds.select( 'plg' )

Display map borders.
cmds.polyOptions( ao=True, dmb=True )

Cut the map.
cmds.polyMapCut( 'plg.e[44]', 'plg.e[46]', 'plg.e[48]', 'plg.e[50]', 'plg.e[52]' )

Move the row
cmds.polyMoveUV( 'plg.map[24:28]', 'plg.map[30:35]', 'plg.map[37]', t=(0.0, 0.5 ))

Now sew some border edges
cmds.polyMapSew( 'plg.e[44]', 'plg.e[46]', 'plg.e[48]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMapSew.html 
    """


def polyMapSewMove(flagcaching: boolean, flagconstructionHistory: boolean, flaglimitPieceSize: boolean, flagname: string, flagnodeState: int, flagnumberFaces: int, flaguvSetName: string, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyMapSewMove([caching=boolean], [constructionHistory=boolean], [limitPieceSize=boolean], [name=string], [nodeState=int], [numberFaces=int], [uvSetName=string], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMapSewMove is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Build a plane
cmds.polyPlane()

Map and move some faces. Scale them so that seams do not mathc any more
cmds.select( 'pPlane1.f[0:49]', r=True )
cmds.polyProjection( type='Planar' )
cmds.setAttr( 'polyPlanarProj1.rotateX', -90 )
cmds.setAttr( 'polyPlanarProj1.imageCenter', 0.630609, 0.38805)
cmds.setAttr( 'polyPlanarProj1.rotationAngle', 10 )
cmds.setAttr( 'polyPlanarProj1.imageScaleU', 1.2 )
cmds.setAttr( 'polyPlanarProj1.imageScaleV', 1.2 )

Select the seams
cmds.select( 'pPlane1.e[105]', 'pPlane1.e[107]', 'pPlane1.e[109]', 'pPlane1.e[111]', 'pPlane1.e[113]', 'pPlane1.e[115]', 'pPlane1.e[117]', 'pPlane1.e[119]', 'pPlane1.e[121]', 'pPlane1.e[123]' )
merge them back, with the appropriate move.
cmds.polyMapSewMove()

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
limitPieceSize(lps): boolean
    properties: create, query, edit
    When on, this flag specifies that the face number limit
described above should be used.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
numberFaces(nf): int
    properties: create, query, edit
    Maximum number of faces in a UV piece. When trying to
combine two UV pieces into a single one, the merge operation is
rejected if the smaller piece has more faces than the number specified
by this flag.
This flag is only used when limitPieceSize is set to on.

---
uvSetName(uvs): string
    properties: create
    Name of the UV set to be created

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMapSewMove.html 
    """


def polyMergeEdge(flagcaching: boolean, flagconstructionHistory: boolean, flagfirstEdge: int, flagmergeMode: int, flagmergeTexture: boolean, flagname: string, flagnodeState: int, flagsecondEdge: int) -> string:
    """Synopsis:
---
---
 polyMergeEdge([caching=boolean], [constructionHistory=boolean], [firstEdge=int], [mergeMode=int], [mergeTexture=boolean], [name=string], [nodeState=int], [secondEdge=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMergeEdge is undoable, queryable, and editable.
Both edges must belong to the same object, and orientations must match
(i.e. normals on corresponding faces must point in the same direction).
Edge flags are mandatory.




Example:
---
import maya.cmds as cmds

cmds.polyPlane( sx=3, sy=3, n='plg1' )
cmds.move( -2, 0, 0, 'plg1' )
cmds.delete( 'plg1.f[3:5]' )
cmds.polyPlane( sx=3, sy=3, n='plg2' )
cmds.delete( 'plg2.f[3:5]' )
cmds.polyPlane( sx=3, sy=3, n='plg3' )
cmds.move( 2, 0, 0, 'plg3' )
cmds.delete( 'plg3.f[3:5]' )

First
cmds.polyMergeEdge( 'plg1', mm=0, fe=8, se=12 )

Between
cmds.polyMergeEdge( 'plg2', mm=1, fe=8, se=12 )

Last
cmds.polyMergeEdge( 'plg3', mm=2, fe=8, se=12 )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
firstEdge(fe): int
    properties: create, query, edit
    First edge to merge.
Invalid default value to force the value to be set.
Default: -1

---
mergeMode(mm): int
    properties: create, query, edit
    Merge mode : 0=first, 1=halfway between both edges, 2=second.
Default: 1

---
mergeTexture(mt): boolean
    properties: create, query, edit
    Boolean which is used to decide if uv coordinates should be
merged or not - along with the geometry.
Default: false

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
secondEdge(se): int
    properties: create, query, edit
    Second edge to merge.
Invalid default value to force the value to be set.
Default: -1

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMergeEdge.html 
    """


def polyMergeEdgeCtx(flagactiveNodes: boolean, flagcaching: boolean, flagconstructionHistory: boolean, flagexists: boolean, flagfirstEdge: int, flagimage1: string, flagimage2: string, flagimage3: string, flagimmediate: boolean, flagmergeMode: int, flagmergeTexture: boolean, flagname: string, flagnodeState: int, flagprevious: boolean, flagreset: boolean, flagsecondEdge: int, flagtoolNode: boolean) -> string:
    """Synopsis:
---
---
 polyMergeEdgeCtx([activeNodes=boolean], [caching=boolean], [constructionHistory=boolean], [exists=boolean], [firstEdge=int], [image1=string], [image2=string], [image3=string], [immediate=boolean], [mergeMode=int], [mergeTexture=boolean], [name=string], [nodeState=int], [previous=boolean], [reset=boolean], [secondEdge=int], [toolNode=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMergeEdgeCtx is undoable, queryable, and editable.
Both edges must belong to the same object, and orientations must match
(i.e. normals on corresponding faces must point in the same direction).
Edge flags are mandatory.

Create a new context to merge edges on polygonal objects




Example:
---
import maya.cmds as cmds

cmds.polyPlane( sx=3, sy=3, n='plg1' )
cmds.move( -2, 0, 0, 'plg1' )
cmds.delete( 'plg1.f[3:5]' )
cmds.polyPlane( sx=3, sy=3, n='plg2' )
cmds.delete( 'plg2.f[3:5]' )
cmds.polyPlane( sx=3, sy=3, n='plg3' )
cmds.move( 2, 0, 0, 'plg3' )
cmds.delete( 'plg3.f[3:5]' )

First
cmds.polyMergeEdge( 'plg1', mm=0, fe=8, se=12 )

Between
cmds.polyMergeEdge( 'plg2', mm=1, fe=8, se=12 )

Last
cmds.polyMergeEdge( 'plg3', mm=2, fe=8, se=12 )

Create a poly plane
cmds.polyPlane(w=10, h=10, sx=10, sy=10, n='pPlane1')

Create a new poly merge edge context, set to use first selected edge as the new edge, then switch to it
cmds.polyMergeEdgeCtx('polyMergeEdgeCtx1', mm=0)
cmds.setToolTo('polyMergeEdgeCtx1')

---
Return:
---


    string: The node name.

Flags:
---


---
activeNodes(anq): boolean
    properties: query
    Return the active nodes in the tool

---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
immediate(im): boolean
    properties: edit
    Acts on the object not the tool defaults

---
name(n): string
    properties: create
    If this is a tool command, name the tool appropriately.

---
previous(pv): boolean
    properties: edit
    Reset to previously stored values

---
reset(rs): boolean
    properties: edit
    Reset to default values

---
toolNode(tnq): boolean
    properties: query
    Return the node used for tool defaults

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
firstEdge(fe): int
    properties: create, query, edit
    First edge to merge.
Invalid default value to force the value to be set.
Default: -1

---
mergeMode(mm): int
    properties: create, query, edit
    Merge mode : 0=first, 1=halfway between both edges, 2=second.
Default: 1

---
mergeTexture(mt): boolean
    properties: create, query, edit
    Boolean which is used to decide if uv coordinates should be
merged or not - along with the geometry.
Default: false

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
secondEdge(se): int
    properties: create, query, edit
    Second edge to merge.
Invalid default value to force the value to be set.
Default: -1

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMergeEdgeCtx.html 
    """


def polyMergeFacet(flagcaching: boolean, flagconstructionHistory: boolean, flagfirstFacet: int, flagmergeMode: int, flagname: string, flagnodeState: int, flagsecondFacet: int) -> string:
    """Synopsis:
---
---
 polyMergeFacet([caching=boolean], [constructionHistory=boolean], [firstFacet=int], [mergeMode=int], [name=string], [nodeState=int], [secondFacet=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMergeFacet is undoable, queryable, and editable.
Both faces must belong to the same object.
Facet flags are mandatory.




Example:
---
import maya.cmds as cmds

cmds.polyPlane( n='plg', h=10, w=10, sx=5, sy=5 )
cmds.polyChipOff( 'plg.f[16]', 'plg.f[18]', 'plg.f[7]', dup=1, ltz=1, ls=(.5, .5, .5) )

First
cmds.polyMergeFacet( 'plg', mm=0, ff=16, sf=26 )
A new face with face ---
16 as an outer loop and face ---
26 as a hole
is replacing faces ---
16 and ---
26, and is located on face ---
16

Between
cmds.polyMergeFacet( 'plg', mm=1, ff=7, sf=25 )
A new face with face ---
7 as an outer loop and face ---
25 as a hole
is replacing faces ---
7 and ---
25, and is located in between.

Last
cmds.polyMergeFacet( 'plg', mm=2, ff=18, sf=25 )
A new face with face ---
18 as an outer loop and face ---
25 as a hole
is replacing faces ---
18 and ---
25, and is located on face ---
25

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
firstFacet(ff): int
    properties: create, query, edit
    The number of the first (outer) face to merge.

---
mergeMode(mm): int
    properties: create, query, edit
    This flag specifies how faces are merged:
0: moves second face to first one
1: moves both faces to average
2: moves first face to second one
3, 4, 5: same as above, except faces are projected but not centred
6: Nothing moves.
C: Default is None (6).

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
secondFacet(sf): int
    properties: create, query, edit
    The number of the second (hole) face to merge.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMergeFacet.html 
    """


def polyMergeFacetCtx(flagactiveNodes: boolean, flagcaching: boolean, flagconstructionHistory: boolean, flagexists: boolean, flagfirstFacet: int, flagimage1: string, flagimage2: string, flagimage3: string, flagimmediate: boolean, flagmergeMode: int, flagname: string, flagnodeState: int, flagprevious: boolean, flagreset: boolean, flagsecondFacet: int, flagtoolNode: boolean) -> string:
    """Synopsis:
---
---
 polyMergeFacetCtx([activeNodes=boolean], [caching=boolean], [constructionHistory=boolean], [exists=boolean], [firstFacet=int], [image1=string], [image2=string], [image3=string], [immediate=boolean], [mergeMode=int], [name=string], [nodeState=int], [previous=boolean], [reset=boolean], [secondFacet=int], [toolNode=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMergeFacetCtx is undoable, queryable, and editable.
Both faces must belong to the same object.
Facet flags are mandatory.

Create a new context to merge facets on polygonal objects




Example:
---
import maya.cmds as cmds

cmds.polyPlane( n='plg', h=10, w=10, sx=5, sy=5 )
cmds.polyChipOff( 'plg.f[16]', 'plg.f[18]', 'plg.f[7]', dup=1, ltz=1, ls=(.5, .5, .5) )

First
cmds.polyMergeFacet( 'plg', mm=0, ff=16, sf=26 )
A new face with face ---
16 as an outer loop and face ---
26 as a hole
is replacing faces ---
16 and ---
26, and is located on face ---
16

Between
cmds.polyMergeFacet( 'plg', mm=1, ff=7, sf=25 )
A new face with face ---
7 as an outer loop and face ---
25 as a hole
is replacing faces ---
7 and ---
25, and is located in between.

Last
cmds.polyMergeFacet( 'plg', mm=2, ff=18, sf=25 )
A new face with face ---
18 as an outer loop and face ---
25 as a hole
is replacing faces ---
18 and ---
25, and is located on face ---
25

Create a poly plane
cmds.polyPlane(w=10, h=10, sx=10, sy=10, n='pPlane1')

Create a new poly merge facet context, set the merge mode to merging the second face to the first face, then switch to it
cmds.polyMergeFacetCtx('polyMergeFacetCtx1', mm=0)
cmds.setToolTo('polyMergeFacetCtx1')

---
Return:
---


    string: The node name.

Flags:
---


---
activeNodes(anq): boolean
    properties: query
    Return the active nodes in the tool

---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
immediate(im): boolean
    properties: edit
    Acts on the object not the tool defaults

---
name(n): string
    properties: create
    If this is a tool command, name the tool appropriately.

---
previous(pv): boolean
    properties: edit
    Reset to previously stored values

---
reset(rs): boolean
    properties: edit
    Reset to default values

---
toolNode(tnq): boolean
    properties: query
    Return the node used for tool defaults

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
firstFacet(ff): int
    properties: create, query, edit
    The number of the first (outer) face to merge.

---
mergeMode(mm): int
    properties: create, query, edit
    This flag specifies how faces are merged:
0: moves second face to first one
1: moves both faces to average
2: moves first face to second one
3, 4, 5: same as above, except faces are projected but not centred
6: Nothing moves.
C: Default is None (6).

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
secondFacet(sf): int
    properties: create, query, edit
    The number of the second (hole) face to merge.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMergeFacetCtx.html 
    """


def polyMergeUV(flagcaching: boolean, flagconstructionHistory: boolean, flagdistance: float, flagname: string, flagnodeState: int, flaguvSetName: string, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyMergeUV([caching=boolean], [constructionHistory=boolean], [distance=float], [name=string], [nodeState=int], [uvSetName=string], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMergeUV is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a poly cube
cmds.polyCube()
cmds.select( 'pCube1.map[4]', 'pCube1.map[13]', r=True )

Merge two UVs
cmds.polyMergeUV()

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
distance(d): float
    properties: create, query, edit
    This flag specifies the maximum distance to merge UVs.
C: Default is 0.0.
Q: When queried, this flag returns a double.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
uvSetName(uvs): string
    properties: create
    Name of the UV set to be created

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMergeUV.html 
    """


def polyMergeVertex(flagalwaysMergeTwoVertices: boolean, flagcaching: boolean, flagconstructionHistory: boolean, flagdistance: linear, flagmergeToComponents: string, flagname: string, flagnodeState: int, flagtexture: boolean, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyMergeVertex([alwaysMergeTwoVertices=boolean], [caching=boolean], [constructionHistory=boolean], [distance=linear], [mergeToComponents=string], [name=string], [nodeState=int], [texture=boolean], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMergeVertex is undoable, queryable, and editable.
First, perform comparison of pairs of selected vertices.
Pairs that lie within given distance of one another are merged,
along with the edge between them.

Second, any selected vertices which share an edge are merged if
the distance between them is within the specified distance.

Unlike Merge Edges, Merge Vertices will perform the merge even if the
edges adjoining the vertices do not have matching orientation (i.e.
normals of adjacent faces do not point in the same direction). As this
restriction is not enforced while merging vertices, resulting geometry
can be non-manifold.

If alwaysMergeTwoVertices is set and there are only two vertices, tolerance
is ignored and the vertices will be merged.

Resulting mesh may have extra vertices or edges to ensure
geometry is valid.




Example:
---
import maya.cmds as cmds

cmds.polyPlane( sx=5, sy=5, n='plg1' )
cmds.polyPlane( sx=5, sy=5, n='plg2' )
cmds.move( 0.55, 0, -1.25, 'plg1', ws=True )
cmds.move( -0.55, 0, -1.25, 'plg2', ws=True )
cmds.polyPlane( sx=5, sy=5, n='plg3' )
cmds.polyPlane( sx=5, sy=5, n='plg4' )
cmds.polyPlane( sx=5, sy=5, n='plg5' )
cmds.move( 0.55, 0, 1.25, 'plg4', ws=True )
cmds.move( -0.55, 0, 1.25, 'plg5', ws=True )

First method:
cmds.polyUnite( 'plg1Shape', 'plg2Shape' )
cmds.select( 'polySurface1.vtx[6]', 'polySurface1.vtx[12]', 'polySurface1.vtx[18]', 'polySurface1.vtx[24]', 'polySurface1.vtx[47]', 'polySurface1.vtx[53]', 'polySurface1.vtx[59]', 'polySurface1.vtx[65]', r=True )
cmds.polyMergeVertex( d=0.15 )

Second method:
cmds.polyMergeVertex( 'plg3.vtx[24]', 'plg3.vtx[30:31]', 'plg3.vtx[8:10]', 'plg3.vtx[14:16]', 'plg3.vtx[20:22]', d=0.25 )

To create non-manifold geometry:
cmds.polyUnite( 'plg4Shape', 'plg5Shape' )
cmds.select( 'polySurface2.vtx[0]', 'polySurface2.vtx[6]', 'polySurface2.vtx[12]', 'polySurface2.vtx[18]', 'polySurface2.vtx[24]', 'polySurface2.vtx[30]', 'polySurface2.vtx[41]', 'polySurface2.vtx[47]', 'polySurface2.vtx[53]', 'polySurface2.vtx[59]', 'polySurface2.vtx[65]', 'polySurface2.vtx[71]', r=True )
cmds.polyMergeVertex( d=0.25 )
Note that there is only one vertex at this merged point and the
resulting polygonal object is non-manifold;()

---
Return:
---


    string: The node name.

Flags:
---


---
alwaysMergeTwoVertices(am): boolean
    properties: create, query, edit
    This flag specifies whether to always merge if only two vertices are
selected regardless of distance.
C: Default is false.
Q: When queried, this flag returns a boolean.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
distance(d): linear
    properties: create, query, edit
    This flag specifies the distance within which vertices will be merged.
C: Default is 0.0 (i.e. vertices are coincident).
Q: When queried, this flag returns a double.

---
mergeToComponents(mtc): string
    properties: create, query, edit
    Optionally defines the position to merge all of the vertices to.  If set, the distance
flag will be ignored, and instead the center point of the set components will be
calculated and all vertices will be merged to that location.
C: Default is empty string.
Q: When queried, this flag returns a string.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
texture(tx): boolean
    properties: create, query, edit
    This flag specifies whether the texture is sewn in addition to the 3d edge
C: Default is true.
Q: When queried, this flag returns a boolean.

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMergeVertex.html 
    """


def polyMirrorFace(flagaxis: int, flagaxisDirection: int, flagcaching: boolean, flagconstructionHistory: boolean, flagdirection: int, flagmergeMode: int, flagmergeThreshold: linear, flagmergeThresholdType: int, flagmirrorAxis: int, flagmirrorPosition: linear, flagname: string, flagnodeState: int, flagpivot: tuple[linear, linear, linear], flagpivotX: linear, flagpivotY: linear, flagpivotZ: linear, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyMirrorFace([axis=int], [axisDirection=int], [caching=boolean], [constructionHistory=boolean], [direction=int], [mergeMode=int], [mergeThreshold=linear], [mergeThresholdType=int], [mirrorAxis=int], [mirrorPosition=linear], [name=string], [nodeState=int], [pivot=[linear, linear, linear]], [pivotX=linear], [pivotY=linear], [pivotZ=linear], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMirrorFace is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Mirror about +X direction by merging the border vertices
cmds.polyCube( name='poly1' )
cmds.delete( 'poly1.f[4]' )
cmds.polyMirrorFace( 'poly1', direction=0, mergeMode=1 )

Mirror about +Y direction by connecting the border edges
in world reference, by explicitly specifying a pivot point (0, 2, 0)
cmds.polyCube( name='poly2' )
cmds.delete( 'poly2.f[4]' )
cmds.rotate( 0, 0, 45, 'poly2', r=True, os=True )
cmds.polyMirrorFace( 'poly2', direction=2, p=(0, 2, 0), mergeMode=2, worldSpace=1 )

---
Return:
---


    string: The node name.

Flags:
---


---
axis(a): int
    properties: create, query, edit
    Axis to mirror the object along
Default: 0

---
axisDirection(ad): int
    properties: create, query, edit
    Direction to mirror the object along
Default: 1

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
direction(d): int
    properties: create, query, edit
    Direction to mirror the object along
Default: 0

---
mergeMode(mm): int
    properties: create, query, edit
    Merge mode to apply
Default: 1

---
mergeThreshold(mt): linear
    properties: create, query, edit
    Tolerance to determine whether vertices should
be merged.
Default: 0.001

---
mergeThresholdType(mtt): int
    properties: create, query, edit
    Merge mode to apply
Default: 0

---
mirrorAxis(ma): int
    properties: create, query, edit
    Mirror axis type selection
Default: 2

---
mirrorPosition(mps): linear
    properties: create, query, edit
    Custom mirror axis position
Default: 0.0

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
pivot(p): [linear, linear, linear]
    properties: create, query, edit
    Pivot point of the mirror plane.
Default: 0.0, 0.0, 0.0

---
pivotX(px): linear
    properties: create, query, edit
    Translation X coord.

---
pivotY(py): linear
    properties: create, query, edit
    Translation Y coord.

---
pivotZ(pz): linear
    properties: create, query, edit
    Translation Z coord.

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMirrorFace.html 
    """


def polyMoveEdge(flagcaching: boolean, flagconstructionHistory: boolean, flaggain: float, flaglocalCenter: int, flaglocalDirection: tuple[linear, linear, linear], flaglocalDirectionX: linear, flaglocalDirectionY: linear, flaglocalDirectionZ: linear, flaglocalRotate: tuple[angle, angle, angle], flaglocalRotateX: angle, flaglocalRotateY: angle, flaglocalRotateZ: angle, flaglocalScale: tuple[float, float, float], flaglocalScaleX: float, flaglocalScaleY: float, flaglocalScaleZ: float, flaglocalTranslate: tuple[linear, linear, linear], flaglocalTranslateX: linear, flaglocalTranslateY: linear, flaglocalTranslateZ: linear, flagname: string, flagnodeState: int, flagpivot: tuple[linear, linear, linear], flagpivotX: linear, flagpivotY: linear, flagpivotZ: linear, flagrandom: float, flagrotate: tuple[angle, angle, angle], flagrotateX: angle, flagrotateY: angle, flagrotateZ: angle, flagscale: tuple[float, float, float], flagscaleX: float, flagscaleY: float, flagscaleZ: float, flagtranslate: tuple[linear, linear, linear], flagtranslateX: linear, flagtranslateY: linear, flagtranslateZ: linear, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyMoveEdge([caching=boolean], [constructionHistory=boolean], [gain=float], [localCenter=int], [localDirection=[linear, linear, linear]], [localDirectionX=linear], [localDirectionY=linear], [localDirectionZ=linear], [localRotate=[angle, angle, angle]], [localRotateX=angle], [localRotateY=angle], [localRotateZ=angle], [localScale=[float, float, float]], [localScaleX=float], [localScaleY=float], [localScaleZ=float], [localTranslate=[linear, linear, linear]], [localTranslateX=linear], [localTranslateY=linear], [localTranslateZ=linear], [name=string], [nodeState=int], [pivot=[linear, linear, linear]], [pivotX=linear], [pivotY=linear], [pivotZ=linear], [random=float], [rotate=[angle, angle, angle]], [rotateX=angle], [rotateY=angle], [rotateZ=angle], [scale=[float, float, float]], [scaleX=float], [scaleY=float], [scaleZ=float], [translate=[linear, linear, linear]], [translateX=linear], [translateY=linear], [translateZ=linear], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMoveEdge is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a sphere.
cmds.polySphere( n='plg', r=5 )

cmds.select( 'plg.e[200:219]', 'plg.e[560:599]' )
Translate selected edges along Z in local coordinates.
cmds.polyMoveEdge( ltz=1.0 )

Scale selected edges by (0.5 0.5 0.5)
cmds.polyMoveEdge( 'plg.e[100:119]', s=(0.5, 0.5, 0.5) )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
gain(ga): float
    properties: create, query, edit, multiuse
    Gain factor per component. Can be painted using Artisan.
Default: 1.0

---
localCenter(lc): int
    properties: create, query, edit
    Local center on the edge : 0=Middle point, 1=Start point, 2=End point.
Default: 0

---
localDirection(ld): [linear, linear, linear]
    properties: create, query, edit
    Direction to determine X axis for local space.
Default: 1.0, 0.0, 0.0

---
localDirectionX(ldx): linear
    properties: create, query, edit
    X coord of the X axis.

---
localDirectionY(ldy): linear
    properties: create, query, edit
    Y coord of the X axis.

---
localDirectionZ(ldz): linear
    properties: create, query, edit
    Z coord of the X axis.

---
localRotate(lr): [angle, angle, angle]
    properties: create, query, edit
    The local rotations.
Default: 0.0, 0.0, 0.0

---
localRotateX(lrx): angle
    properties: create, query, edit
    Local rotate X coord.
The range is [0, 360].

---
localRotateY(lry): angle
    properties: create, query, edit
    Local rotate Y coord.
The range is [0, 360].

---
localRotateZ(lrz): angle
    properties: create, query, edit
    Local rotate Z coord : Rotation along the normal.
The range is [0, 360].

---
localScale(ls): [float, float, float]
    properties: create, query, edit
    Local Scale.
Default: 1.0, 1.0, 1.0

---
localScaleX(lsx): float
    properties: create, query, edit
    Scale X coord.

---
localScaleY(lsy): float
    properties: create, query, edit
    Scale Y coord.

---
localScaleZ(lsz): float
    properties: create, query, edit
    Scale Z coord.

---
localTranslate(lt): [linear, linear, linear]
    properties: create, query, edit
    Local translate.
Default: 0.0, 0.0, 0.0

---
localTranslateX(ltx): linear
    properties: create, query, edit
    Local translation X coord.

---
localTranslateY(lty): linear
    properties: create, query, edit
    Local translation Y coord.

---
localTranslateZ(ltz): linear
    properties: create, query, edit
    Local translation Z coord : Move along the normal.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
pivot(pvt): [linear, linear, linear]
    properties: create, query, edit
    The pivot for scaling and rotation.
Default: 0.0, 0.0, 0.0

---
pivotX(pvx): linear
    properties: create, query, edit
    Pivot X coord.

---
pivotY(pvy): linear
    properties: create, query, edit
    Pivot Y coord.

---
pivotZ(pvz): linear
    properties: create, query, edit
    Pivot Z coord.

---
random(ran): float
    properties: create, query, edit
    Random value for all parameters.
Default: 0.0

---
rotate(ro): [angle, angle, angle]
    properties: create, query, edit
    Rotation angles around X, Y, Z.
Default: 0.0, 0.0, 0.0

---
rotateX(rx): angle
    properties: create, query, edit
    Rotation angle around X.

---
rotateY(ry): angle
    properties: create, query, edit
    Rotation angle around Y.

---
rotateZ(rz): angle
    properties: create, query, edit
    Rotation angle around Z.

---
scale(s): [float, float, float]
    properties: create, query, edit
    Scaling vector.
Default: 1.0, 1.0, 1.0

---
scaleX(sx): float
    properties: create, query, edit
    Scale X coord.

---
scaleY(sy): float
    properties: create, query, edit
    Scale Y coord.

---
scaleZ(sz): float
    properties: create, query, edit
    Scale Z coord.

---
translate(t): [linear, linear, linear]
    properties: create, query, edit
    Translation vector.
Default: 0.0, 0.0, 0.0

---
translateX(tx): linear
    properties: create, query, edit
    Translation X coord.

---
translateY(ty): linear
    properties: create, query, edit
    Translation Y coord.

---
translateZ(tz): linear
    properties: create, query, edit
    Translation Z coord.

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMoveEdge.html 
    """


def polyMoveFacet(flagattraction: float, flagcaching: boolean, flagconstructionHistory: boolean, flaggain: float, flaggravity: tuple[linear, linear, linear], flaggravityX: linear, flaggravityY: linear, flaggravityZ: linear, flaglocalCenter: int, flaglocalDirection: tuple[linear, linear, linear], flaglocalDirectionX: linear, flaglocalDirectionY: linear, flaglocalDirectionZ: linear, flaglocalRotate: tuple[angle, angle, angle], flaglocalRotateX: angle, flaglocalRotateY: angle, flaglocalRotateZ: angle, flaglocalScale: tuple[float, float, float], flaglocalScaleX: float, flaglocalScaleY: float, flaglocalScaleZ: float, flaglocalTranslate: tuple[linear, linear, linear], flaglocalTranslateX: linear, flaglocalTranslateY: linear, flaglocalTranslateZ: linear, flagmagnX: linear, flagmagnY: linear, flagmagnZ: linear, flagmagnet: tuple[linear, linear, linear], flagname: string, flagnodeState: int, flagoffset: float, flagpivot: tuple[linear, linear, linear], flagpivotX: linear, flagpivotY: linear, flagpivotZ: linear, flagrandom: float, flagrotate: tuple[angle, angle, angle], flagrotateX: angle, flagrotateY: angle, flagrotateZ: angle, flagscale: tuple[float, float, float], flagscaleX: float, flagscaleY: float, flagscaleZ: float, flagtranslate: tuple[linear, linear, linear], flagtranslateX: linear, flagtranslateY: linear, flagtranslateZ: linear, flagweight: float, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyMoveFacet([attraction=float], [caching=boolean], [constructionHistory=boolean], [gain=float], [gravity=[linear, linear, linear]], [gravityX=linear], [gravityY=linear], [gravityZ=linear], [localCenter=int], [localDirection=[linear, linear, linear]], [localDirectionX=linear], [localDirectionY=linear], [localDirectionZ=linear], [localRotate=[angle, angle, angle]], [localRotateX=angle], [localRotateY=angle], [localRotateZ=angle], [localScale=[float, float, float]], [localScaleX=float], [localScaleY=float], [localScaleZ=float], [localTranslate=[linear, linear, linear]], [localTranslateX=linear], [localTranslateY=linear], [localTranslateZ=linear], [magnX=linear], [magnY=linear], [magnZ=linear], [magnet=[linear, linear, linear]], [name=string], [nodeState=int], [offset=float], [pivot=[linear, linear, linear]], [pivotX=linear], [pivotY=linear], [pivotZ=linear], [random=float], [rotate=[angle, angle, angle]], [rotateX=angle], [rotateY=angle], [rotateZ=angle], [scale=[float, float, float]], [scaleX=float], [scaleY=float], [scaleZ=float], [translate=[linear, linear, linear]], [translateX=linear], [translateY=linear], [translateZ=linear], [weight=float], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMoveFacet is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a sphere.
cmds.polySphere( n='plg', r=5 )

Translate selected facets along Y by 1.0 in world coordinates
cmds.polyMoveFacet( 'plg.f[300:359]', 'plg.f[380:399]', ty=1.0 )

Scale selected facets by (0.5, 0.5, 0.5);
cmds.polyMoveFacet( 'plg.f[0:59]', 'plg.f[360:379]', sx=0.5, sy=0.5, sz=0.5 )

---
Return:
---


    string: The node name.

Flags:
---


---
attraction(att): float
    properties: create, query, edit
    Attraction, related to magnet.
The range is [-2.0, 2.0].
Default: 0.0

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
gain(ga): float
    properties: create, query, edit, multiuse
    Gain factor per component. Can be painted using Artisan.
Default: 1.0

---
gravity(g): [linear, linear, linear]
    properties: create, query, edit
    The gravity vector.
Default: 0.0, -1.0, 0.0

---
gravityX(gx): linear
    properties: create, query, edit
    Gravity X coord.

---
gravityY(gy): linear
    properties: create, query, edit
    Gravity Y coord.

---
gravityZ(gz): linear
    properties: create, query, edit
    Gravity Z coord.

---
localCenter(lc): int
    properties: create, query, edit
    Local center on the edge : 0=Middle point, 1=Start point, 2=End point.
Default: 0

---
localDirection(ld): [linear, linear, linear]
    properties: create, query, edit
    Direction to determine X axis for local space.
Default: 1.0, 0.0, 0.0

---
localDirectionX(ldx): linear
    properties: create, query, edit
    X coord of the X axis.

---
localDirectionY(ldy): linear
    properties: create, query, edit
    Y coord of the X axis.

---
localDirectionZ(ldz): linear
    properties: create, query, edit
    Z coord of the X axis.

---
localRotate(lr): [angle, angle, angle]
    properties: create, query, edit
    The local rotations.
Default: 0.0, 0.0, 0.0

---
localRotateX(lrx): angle
    properties: create, query, edit
    Local rotate X coord.
The range is [0, 360].

---
localRotateY(lry): angle
    properties: create, query, edit
    Local rotate Y coord.
The range is [0, 360].

---
localRotateZ(lrz): angle
    properties: create, query, edit
    Local rotate Z coord : Rotation along the normal.
The range is [0, 360].

---
localScale(ls): [float, float, float]
    properties: create, query, edit
    Local Scale.
Default: 1.0, 1.0, 1.0

---
localScaleX(lsx): float
    properties: create, query, edit
    Scale X coord.

---
localScaleY(lsy): float
    properties: create, query, edit
    Scale Y coord.

---
localScaleZ(lsz): float
    properties: create, query, edit
    Scale Z coord.

---
localTranslate(lt): [linear, linear, linear]
    properties: create, query, edit
    Local translate.
Default: 0.0, 0.0, 0.0

---
localTranslateX(ltx): linear
    properties: create, query, edit
    Local translation X coord.

---
localTranslateY(lty): linear
    properties: create, query, edit
    Local translation Y coord.

---
localTranslateZ(ltz): linear
    properties: create, query, edit
    Local translation Z coord : Move along the normal.

---
magnX(mx): linear
    properties: create, query, edit
    Magnet X coord.

---
magnY(my): linear
    properties: create, query, edit
    Magnet Y coord.

---
magnZ(mz): linear
    properties: create, query, edit
    Magnet Z coord.

---
magnet(m): [linear, linear, linear]
    properties: create, query, edit
    The magnet vector.
Default: 0.0, 0.0, 0.0

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
offset(off): float
    properties: create, query, edit
    Local offset. Faces are moved this distance towards the inside of the face.
Default: 0.0

---
pivot(pvt): [linear, linear, linear]
    properties: create, query, edit
    The pivot for scaling and rotation.
Default: 0.0, 0.0, 0.0

---
pivotX(pvx): linear
    properties: create, query, edit
    Pivot X coord.

---
pivotY(pvy): linear
    properties: create, query, edit
    Pivot Y coord.

---
pivotZ(pvz): linear
    properties: create, query, edit
    Pivot Z coord.

---
random(ran): float
    properties: create, query, edit
    Random value for all parameters.
Default: 0.0

---
rotate(ro): [angle, angle, angle]
    properties: create, query, edit
    Rotation angles around X, Y, Z.
Default: 0.0, 0.0, 0.0

---
rotateX(rx): angle
    properties: create, query, edit
    Rotation angle around X.

---
rotateY(ry): angle
    properties: create, query, edit
    Rotation angle around Y.

---
rotateZ(rz): angle
    properties: create, query, edit
    Rotation angle around Z.

---
scale(s): [float, float, float]
    properties: create, query, edit
    Scaling vector.
Default: 1.0, 1.0, 1.0

---
scaleX(sx): float
    properties: create, query, edit
    Scale X coord.

---
scaleY(sy): float
    properties: create, query, edit
    Scale Y coord.

---
scaleZ(sz): float
    properties: create, query, edit
    Scale Z coord.

---
translate(t): [linear, linear, linear]
    properties: create, query, edit
    Translation vector.
Default: 0.0, 0.0, 0.0

---
translateX(tx): linear
    properties: create, query, edit
    Translation X coord.

---
translateY(ty): linear
    properties: create, query, edit
    Translation Y coord.

---
translateZ(tz): linear
    properties: create, query, edit
    Translation Z coord.

---
weight(w): float
    properties: create, query, edit
    The weight, related to gravity.
Default: 0.0

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMoveFacet.html 
    """


def polyMoveFacetUV(flagaxisLen: tuple[float, float], flagaxisLenX: float, flagaxisLenY: float, flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int, flagpivot: tuple[float, float], flagpivotU: float, flagpivotV: float, flagrandom: float, flagrotationAngle: angle, flagscale: tuple[float, float], flagscaleU: float, flagscaleV: float, flagtranslate: tuple[float, float], flagtranslateU: float, flagtranslateV: float) -> string:
    """Synopsis:
---
---
 polyMoveFacetUV([axisLen=[float, float]], [axisLenX=float], [axisLenY=float], [caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int], [pivot=[float, float]], [pivotU=float], [pivotV=float], [random=float], [rotationAngle=angle], [scale=[float, float]], [scaleU=float], [scaleV=float], [translate=[float, float]], [translateU=float], [translateV=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMoveFacetUV is undoable, queryable, and editable.
The UV coordinates of the model are manipulated without
changing the vertices of the 3D object.




Example:
---
import maya.cmds as cmds

Opening up the textureView will make this example easier to visualize.

Create a plane and select it.
cmds.polyPlane( n='plg', sx=5, sy=5, w=10, h=10 )
cmds.select( 'plg' )

Display map borders.
cmds.polyOptions( ao=True, dmb=True )

Translate selected UVs as the vector (0.0, 1.0).
cmds.polyMoveFacetUV( 'plgShape.map[30:35]', tu=0.0, tv=1.0 )

Scale selected UVs as the scaling (0.5, 0.5);
cmds.polyMoveFacetUV( 'plgShape.map[30:35]', su=0.5, sv=0.5 )

---
Return:
---


    string: The node name.

Flags:
---


---
axisLen(l): [float, float]
    properties: create, query, edit
    Axis Length vector, used to draw the manip handles.
C: Default is 1.0, 1.0
Q: When queried, this flag returns a float[2].

---
axisLenX(lx): float
    properties: create, query, edit
    Axis Length in X, used to draw the manip handles.
C: Default is 1.0
Q: When queried, this flag returns a float.

---
axisLenY(ly): float
    properties: create, query, edit
    Axis Length in Y, used to draw the manip handles.
C: Default is 1.0
Q: When queried, this flag returns a float.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
pivot(pvt): [float, float]
    properties: create, query, edit
    This flag specifies the pivot for scaling and rotation.
C: Default is 0.0 0.0.
Q: When queried, this flag returns a float[2].

---
pivotU(pvu): float
    properties: create, query, edit
    This flag specifies U for the pivot for scaling and rotation.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
pivotV(pvv): float
    properties: create, query, edit
    This flag specifies V for the pivot for scaling and rotation.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
random(ran): float
    properties: create, query, edit
    This flag specifies the random value for all parameters.
C: Default is 0.0. The range is [-10.0, 10.0].
Q: When queried, this flag returns a float.

---
rotationAngle(ra): angle
    properties: create, query, edit
    Angle of rotation.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
scale(s): [float, float]
    properties: create, query, edit
    This flag specifies the scaling vector.
C: Default is 1.0 1.0.
Q: When queried, this flag returns a float.

---
scaleU(su): float
    properties: create, query, edit
    This flag specifies U for the scaling vector.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
scaleV(sv): float
    properties: create, query, edit
    This flag specifies V for the scaling vector.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
translate(t): [float, float]
    properties: create, query, edit
    This flag specifies the translation vector.
C: Default is 0.0 0.0.
Q: When queried, this flag returns a float[2].

---
translateU(tu): float
    properties: create, query, edit
    This flag specifies the U translation vector.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
translateV(tv): float
    properties: create, query, edit
    This flag specifies the V translation vector.
C: Default is 0.0.
Q: When queried, this flag returns a float.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMoveFacetUV.html 
    """


def polyMoveUV(flagaxisLen: tuple[float, float], flagaxisLenX: float, flagaxisLenY: float, flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int, flagpivot: tuple[float, float], flagpivotU: float, flagpivotV: float, flagrandom: float, flagrotationAngle: angle, flagscale: tuple[float, float], flagscaleU: float, flagscaleV: float, flagtranslate: tuple[float, float], flagtranslateU: float, flagtranslateV: float) -> string:
    """Synopsis:
---
---
 polyMoveUV([axisLen=[float, float]], [axisLenX=float], [axisLenY=float], [caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int], [pivot=[float, float]], [pivotU=float], [pivotV=float], [random=float], [rotationAngle=angle], [scale=[float, float]], [scaleU=float], [scaleV=float], [translate=[float, float]], [translateU=float], [translateV=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMoveUV is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Opening up the textureView will make this example easier to visualize.

Create a plane and select it.
cmds.polyPlane( n='plg', sx=5, sy=5, w=10, h=10 )
cmds.select( 'plg' )

Display map borders.
cmds.polyOptions( ao=True, dmb=True )

Translate selected UVs as the vector (0.0, 1.0).
cmds.polyMoveUV( 'plgShape.map[30:35]', tu=0.0, tv=1.0 )

Scale selected UVs as the scaling (0.5, 0.5);
cmds.polyMoveUV( 'plgShape.map[30:35]', su=0.5, sv=0.5 )

---
Return:
---


    string: The node name.

Flags:
---


---
axisLen(l): [float, float]
    properties: create, query, edit
    AxisLen vector, used to draw the manip handles.
Default: 1.0, 1.0

---
axisLenX(lx): float
    properties: create, query, edit
    AxisLen X coord.

---
axisLenY(ly): float
    properties: create, query, edit
    AxisLen Y coord.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
pivot(pvt): [float, float]
    properties: create, query, edit
    The pivot for scaling and rotation.
Default: 0.5, 0.5

---
pivotU(pvu): float
    properties: create, query, edit
    Pivot U coord.

---
pivotV(pvv): float
    properties: create, query, edit
    Pivot V coord.

---
random(ran): float
    properties: create, query, edit
    Random value, added to all parameters.
Default: 0.0

---
rotationAngle(ra): angle
    properties: create, query, edit
    Angle of rotation.
Default: 0.0

---
scale(s): [float, float]
    properties: create, query, edit
    Scaling vector.
Default: 1.0, 1.0

---
scaleU(su): float
    properties: create, query, edit
    Scaling U coord.

---
scaleV(sv): float
    properties: create, query, edit
    Scaling V coord.

---
translate(t): [float, float]
    properties: create, query, edit
    Translation vector.
Default: 0.0, 0.0

---
translateU(tu): float
    properties: create, query, edit
    Translation U coord.

---
translateV(tv): float
    properties: create, query, edit
    Translation V coord.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMoveUV.html 
    """


def polyMoveVertex(flagcaching: boolean, flagconstructionHistory: boolean, flaggain: float, flaglocalDirection: tuple[linear, linear, linear], flaglocalDirectionX: linear, flaglocalDirectionY: linear, flaglocalDirectionZ: linear, flaglocalTranslate: tuple[linear, linear, linear], flaglocalTranslateX: linear, flaglocalTranslateY: linear, flaglocalTranslateZ: linear, flagname: string, flagnodeState: int, flagpivot: tuple[linear, linear, linear], flagpivotX: linear, flagpivotY: linear, flagpivotZ: linear, flagrandom: float, flagrotate: tuple[angle, angle, angle], flagrotateX: angle, flagrotateY: angle, flagrotateZ: angle, flagscale: tuple[float, float, float], flagscaleX: float, flagscaleY: float, flagscaleZ: float, flagtranslate: tuple[linear, linear, linear], flagtranslateX: linear, flagtranslateY: linear, flagtranslateZ: linear, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyMoveVertex([caching=boolean], [constructionHistory=boolean], [gain=float], [localDirection=[linear, linear, linear]], [localDirectionX=linear], [localDirectionY=linear], [localDirectionZ=linear], [localTranslate=[linear, linear, linear]], [localTranslateX=linear], [localTranslateY=linear], [localTranslateZ=linear], [name=string], [nodeState=int], [pivot=[linear, linear, linear]], [pivotX=linear], [pivotY=linear], [pivotZ=linear], [random=float], [rotate=[angle, angle, angle]], [rotateX=angle], [rotateY=angle], [rotateZ=angle], [scale=[float, float, float]], [scaleX=float], [scaleY=float], [scaleZ=float], [translate=[linear, linear, linear]], [translateX=linear], [translateY=linear], [translateZ=linear], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMoveVertex is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a sphere.
cmds.polySphere( r=5, n='plg' )

Move vertices as the scaling vector (1.0, 1.5, 1.0).
cmds.polyMoveVertex( 'plg.vtx[200:379]', 'plg.vtx[381]', s=(1.0, 1.5, 1.0) )

Translate vertices as the vector (0.0, 2.0, 0.0).
cmds.polyMoveVertex( 'plg.vtx[200:379]', 'plg.vtx[381]', ty=2.0 )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
gain(ga): float
    properties: create, query, edit, multiuse
    Gain factor per component. Can be painted using Artisan.
Default: 1.0

---
localDirection(ld): [linear, linear, linear]
    properties: create, query, edit
    Direction to determine X axis for local space.
Default: 1.0, 0.0, 0.0

---
localDirectionX(ldx): linear
    properties: create, query, edit
    X coord of the X axis.

---
localDirectionY(ldy): linear
    properties: create, query, edit
    Y coord of the X axis.

---
localDirectionZ(ldz): linear
    properties: create, query, edit
    Z coord of the X axis.

---
localTranslate(lt): [linear, linear, linear]
    properties: create, query, edit
    Local translate.
Default: 0.0, 0.0, 0.0

---
localTranslateX(ltx): linear
    properties: create, query, edit
    Local translation X coord.

---
localTranslateY(lty): linear
    properties: create, query, edit
    Local translation Y coord.

---
localTranslateZ(ltz): linear
    properties: create, query, edit
    Local translation Z coord : Move along the normal.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
pivot(pvt): [linear, linear, linear]
    properties: create, query, edit
    The pivot for scaling and rotation.
Default: 0.0, 0.0, 0.0

---
pivotX(pvx): linear
    properties: create, query, edit
    Pivot X coord.

---
pivotY(pvy): linear
    properties: create, query, edit
    Pivot Y coord.

---
pivotZ(pvz): linear
    properties: create, query, edit
    Pivot Z coord.

---
random(ran): float
    properties: create, query, edit
    Random value for all parameters.
Default: 0.0

---
rotate(ro): [angle, angle, angle]
    properties: create, query, edit
    Rotation angles around X, Y, Z.
Default: 0.0, 0.0, 0.0

---
rotateX(rx): angle
    properties: create, query, edit
    Rotation angle around X.

---
rotateY(ry): angle
    properties: create, query, edit
    Rotation angle around Y.

---
rotateZ(rz): angle
    properties: create, query, edit
    Rotation angle around Z.

---
scale(s): [float, float, float]
    properties: create, query, edit
    Scaling vector.
Default: 1.0, 1.0, 1.0

---
scaleX(sx): float
    properties: create, query, edit
    Scale X coord.

---
scaleY(sy): float
    properties: create, query, edit
    Scale Y coord.

---
scaleZ(sz): float
    properties: create, query, edit
    Scale Z coord.

---
translate(t): [linear, linear, linear]
    properties: create, query, edit
    Translation vector.
Default: 0.0, 0.0, 0.0

---
translateX(tx): linear
    properties: create, query, edit
    Translation X coord.

---
translateY(ty): linear
    properties: create, query, edit
    Translation Y coord.

---
translateZ(tz): linear
    properties: create, query, edit
    Translation Z coord.

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMoveVertex.html 
    """


def polyMultiLayoutUV(flagflipReversed: boolean, flaggridU: int, flaggridV: int, flaglayout: int, flaglayoutMethod: int, flagoffsetU: float, flagoffsetV: float, flagpercentageSpace: float, flagprescale: int, flagrotateForBestFit: int, flagscale: int, flagsizeU: float, flagsizeV: float, flaguvSetName: string) -> None:
    """Synopsis:
---
---
 polyMultiLayoutUV([flipReversed=boolean], [gridU=int], [gridV=int], [layout=int], [layoutMethod=int], [offsetU=float], [offsetV=float], [percentageSpace=float], [prescale=int], [rotateForBestFit=int], [scale=int], [sizeU=float], [sizeV=float], [uvSetName=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyMultiLayoutUV is undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

Create 3 objects with overlapping UVs
sphere = cmds.polySphere()
cylinder = cmds.polyCylinder()
torus = cmds.polyTorus()

cmds.polyAutoProjection( sphere[0], ibd=1, cm=0, l=2, sc=1, o=1, p=4, ps=0.2 )
cmds.polyAutoProjection( cylinder[0], ibd=1, cm=0, l=2, sc=1, o=1, p=4, ps=0.2 )
cmds.polyAutoProjection( torus[0], ibd=1, cm=0, l=2, sc=1, o=1, p=4, ps=0.2 )

cmds.select( sphere[0], cylinder[0], torus[0] )

Layout the UVs in a square, allow free rotations, scale uniformly
cmds.polyMultiLayoutUV( scale=1, rotateForBestFit=2, layout=2 )

---


Flags:
---


---
flipReversed(fr): boolean
    properties: create
    If this flag is turned on, the reversed UV pieces are fliped.

---
gridU(gu): int
    properties: create
    The U size of the grids.

---
gridV(gv): int
    properties: create
    The V size of the grids.

---
layout(l): int
    properties: create
    How to move the UV pieces, after cuts are applied:
0 No move is applied.
1 Layout the pieces along the U axis.
2 Layout the pieces in a square shape.
3 Layout the pieces in grids.
4 Layout the pieces in nearest regions.

---
layoutMethod(lm): int
    properties: create
    // -lm/layoutMethod     layoutMethod  integer
//      (C, E, Q) Which layout method to use:
//              0 Block Stacking.
//              1 Shape Stacking.

---
offsetU(ou): float
    properties: create
    Offset the layout in the U direction by the given value.

---
offsetV(ov): float
    properties: create
    Offset the layout in the V direction by the given value.

---
percentageSpace(ps): float
    properties: create
    When layout is set to square, this value is a percentage of
the texture area which is added around each UV piece. It can be
used to ensure each UV piece uses different pixels in the texture.
Maximum value is 5 percent.

---
prescale(psc): int
    properties: create
    Prescale the shell before laying it out.
0 No scale is applied.
1 Object space scaling applied.
2 World space scaling applied.

---
rotateForBestFit(rbf): int
    properties: create
    How to rotate the pieces, before move:
0 No rotation is applied.
1 Only allow 90 degree rotations.
2 Allow free rotations.

---
scale(sc): int
    properties: create
    How to scale the pieces, after move:
0 No scale is applied.
1 Uniform scale to fit in unit square.
2 Non proportional scale to fit in unit square.

---
sizeU(su): float
    properties: create
    Scale the layout in the U direction by the given value.

---
sizeV(sv): float
    properties: create
    Scale the layout in the V direction by the given value.

---
uvSetName(uvs): string
    properties: create
    Specifies the name of the uv set to edit uvs on. If not
specified will use the current uv set if it exists.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyMultiLayoutUV.html 
    """


def polyNormal(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int, flagnormalMode: int, flaguserNormalMode: boolean) -> string:
    """Synopsis:
---
---
 polyNormal([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int], [normalMode=int], [userNormalMode=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyNormal is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polyPlane( n='plg', w=3, h=3 )
cmds.polyOptions( ao=True, dn=True, db=True, bc=True )

---
<I>reverse and cut</I>
cmds.select( 'plg.f[40:59]' )
cmds.polyNormal( nm=3 )

---
<I>reverse and propagate</I>
cmds.polyNormal( 'plg.f[11]', nm=4 )
Notice that only the shell containing face 11 is reversed.

We can reverse all the shells by passing in the object
cmds.polyNormal( 'plg', nm=3 )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
normalMode(nm): int
    properties: create, query, edit
    Normal mode     : 0=reverse, 1=propagate, 2=conform,
3=reverseAndCut, 4=reverseAndPropagate
Default: 0

---
userNormalMode(unm): boolean
    properties: create, query, edit
    Determines if user normals needs to be reversed as well.
Default: true

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyNormal.html 
    """


def polyNormalPerVertex(flagallLocked: boolean, flagdeformable: boolean, flagfreezeNormal: boolean, flagnormalX: float, flagnormalXYZ: tuple[float, float, float], flagnormalY: float, flagnormalZ: float, flagrelative: boolean, flagunFreezeNormal: boolean) -> boolean:
    """Synopsis:
---
---
 polyNormalPerVertex([allLocked=boolean], [deformable=boolean], [freezeNormal=boolean], [normalX=float], [normalXYZ=[float, float, float]], [normalY=float], [normalZ=float], [relative=boolean], [unFreezeNormal=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyNormalPerVertex is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

To set the xyz values of normals of selected vertices:
cmds.polyNormalPerVertex( xyz=(0.2, 0.3, 0.4) )

To set just the "x" value of normal of selected vertices:
cmds.polyNormalPerVertex( x=.37 )

To add to the current value of the "y" normal value of selected vertices:
cmds.polyNormalPerVertex( rel=True, y=.13 )

To query the normal values on selected vertices - This returns all normals
regardless of whether they are shared or not:
cmds.polyNormalPerVertex( query=True, xyz=True )

To query if the normals on the selected vertices are locked or not
cmds.polyNormalPerVertex( query=True, freezeNormal=True )

To query if all the normals on the selected vertices are locked or not
cmds.polyNormalPerVertex( query=True, allLocked=True )

More examples
cmds.file( f=True, new=True )
cmds.polyCube()
cmds.select( 'pCube1.vtxFace[2][1]', r=True )
cmds.polyNormalPerVertex( query=True, freezeNormal=True )
Result: 0 ---

Now, lock the normal of a VertexFace on the cube
cmds.select('pCube1.vtxFace[2][1]', r=True )
cmds.polyNormalPerVertex( xyz=(0.7071, 0, 0.7071) )

Query if the normal is locked for this vertexFace
cmds.polyNormalPerVertex( query=True, freezeNormal=True )
Result: 1 ---


Query if the normal is locked for all the normals on this vertex
Should return 0, because there are some other normals on
this vertex that are not locked.
cmds.select('pCube1.vtx[2]', r=True)
cmds.polyNormalPerVertex( query=True, allLocked=True )
Result: 0 ---


---
Return:
---


    boolean: Success or Failure.

Flags:
---


---
allLocked(al): boolean
    properties: create, query, edit
    Queries if all normals on the selected vertices are locked (frozen) or not

---
deformable(deformable): boolean
    properties: create, query, edit
    DEFAULT  true
OBSOLETE flag. This flag will be removed in the next release.

---
freezeNormal(fn): boolean
    properties: create, query, edit
    Specifies that the normal values be frozen (locked) at the current value.

---
normalX(x): float
    properties: create, query, edit
    Specifies the x value normal

---
normalXYZ(xyz): [float, float, float]
    properties: create, query, edit, multiuse
    Specifies the xyz values normal
If this flag is used singly, the specified normal xyz values are
used for all selected components.
If the flag is used multiple times, the number of uses must match
the number of selected components, and each use specifies
the normal of one component.

---
normalY(y): float
    properties: create, query, edit
    Specifies the y value normal

---
normalZ(z): float
    properties: create, query, edit
    Specifies the z value normal

---
relative(rel): boolean
    properties: create, query, edit
    When used, the normal values specified are added relative to the current value.

---
unFreezeNormal(ufn): boolean
    properties: create, query, edit
    Specifies that the normal values that were frozen at the current value be
un-frozen (un-locked).

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyNormalPerVertex.html 
    """


def polyNormalizeUV(flagcaching: boolean, flagcenterOnTile: boolean, flagconstructionHistory: boolean, flagcreateNewMap: boolean, flaginsertBeforeDeformers: boolean, flagname: string, flagnodeState: int, flagnormalizeDirection: int, flagnormalizeType: int, flagpreserveAspectRatio: boolean, flaguvSetName: string, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyNormalizeUV([caching=boolean], [centerOnTile=boolean], [constructionHistory=boolean], [createNewMap=boolean], [insertBeforeDeformers=boolean], [name=string], [nodeState=int], [normalizeDirection=int], [normalizeType=int], [preserveAspectRatio=boolean], [uvSetName=string], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyNormalizeUV is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a poly sphere with default UVs.
cmds.polySphere( n='sph' )

rescale it
cmds.polyEditUV('sph.map[*]', pu=0.5, pv=0.5, su=1.5, sv=1.5)

normalize the UV values of all the faces
cmds.polyNormalizeUV( 'sph.f[*]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createNewMap(cm): boolean
    properties: create
    Set to true if a new map should be created

---
insertBeforeDeformers(ibd): boolean
    properties: create
    Set to true if the new node created should inserted before any deformer nodes.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
uvSetName(uvs): string
    properties: create
    Name of the UV set to be created

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

---
centerOnTile(cot): boolean
    properties: create, query, edit
    If true, will center UV's on the UV tile they are most over.
If false, will center UV's in the 0-1 region.

---
normalizeDirection(nd): int
    properties: create, query, edit
    Scale along U or V or both.


0 UV


1 U


2 V


C:  Default is 0.
Q:  When queried, returns an int.

---
normalizeType(nt): int
    properties: create, query, edit
    Options for normalize.


0 Separate


1 Collective


C:  Default is 1.
Q:  When queried, returns an int.

---
preserveAspectRatio(pa): boolean
    properties: create, query, edit
    Scale uniform along u and v.
C: Default is on.
Q: When queried, returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyNormalizeUV.html 
    """


def polyOptUvs(flagapplyToShell: boolean, flagareaWeight: float, flagcaching: boolean, flagconstructionHistory: boolean, flagglobalBlend: float, flagglobalMethodBlend: float, flagiterations: int, flagname: string, flagnodeState: int, flagoptimizeAxis: int, flagpinSelected: boolean, flagpinUvBorder: boolean, flagscale: float, flagstoppingThreshold: float, flaguseScale: boolean, flaguvSetName: string, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyOptUvs(
selectionList
    , [applyToShell=boolean], [areaWeight=float], [caching=boolean], [constructionHistory=boolean], [globalBlend=float], [globalMethodBlend=float], [iterations=int], [name=string], [nodeState=int], [optimizeAxis=int], [pinSelected=boolean], [pinUvBorder=boolean], [scale=float], [stoppingThreshold=float], [useScale=boolean], [uvSetName=string], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyOptUvs is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a sphere and select it.
cmds.polySphere()

Optimise the position of some Uvs
cmds.polyOptUvs( 'pSphere1.map[189:398]' )

---
Return:
---


    string: The node name.

Flags:
---


---
applyToShell(applyToShell): boolean
    properties: create
    Specifies where the whole object or just shells that are selected
or pinned should be affected.

---
areaWeight(aw): float
    properties: create
    Surface driven importance. 0 treat all faces equal. 1 gives more
importance to large ones.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
globalBlend(gb): float
    properties: create
    This allows the user to blend between a local optimization method
(globalBlend = 0.0) and a global optimization method
(globalBlend = 1.0). The local optimization method looks at the
ratio between the triangles on the object and the triangles in UV
space.  It has a side affect that it can sometimes introduce tapering
problems.  The global optimization is much slower, but takes into
consideration the entire object when optimizing uv placement.

---
globalMethodBlend(gmb): float
    properties: create
    The global optimization method uses two functions to compute
a minimization.  The first function controls edge
stretch by using edges lengths between xyz and uv.  The second
function penalizes the first function by preventing
configurations where triangles would overlap.  For every surface
there is a mix between these two functions that will give the
appropriate response. Values closer to 1.0 give more weight to
the edge length function. Values closer to 0.0 give more weight to
surface area.  The default value of '0.5' is a even mix
between these two values.

---
iterations(i): int
    properties: create
    Maximum number of iterations for each connected UV piece.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
optimizeAxis(oa): int
    properties: create
    Degree of freedom for optimization:
0=Optimize freely, 1=Move vertically only, 2=Move horzontally only

---
pinSelected(ps): boolean
    properties: create
    Specifies that the selected components should be pinned
instead of the unselected components.

---
pinUvBorder(pub): boolean
    properties: create
    Specifies that the UV border should be pinned when doing the
solve. By default only unselected components are pinned.

---
scale(s): float
    properties: create
    Ratio between 2d and 3d space.

---
stoppingThreshold(ss): float
    properties: create
    Minimum distorsion improvement between two steps in %.

---
useScale(us): boolean
    properties: create
    Adjust the scale or not.

---
uvSetName(uvs): string
    properties: create
    Name of the UV set to be created

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyOptUvs.html 
    """


def polyOptions(flagactiveObjects: boolean, flagallEdges: boolean, flagbackCullVertex: boolean, flagbackCulling: boolean, flagcolorMaterialChannel: string, flagcolorShadedDisplay: boolean, flagdisplayAlphaAsGreyScale: boolean, flagdisplayBlueChannel: boolean, flagdisplayBorder: boolean, flagdisplayCenter: boolean, flagdisplayColorAsGreyScale: boolean, flagdisplayCreaseEdge: boolean, flagdisplayCreaseVertex: boolean, flagdisplayGeometry: boolean, flagdisplayGreenChannel: boolean, flagdisplayInvisibleFaces: boolean, flagdisplayItemNumbers: tuple[boolean, boolean, boolean, boolean], flagdisplayMapBorder: boolean, flagdisplayMetadata: tuple[boolean, boolean, boolean], flagdisplayNormal: boolean, flagdisplayRedChannel: boolean, flagdisplaySubdComps: boolean, flagdisplayTangent: boolean, flagdisplayTriangle: boolean, flagdisplayUVTopology: boolean, flagdisplayUVs: boolean, flagdisplayVertex: boolean, flagdisplayWarp: boolean, flagfacet: boolean, flagfullBack: boolean, flaggl: boolean, flaghardBack: boolean, flaghardEdge: boolean, flaghardEdgeColor: boolean, flagmaterialBlend: string, flagnewPolymesh: boolean, flagpoint: boolean, flagpointFacet: boolean, flagrelative: boolean, flagreuseTriangles: boolean, flagsizeBorder: float, flagsizeNormal: float, flagsizeUV: float, flagsizeVertex: float, flagsmoothDrawType: int, flagsoftEdge: boolean, flagvertexNormalMethod: int, flagwireBackCulling: boolean) -> None:
    """Synopsis:
---
---
 polyOptions([activeObjects=boolean], [allEdges=boolean], [backCullVertex=boolean], [backCulling=boolean], [colorMaterialChannel=string], [colorShadedDisplay=boolean], [displayAlphaAsGreyScale=boolean], [displayBlueChannel=boolean], [displayBorder=boolean], [displayCenter=boolean], [displayColorAsGreyScale=boolean], [displayCreaseEdge=boolean], [displayCreaseVertex=boolean], [displayGeometry=boolean], [displayGreenChannel=boolean], [displayInvisibleFaces=boolean], [displayItemNumbers=[boolean, boolean, boolean, boolean]], [displayMapBorder=boolean], [displayMetadata=[boolean, boolean, boolean]], [displayNormal=boolean], [displayRedChannel=boolean], [displaySubdComps=boolean], [displayTangent=boolean], [displayTriangle=boolean], [displayUVTopology=boolean], [displayUVs=boolean], [displayVertex=boolean], [displayWarp=boolean], [facet=boolean], [fullBack=boolean], [gl=boolean], [hardBack=boolean], [hardEdge=boolean], [hardEdgeColor=boolean], [materialBlend=string], [newPolymesh=boolean], [point=boolean], [pointFacet=boolean], [relative=boolean], [reuseTriangles=boolean], [sizeBorder=float], [sizeNormal=float], [sizeUV=float], [sizeVertex=float], [smoothDrawType=int], [softEdge=boolean], [vertexNormalMethod=int], [wireBackCulling=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyOptions is undoable, queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

cmds.polyCube( n='plg', sx=3, sy=3, sz=3, w=5, h=5, d=5 )
cmds.delete( 'plg.f[9:17]' )

Vertices
cmds.polyOptions( displayVertex=True )
Toggle vertices
cmds.polyOptions( r=True, displayVertex=True )
Toggle, whatever the value given to the flag in this command.
It was previously true, it is set to false : vertices are not drawn.

Facet centers
cmds.polyOptions( displayCenter=True )
cmds.polyOptions( displayCenter=False )

Triangulation
cmds.polyOptions( displayTriangle=True )
cmds.polyOptions( displayTriangle=False )

Reusing Triangulation
cmds.polyOptions( reuseTriangles=True )
cmds.polyOptions( reuseTriangles=False )

Borders
cmds.polyOptions( displayBorder=True )
Border size
cmds.polyOptions( sb=3 )
Increase border size
cmds.polyOptions( r=True, sb=2 )
cmds.polyOptions( displayBorder=False, sb=3 )
Map borders
cmds.polyOptions( displayMapBorder=True )
cmds.polyOptions( displayMapBorder=False )

Normals
Normal type
cmds.polyOptions( displayNormal=True )
cmds.polyOptions( pt=True )on vertices
cmds.polyOptions( pf=True )on vertices and facets
cmds.polyOptions( f=True )on facets
Normal size
cmds.polyOptions( sn=2 )
Increase normal size
cmds.polyOptions( r=True, sn=1.5 )
cmds.polyOptions( displayNormal=False )

Edges
cmds.polyOptions( softEdge=True )
cmds.polyOptions( hardEdge=True )
cmds.polyOptions( hardEdgeColor=True )
cmds.polyOptions( allEdges=True )

Geometry
cmds.polyOptions( displayGeometry=False )
cmds.polyOptions( displayGeometry=True )

Backculling
cmds.polyOptions( wireBackCulling=True )
cmds.polyOptions( hardBack=True )
cmds.polyOptions( fullBack=True )
cmds.polyOptions( displayVertex=True, backCullVertex=True )
cmds.polyOptions( backCullVertex=False )
cmds.polyOptions( displayVertex=False )
cmds.polyOptions( backCulling=True )

Color Shaded Display
cmds.polyOptions( colorShadedDisplay=True )
cmds.polyOptions( colorMaterialChannel='DIFFUSE' )

---


Flags:
---


---
activeObjects(ao): boolean
    properties: create, query
    Apply user choices for all active objects.

---
allEdges(ae): boolean
    properties: create, query
    Display all edges in solid line.

---
backCullVertex(bcv): boolean
    properties: create, query
    BackCull vertices.

---
backCulling(bc): boolean
    properties: create, query
    Display with no back culling.

---
colorMaterialChannel(cm): string
    properties: create, query
    If colorShadedDisplay is true, then determines which
material channel to display color per vertex in.
The options are:

"none" : disable material shading
"ambient" : ambient material channel
"ambientDiffuse" :  ambient and diffuse material channel
"diffuse" :  diffuse material channel
"specular" :  specular material channel
"emission" :  emission material channel

---
colorShadedDisplay(cs): boolean
    properties: create, query
    Use color per vertex display in shaded mode.

---
displayAlphaAsGreyScale(dal): boolean
    properties: create, query
    Display alpha as greyscale.

---
displayBlueChannel(dbc): boolean
    properties: create, query
    Display Blue channel.

---
displayBorder(db): boolean
    properties: create, query
    Highlight border edge.

---
displayCenter(dc): boolean
    properties: create, query
    Display facet centers.

---
displayColorAsGreyScale(dcl) 2024: boolean
    properties: create, query
    Display color channels as greyscale.

---
displayCreaseEdge(dce): boolean
    properties: create, query
    Highlight creased edges

---
displayCreaseVertex(dcv): boolean
    properties: create, query
    Highlight creased vertices

---
displayGeometry(dg): boolean
    properties: create, query
    Display geometry.

---
displayGreenChannel(dgc): boolean
    properties: create, query
    Display Green channel.

---
displayInvisibleFaces(dif): boolean
    properties: create, query
    Highlight invisible faces

---
displayItemNumbers(din): [boolean, boolean, boolean, boolean]
    properties: create, query
    Displays item numbers (vertices edges facets uvs)

---
displayMapBorder(dmb): boolean
    properties: create, query
    Highlight map border edge.

---
displayMetadata(dmt): [boolean, boolean, boolean]
    properties: create, query
    Displays component metadata (vertices edges facets vertexFaces)

---
displayNormal(dn): boolean
    properties: create, query
    Display normals.

---
displayRedChannel(drc): boolean
    properties: create, query
    Display Red channel.

---
displaySubdComps(dsc): boolean
    properties: create, query
    Display subdivided components when in Smooth Mesh Preview mode.

---
displayTangent(dtn): boolean
    properties: create, query
    Display tangent.

---
displayTriangle(dt): boolean
    properties: create, query
    Display triangulation.

---
displayUVTopology(uvt): boolean
    properties: create, query
    Option on UV display to display UVs topologically.

---
displayUVs(duv): boolean
    properties: create, query
    Display UVs.

---
displayVertex(dv): boolean
    properties: create, query
    Display vertices.

---
displayWarp(dw): boolean
    properties: create, query
    Highlight warped facets.

---
facet(f): boolean
    properties: create, query
    For use with -dn flag. Set the normal display style to facet display.

---
fullBack(fb): boolean
    properties: create, query
    Display with full back culling.

---
gl(gl): boolean
    properties: create, query
    Apply user choices for all objects.

---
hardBack(hb): boolean
    properties: create, query
    Backculled hard edges only for backculled faces.

---
hardEdge(he): boolean
    properties: create, query
    Display only hard edges.

---
hardEdgeColor(hec): boolean
    properties: create, query
    Display hard edges as separate color.

---
materialBlend(mb): string
    properties: create, query
    The options are:
"overwrite"
"add"
"subtract"
"multiply"
"divide"
"average"
"modulate2x"

---
newPolymesh(np): boolean
    properties: create, query
    Set component display state of new polymesh objects.

---
point(pt): boolean
    properties: create, query
    For use with -dn flag. Set the normal display style to vertex display.

---
pointFacet(pf): boolean
    properties: create, query
    For use with -dn flag. Set the normal display style to vertex and face display.

---
relative(r): boolean
    properties: create, query
    When this flag is used with flags dealing with size,
the value (size) is a multiplication factor :
i.e for flags : -sizeNormal, -sizeBorder.
When this flag is used with flags dealing with a boolean value,
the boolean value is toggled :
i.e for flags : displayVertex, displayCenter, displayTriangle,
displayBorder, backCullVertex, displayWarp, displayItemNumbers.

---
reuseTriangles(rt): boolean
    properties: create, query
    Avoid regenerating triangles, by reusing the old triangles upstream
in the construction history.  The construction history is searched
upstream and downstream for other mesh nodes, and the given boolean
value is set on those mesh nodes.  Note, that this command does not
set the value on the given mesh node.  That has to be done using
the setAttr command.
This option would affect only the interactive 3d viewport.
The batch-rendering would use the properly computed triangles.
This is useful only for interactive performance such as skinning
playback, when the display mode is shaded (or wireframe with
triangles displayed)  Using this option for wireframe display mode
is not recomended.

---
sizeBorder(sb): float
    properties: create, query
    Set the size of the polygonal border edges.

---
sizeNormal(sn): float
    properties: create, query
    Set the size of the polygonal normals.

---
sizeUV(suv): float
    properties: create, query
    Set the size of the polygonal UV.

---
sizeVertex(sv): float
    properties: create, query
    Set the size of the polygonal vertex.

---
smoothDrawType(sdt): int
    properties: create, query
    This setting only works with the newPolymesh flag.
Sets a new default attribute value for the smoothDrawType attribute on a polymesh object.
Options are:
0: Catmull-Clark
1: Linear
2: OpenSubdiv Catmull-Clark Uniform
3: OpenSubdiv Catmull-Clark Adaptive

---
softEdge(se): boolean
    properties: create, query
    Display soft edges in dotted lines.

---
vertexNormalMethod(vnm): int
    properties: create, query
    This setting only works with the newPolymesh flag.
Sets a new default attribute value for the vertexNormalMethod attribute on a polymesh object.
Options are:
0: Unweighted
1: Angle Weighted
2: Area Weighted
3: Angle And Area Weighted

---
wireBackCulling(wbc): boolean
    properties: create, query
    Backculled faces are in wireframe.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyOptions.html 
    """


def polyOutput(flagallValues: boolean, flagcolor: boolean, flagcolorDesc: boolean, flagedge: boolean, flagedgeFace: boolean, flagface: boolean, flagfaceNorm: boolean, flagforce: boolean, flaggroup: boolean, flagnoOutput: boolean, flagnormDesc: boolean, flagoutputFile: string, flagtriangle: boolean, flaguvDesc: boolean, flaguvValue: boolean, flagvert: boolean, flagvertEdge: boolean, flagvertNorm: boolean) -> None:
    """Synopsis:
---
---
 polyOutput(
poly poly...
    , [allValues=boolean], [color=boolean], [colorDesc=boolean], [edge=boolean], [edgeFace=boolean], [face=boolean], [faceNorm=boolean], [force=boolean], [group=boolean], [noOutput=boolean], [normDesc=boolean], [outputFile=string], [triangle=boolean], [uvDesc=boolean], [uvValue=boolean], [vert=boolean], [vertEdge=boolean], [vertNorm=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyOutput is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

cmds.polyPlane()
cmds.polyOutput( a=True )

If a polygon operation is performed such as Add Divisions:
cmds.polySubdivideFacet('pPlane1', dv=1, m=0, ch=1)

then the command can get information on geometry data feeding into the polySubdFace1 node.
cmds.polyOutput( 'polySubdFace1.inputPolymesh' )

The command can also get information on geometry data coming out of the
polySubdFace1 node.
cmds.polyOutput( 'polySubdFace1.output' )

---


Flags:
---


---
allValues(a): boolean
    properties: create
    Shortcut for setting all the flags above

---
color(c): boolean
    properties: create
    Prints the color per vertex. In case of multiple sets,
all sets are printed.

---
colorDesc(cd): boolean
    properties: create
    Print the color per vertex description. Each integer
is an entry in the color array.

---
edge(e): boolean
    properties: create
    Print the edge description.

---
edgeFace(ef): boolean
    properties: create
    Prints the edge to face adjascency list. Only
available if the information is already computed on
the object.

---
face(f): boolean
    properties: create
    Print the faces description

---
faceNorm(fn): boolean
    properties: create
    Prints the normals per face. Only available if the
information is already computed on the object.

---
force(fo): boolean
    properties: create
    Force evaluation of missing pieces before printing.

---
group(g): boolean
    properties: create
    Print the groups of the object.

---
noOutput(no): boolean
    properties: create
    Dont output any data.  Would be useful if you want to
just evaluate the data, for testing purposes.

---
normDesc(nd): boolean
    properties: create
    Prints the normals per vertex description. Each
integer is an entry in the vertNorm array. Only
available if the information is already computed on
the object.

---
outputFile(of): string
    properties: create
    Location of the output file.

---
triangle(t): boolean
    properties: create
    Prints the triangles per face. Only available if the
information is already computed on the object.

---
uvDesc(uvd): boolean
    properties: create
    Print the UV description. Each integer is an entry in
the uvValue array.

---
uvValue(uv): boolean
    properties: create
    Prints the UV positions. In case of multiple UV sets,
all sets are printed.

---
vert(v): boolean
    properties: create
    Prints the vertex positions.

---
vertEdge(ve): boolean
    properties: create
    Prints the vertex to edge adjascency list. Only
available if the information is already computed on
the object.

---
vertNorm(vn): boolean
    properties: create
    Prints the normals per vertex. Only available if the
information is already computed on the object.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyOutput.html 
    """


def polyPinUV(flagcreateHistory: boolean, flagoperation: uint, flagunpinned: boolean, flaguvSetName: string, flagvalue: float) -> boolean:
    """Synopsis:
---
---
 polyPinUV([createHistory=boolean], [operation=uint], [unpinned=boolean], [uvSetName=string], [value=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyPinUV is undoable, queryable, and editable.
This command is used to pin and unpin UVs. A "pinned" UV is one which should not be modified.


Each UV has an associated pin weight, that defaults to 0.0 meaning that the UV is not pinned. If pin weight is set to 1.0 then it becomes fully pinned and UV tools should not modify that UV.
If the pin weight is set to a value between 0.0 and 1.0 then UV tools should weight their changes to that UV accordingly.


UV pinning is not enforced by the shape node: it is up to each tool to decide whether it will obey the pin weights.




Example:
---
import maya.cmds as cmds

To set a pin value of 0.9 on the selected UVs.
cmds.polyPinUV( value=0.9 )

List all selected UVs which are not pinned.
cmds.polyPinUV( q=True, unpinned=True )

---
Return:
---


    boolean: Success or Failure.

Flags:
---


---
createHistory(ch): boolean
    properties: create, query, edit
    For objects that have no construction history, this flag can be used
to force the creation of construction history for pinning.  By default,
history is not created if the object has no history.  Regardless of this
flag, history is always created if the object already has history.

---
operation(op): uint
    properties: create, query, edit
    Operation to perform.  Valid values are:
0: Set pin weights on the selected UVs.
1: Set pin weights to zero for the selected UVs.
2: Remove pin weights from the entire mesh.
3: Invert pin weights of the entire mesh.
Default is 0.

---
unpinned(unp): boolean
    properties: query, edit
    List all selected UVs which are not pinned.

---
uvSetName(uvs): string
    properties: create, query, edit
    Specifies the name of the UV set to edit UVs on. If not
specified the current UV set will be used if it exists.

---
value(v): float
    properties: create, query, edit, multiuse
    Specifies the pin value for the selected UV components.
When specified multiple times, the values are assigned respectively to
the specified UVs.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyPinUV.html 
    """


def polyPipe(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: boolean, flagheight: linear, flagname: string, flagnodeState: int, flagobject: boolean, flagradius: linear, flagroundCap: boolean, flagsubdivisionsAxis: int, flagsubdivisionsCaps: int, flagsubdivisionsHeight: int, flagtexture: boolean, flagthickness: linear) -> list[string]:
    """Synopsis:
---
---
 polyPipe([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=boolean], [height=linear], [name=string], [nodeState=int], [object=boolean], [radius=linear], [roundCap=boolean], [subdivisionsAxis=int], [subdivisionsCaps=int], [subdivisionsHeight=int], [texture=boolean], [thickness=linear])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyPipe is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a pipe with height 20 radius 1.0 thickness 0.5 with
10 subdivisions along height
cmds.polyPipe( sh=10, h=20 )

Create a pipe, called "myPipe", on thickness cap there are 5
subdivisions.
cmds.polyPipe( n='myPipe', sc=5);

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the pipe.
Q: When queried, this flag returns a float[3].

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createUVs(cuv): boolean
    properties: create, query, edit
    Create UVs or not.
Default: true

---
height(h): linear
    properties: create, query, edit
    Height of the pipe.
Default: 2.0

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
radius(r): linear
    properties: create, query, edit
    Radius of the pipe.
Default: 1.0

---
roundCap(rcp): boolean
    properties: create, query, edit
    To indicate whether we need a round cap
Default: false

---
subdivisionsAxis(sa): int
    properties: create, query, edit
    Subdivisions around the axis.
Default: 20

---
subdivisionsCaps(sc): int
    properties: create, query, edit
    Subdivisions along the thickness caps.
Default: 1

---
subdivisionsHeight(sh): int
    properties: create, query, edit
    Subdivisions along the height.
Default: 1

---
texture(tx): boolean
    properties: create, query, edit
    Apply texture or not. this is an old attribute.
This is unsupported and would be removed in a future release.
Default: true

---
thickness(t): linear
    properties: create, query, edit
    Thickness of the pipe.
Default: 0.5

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyPipe.html 
    """


def polyPlanarProjection(flagcaching: boolean, flagconstructionHistory: boolean, flagcreateNewMap: boolean, flagimageCenter: tuple[float, float], flagimageCenterX: float, flagimageCenterY: float, flagimageScale: tuple[float, float], flagimageScaleU: float, flagimageScaleV: float, flaginsertBeforeDeformers: boolean, flagkeepImageRatio: boolean, flagmapDirection: string, flagname: string, flagnodeState: int, flagperInstance: boolean, flagprojectionCenter: tuple[linear, linear, linear], flagprojectionCenterX: linear, flagprojectionCenterY: linear, flagprojectionCenterZ: linear, flagprojectionHeight: linear, flagprojectionHorizontalSweep: linear, flagprojectionScale: tuple[linear, linear], flagrotate: tuple[angle, angle, angle], flagrotateX: angle, flagrotateY: angle, flagrotateZ: angle, flagrotationAngle: angle, flagseamCorrect: boolean, flagsmartFit: boolean, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyPlanarProjection([caching=boolean], [constructionHistory=boolean], [createNewMap=boolean], [imageCenter=[float, float]], [imageCenterX=float], [imageCenterY=float], [imageScale=[float, float]], [imageScaleU=float], [imageScaleV=float], [insertBeforeDeformers=boolean], [keepImageRatio=boolean], [mapDirection=string], [name=string], [nodeState=int], [perInstance=boolean], [projectionCenter=[linear, linear, linear]], [projectionCenterX=linear], [projectionCenterY=linear], [projectionCenterZ=linear], [projectionHeight=linear], [projectionHorizontalSweep=linear], [projectionScale=[linear, linear]], [rotate=[angle, angle, angle]], [rotateX=angle], [rotateY=angle], [rotateZ=angle], [rotationAngle=angle], [seamCorrect=boolean], [smartFit=boolean], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyPlanarProjection is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a plane with default UVs.
cmds.polyPlane( n='plane', h=20, w=20 )

Create a lambert node.
cmds.shadingNode( 'lambert', n= 'myLambert', asShader=True )
cmds.sets( renderable=True, noSurfaceShader=True, empty=True, name='myLambertSG' )
cmds.connectAttr( 'myLambert.outColor', 'myLambertSG.surfaceShader', f=True )

Create a texture checker.
cmds.shadingNode( 'checker', asTexture=True )
cmds.shadingNode( 'place2dTexture', asUtility=True )
cmds.connectAttr( 'place2dTexture1.outUV', 'checker1.uv' )

Assign the texture the the lambert node.
cmds.connectAttr( 'checker1.outColor', 'myLambert.color', f=True )

Set the textured display mode.
currentPanel = cmds.getPanel(withFocus= True)
if currentPanel != '':
        cmds.modelEditor(currentPanel, edit=True, da='smoothShaded', displayTextures=True, dl='default')

Assign the lambert shader to all facets of the plane.
cmds.sets('planeShape.f[0:99]', edit=True, forceElement= 'myLambertSG' )

Replace default UVs on half of the plane :
Rotates projection around X, rotate the map of 45 degrees,
and reduces of half the projected map.
cmds.polyPlanarProjection( 'plane.f[0:49]', rx=90, ra=45.0, pc= (0, 0, 0), imageScale=(0.5, 0.5))

Set the wireframe display mode.
currentPanel = cmds.getPanel(withFocus= True)
if currentPanel != '':
        cmds.modelEditor(currentPanel, edit=True, da='wireframe')

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createNewMap(cm): boolean
    properties: create, query
    This flag when set true will create a new map with
a the name passed in, if the map does not already exist.

---
imageCenter(ic): [float, float]
    properties: create, query, edit
    The center point of the 2D model layout.
Default: 0.5, 0.5

---
imageCenterX(icx): float
    properties: create, query, edit
    Image center X coord.

---
imageCenterY(icy): float
    properties: create, query, edit
    Image center Y coord.

---
imageScale(imageScale): [float, float]
    properties: create, query, edit
    Specifies the UV scale : Enlarges or reduces the 2D version of the
model in U or V space relative to the 2D centerpoint.
Default: 1.0, 1.0

---
imageScaleU(isu): float
    properties: create, query, edit
    The the U scale : Enlarges or reduces the 2D version of the model
in U space relative to the 2D centerpoint.

---
imageScaleV(isv): float
    properties: create, query, edit
    The V scale : Enlarges or reduces the 2D version of the model
in V space relative to the 2D centerpoint.

---
insertBeforeDeformers(ibd): boolean
    properties: create
    This flag specifies if the projection node should be inserted before
or after deformer nodes already applied to the shape. Inserting the
projection after the deformer leads to texture swimming during
animation and is most often undesirable.
C: Default is on.

---
keepImageRatio(kir): boolean
    properties: create
    True means keep any image ratio

---
mapDirection(md): string
    properties: create
    This flag specifies the mapping direction.
'x', 'y' and 'z' projects the map along the corresponding axis.
'c' projects along the current camera viewing direction.
'p' does perspective projection if current camera is perspective.
'b' projects along the best plane fitting the objects selected.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
perInstance(pi): boolean
    properties: create
    True if the new map is per-instance, otherwise it is shared.

---
projectionCenter(pc): [linear, linear, linear]
    properties: create, query, edit
    The point on the object that will be the center of the projection.
Default: 0.0, 0.0, 0.0

---
projectionCenterX(pcx): linear
    properties: create, query, edit
    Projection center X coord.

---
projectionCenterY(pcy): linear
    properties: create, query, edit
    Projection center Y coord.

---
projectionCenterZ(pcz): linear
    properties: create, query, edit
    Projection center Z coord.

---
projectionHeight(ph): linear
    properties: create, query, edit
    The height of the map relative to the 3D projection axis.

---
projectionScale(ps): [linear, linear]
    properties: create, query, edit
    The width and the height of the map relative to the 3D projection axis.
Default: 1.0, 1.0

---
rotate(ro): [angle, angle, angle]
    properties: create, query, edit
    The mapping rotate angles.
Default: 0.0, 0.0, 0.0

---
rotateX(rx): angle
    properties: create, query, edit
    X mapping rotate angle.

---
rotateY(ry): angle
    properties: create, query, edit
    Y mapping rotate angle.

---
rotateZ(rz): angle
    properties: create, query, edit
    Z mapping rotate angle.

---
rotationAngle(ra): angle
    properties: create, query, edit
    The angle for the rotation.
When the angle is positive, then the map rotates counterclockwise on
the mapped model; if negative, the map rotates clockwise.
Default: 0.0

---
smartFit(sf): boolean
    properties: create
    True means use the smart fit algorithm

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

---
projectionHorizontalSweep(phs): linear
    properties: create, query, edit
    The angle swept horizontally by the projection.  The range is [0, 360].

---
seamCorrect(sc): boolean
    properties: create, query, edit
    This flag specifies to perform a seam correction
on the mapped faces.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyPlanarProjection.html 
    """


def polyPlane(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: int, flagheight: linear, flagname: string, flagnodeState: int, flagobject: boolean, flagsubdivisionsHeight: int, flagsubdivisionsWidth: int, flagsubdivisionsX: int, flagsubdivisionsY: int, flagtexture: int, flagwidth: linear) -> list[string]:
    """Synopsis:
---
---
 polyPlane([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=int], [height=linear], [name=string], [nodeState=int], [object=boolean], [subdivisionsHeight=int], [subdivisionsWidth=int], [subdivisionsX=int], [subdivisionsY=int], [texture=int], [width=linear])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyPlane is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a mesh (plane), with 10 subdivisions in the X direction,
15 subdivisions in the Y direction,
the width of the mesh is 15, the height of the mesh is 20.
cmds.polyPlane( sx=10, sy=15, w=15, h=20)

Create a mesh, called "myPlane", on each direction there are 5 subdivisions.
cmds.polyPlane(n='myPlane', sx=5, sy=5)

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the plane.

---
createUVs(cuv): int
    properties: create, query, edit
    Create UVs or not.
0: No UVs
1: No Normalization
2: Normalize and Preserve Aspect Ratio
Default: 1

---
height(h): linear
    properties: create, query, edit
    Height of the plane.
Default: 1.0

---
subdivisionsHeight(sh): int
    properties: create, query, edit
    Subdivisions along the height of the sphere.

---
subdivisionsWidth(sw): int
    properties: create, query, edit
    Subdivisions along the width of the plane.
Default: 10

---
subdivisionsX(sx): int
    properties: create, query, edit
    This specifies the number of subdivisions in the X direction for the plane.
Default is 5.

---
subdivisionsY(sy): int
    properties: create, query, edit
    This flag specifies the number of subdivisions in the Y direction for the plane.
Default is 5.

---
texture(tx): int
    properties: create, query, edit
    What texture mechanism to be applied.
0=No textures; 1=stretch to fit;
2=preserve aspect ratio
Default: 1

---
width(w): linear
    properties: create, query, edit
    Width of the plane.
Default: 1.0

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyPlane.html 
    """


def polyPlatonicSolid(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: int, flagname: string, flagnodeState: int, flagobject: boolean, flagradius: linear, flagsideLength: linear, flagsolidType: int, flagtexture: int) -> list[string]:
    """Synopsis:
---
---
 polyPlatonicSolid([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=int], [name=string], [nodeState=int], [object=boolean], [radius=linear], [sideLength=linear], [solidType=int], [texture=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyPlatonicSolid is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a icosahedron with radius 2 side length 2
cmds.polyPlatonicSolid( r=2, l=2, st=1)

Create a platonic solid, called "myPlatonicsolid", of type octahedron.
cmds.polyPlatonicSolid( n='myPlatonicsolid', st=2 )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the platonic solid.
Q: When queried, this flag returns a float[3].

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createUVs(cuv): int
    properties: create
    This flag alows a specific UV mechanism to be selected, while creating.
The valid values are 0, 1,  2 ,3 or 4.
0 implies that no UVs will be generated (No texture to be applied).

1 implies UVs should be created for the object as a whole without any normalization.
 The solid will be unwrapped and then the texture will be applied
 without any distortion.
 In the unwrapped solid, the shared edges will have shared UVs.

2 implies UVs are created separately for each of the faces of the solid.

3 implies the UVs should be normalized. This will normalize the
 U and V direction separately, thereby resulting in distortion of textures.

4 implies UVs are created so that the texture will not be distorted when applied.
 The texture lying outside the UV range will be truncated (since that cannot be
 squeezed in, without distorting the texture.

  For better understanding of these options, you may have to open the
     texture view window

C: Default is 4

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
radius(r): linear
    properties: create, query, edit
    This flag specifies the radius of the platonic solid.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
sideLength(l): linear
    properties: create, query, edit
    This flag specifies the side length of platonic solid.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
solidType(st): int
    properties: create
    This flag allows a specific platonic solid to be selected for creation of mesh,
The valid values are 0, 1, 2 and 3.
0 implies dodecahedron to be created.
1 implies icosahedron to be created.
2 implies octahedron to be created.
3 implies tertrahedron to be created.

C: Default is 0

---
texture(tx): int
    properties: create
    This flag is obsolete and will be removed in the next release.
The -cuv/createUVs flag should be used instead.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyPlatonicSolid.html 
    """


def polyPoke(flagcaching: boolean, flagconstructionHistory: boolean, flaglocalTranslate: tuple[linear, linear, linear], flaglocalTranslateX: linear, flaglocalTranslateY: linear, flaglocalTranslateZ: linear, flagname: string, flagnodeState: int, flagtranslate: tuple[linear, linear, linear], flagtranslateX: linear, flagtranslateY: linear, flagtranslateZ: linear, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyPoke(
selectionList
    , [caching=boolean], [constructionHistory=boolean], [localTranslate=[linear, linear, linear]], [localTranslateX=linear], [localTranslateY=linear], [localTranslateZ=linear], [name=string], [nodeState=int], [translate=[linear, linear, linear]], [translateX=linear], [translateY=linear], [translateZ=linear], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyPoke is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

To poke all the faces of a polyCube...
---

cmds.polyCube( w=1, h=1, d=1, sx=1, sy=1, sz=1, ax=(0, 1, 0), tx=1, ch=1, n='pCube' )
cmds.polyPoke( 'pCube.f[0:5]', ch=1 )

To poke all the faces of a polyCube, and pull the
new vertices by one unit along the face normal
---

cmds.polyCube( w=1, h=1, d=1, sx=1, sy=1, sz=1, ax=(0, 1, 0), tx=1, ch=1, n='pCubePull' )
cmds.polyPoke( 'pCubePull.f[0:5]', ltx=0, lty=0, ltz=1, ch=1 )

---
Return:
---


    string: The node name

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
localTranslate(lt): [linear, linear, linear]
    properties: create
    Translate the new vertex in the local face coordinate.

---
localTranslateX(ltx): linear
    properties: create
    Translate the new vertex in the local face coordinate along X.

---
localTranslateY(lty): linear
    properties: create
    Translate the new vertex in the local face coordinate along Y.

---
localTranslateZ(ltz): linear
    properties: create
    Translate the new vertex in the local face coordinate along Z.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
translate(t): [linear, linear, linear]
    properties: create
    Translate the new vertex in the world space.

---
translateX(tx): linear
    properties: create
    Translate the new vertex in the world space along X.

---
translateY(ty): linear
    properties: create
    Translate the new vertex in the world space along Y.

---
translateZ(tz): linear
    properties: create
    Translate the new vertex in the world space along Z.

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyPoke.html 
    """


def polyPrimitive(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: int, flagname: string, flagnodeState: int, flagobject: boolean, flagpolyType: int, flagradius: linear, flagsideLength: linear, flagtexture: int) -> list[string]:
    """Synopsis:
---
---
 polyPrimitive([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=int], [name=string], [nodeState=int], [object=boolean], [polyType=int], [radius=linear], [sideLength=linear], [texture=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyPrimitive is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a soccerBall with radius 1 side length 0.4037
cmds.polyPrimitive( r=1, l=0.4036, pt=0)

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the primitive polygon.
Q: When queried, this flag returns a float[3].

---
createUVs(cuv): int
    properties: create, query, edit
    Create UVs or not.
0: No UVs
1: No Normalization
2: Normalize Each Face Separately
3: Normalize Collectively
4: Normalize and Preserve Aspect Ratio

---
polyType(pt): int
    properties: create
    This flag allows a specific primitive poly to be selected for creation of mesh,
The valid values is 0
0 implies soccer ball to be created.
C: Default is 0

---
radius(r): linear
    properties: create, query, edit
    This flag specifies the radius of the primitive polygon.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
sideLength(l): linear
    properties: create, query, edit
    This flag specifies the side length of primitive polygon.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
texture(tx): int
    properties: create, query, edit
    What texture mechanism to be applied
0=No textures, 1=Object, 2=Faces

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyPrimitive.html 
    """


def polyPrism(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: int, flaglength: linear, flagname: string, flagnodeState: int, flagnumberOfSides: int, flagnumderOfSides: int, flagobject: boolean, flagsideLength: linear, flagsubdivisionsCaps: int, flagsubdivisionsHeight: int, flagtexture: int) -> list[string]:
    """Synopsis:
---
---
 polyPrism([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=int], [length=linear], [name=string], [nodeState=int], [numberOfSides=int], [numderOfSides=int], [object=boolean], [sideLength=linear], [subdivisionsCaps=int], [subdivisionsHeight=int], [texture=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyPrism is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a prism, with 10 subdivisions on the caps,
and 15 subdivisions along the length,
the edge length of the prism is 20.
cmds.polyPrism ( sc=10, sh=15, w=20)

Create a prism, called "myprism", on each direction there are 5 subdivisions.
cmds.polyPrism( n='myprism', sc=5, sh=5)

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the prism.
Q: When queried, this flag returns a float[3].

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createUVs(cuv): int
    properties: create
    This flag alows a specific UV mechanism to be selected, while creating the primitive.
The valid values are 0, 1,  2 or 3.
0 implies that no UVs will be generated (No texture to be applied).

1 implies UVs should be created for the object as a whole without any normalization.
 The primitive will be unwrapped and then the texture will be applied
 without any distortion.
 In the unwrapped primitive, the shared edges will have shared UVs.

2 implies the UVs should be normalized. This will normalize the
 U and V direction separately, thereby resulting in distortion of textures.

3 implies UVs are created so that the texture will not be distorted when applied.
 The texture lying outside the UV range will be truncated (since that cannot be
 squeezed in, without distorting the texture.

  For better understanding of these options, you may have to open the
     texture view window

C: Default is 2.

---
length(l): linear
    properties: create, query, edit
    This flag specifies the length of the prism.
C: Default is 2.0.
Q: When queried, this flag returns a float.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
numberOfSides(ns): int
    properties: create, query, edit
    This specifies the number of sides for the prism.
C: Default is 3.
Q: When queried, this flag returns an int.

---
numderOfSides(nsi): int
    properties: create, query, edit
    This specifies the number of sides for the prism.
C: Default is 3.
Q: When queried, this flag returns an int.

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
sideLength(w): linear
    properties: create, query, edit
    This flag specifies the edge length of the prism.
C: Default is 2.0.
Q: When queried, this flag returns a float.

---
subdivisionsCaps(sc): int
    properties: create, query, edit
    This flag specifies the subdivisions on the caps for the prism.
C: Default is 2.
Q: When queried, this flag returns an int.

---
subdivisionsHeight(sh): int
    properties: create, query, edit
    This specifies the subdivisions along the height for the prism.
C: Default is 1.
Q: When queried, this flag returns an int.

---
texture(tx): int
    properties: create
    This flag is obsolete and will be removed in the next release.
The -cuv/createUVs flag should be used instead.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyPrism.html 
    """


def polyProjectCurve(flagaddUnderTransform: boolean, flagcaching: boolean, flagdirection: tuple[linear, linear, linear], flagdirectionX: linear, flagdirectionY: linear, flagdirectionZ: linear, flagnodeState: int, flagtolerance: linear) -> list[string]:
    """Synopsis:
---
---
 polyProjectCurve(
curve poly
    , [addUnderTransform=boolean], [caching=boolean], [direction=[linear, linear, linear]], [directionX=linear], [directionY=linear], [directionZ=linear], [nodeState=int], [tolerance=linear])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyProjectCurve is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

create a poly plane in the z axis
poly = cmds.polyPlane(w=10, h=10, sx=10, sy=10, ax=(0,0,1), cuv=2, ch=1)

create a nurbs circle also in the z axis
nurbs = cmds.circle(ch=1, o=1, r=2, nr=(0,0,1))

and project it onto the poly plane along the z axis
results = cmds.polyProjectCurve(poly[0], nurbs[0], direction=(0,0,1))

---
Return:
---


    list[string]: Object name and node name

Flags:
---


---
addUnderTransform(aut): boolean
    properties: create
    True if the resulting curve should be added under the source transform

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
direction(d): [linear, linear, linear]
    properties: create, query, edit
    Direction of projection.

---
directionX(dx): linear
    properties: create, query, edit
    X direction of projection.

---
directionY(dy): linear
    properties: create, query, edit
    Y direction of projection.

---
directionZ(dz): linear
    properties: create, query, edit
    Z direction of projection.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
tolerance(tol): linear
    properties: create, query, edit
    Tolerance to fit to.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyProjectCurve.html 
    """


def polyProjection(flagconstructionHistory: boolean, flagcreateNewMap: boolean, flagimageCenterX: float, flagimageCenterY: float, flagimageScaleU: float, flagimageScaleV: float, flaginsertBeforeDeformers: boolean, flagkeepImageRatio: boolean, flagmapDirection: string, flagprojectionCenterX: float, flagprojectionCenterY: float, flagprojectionCenterZ: float, flagprojectionScaleU: float, flagprojectionScaleV: float, flagrotateX: float, flagrotateY: float, flagrotateZ: float, flagrotationAngle: float, flagseamCorrect: boolean, flagsmartFit: boolean, flagtype: string, flaguvSetName: string) -> string:
    """Synopsis:
---
---
 polyProjection([constructionHistory=boolean], [createNewMap=boolean], [imageCenterX=float], [imageCenterY=float], [imageScaleU=float], [imageScaleV=float], [insertBeforeDeformers=boolean], [keepImageRatio=boolean], [mapDirection=string], [projectionCenterX=float], [projectionCenterY=float], [projectionCenterZ=float], [projectionScaleU=float], [projectionScaleV=float], [rotateX=float], [rotateY=float], [rotateZ=float], [rotationAngle=float], [seamCorrect=boolean], [smartFit=boolean], [type=string], [uvSetName=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyProjection is undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

cmds.file( f=True, new=True )
To create a planar projection
---

cmds.polyPlane( sx=10, sy=10 )
cmds.move( 0, 0, r=3 )
cmds.polyProjection( 'pPlane1.f[0:99]', type='Planar', md='y' )
Result: polyPlanarProj1 ---


To create a cylindrical projection
---

cmds.polyCylinder()
cmds.polyProjection( 'pCylinder1.f[0:21]', type='Cylindrical' )
Result: polyCylProj1 ---


To create a spherical projection
---

cmds.polySphere()
cmds.move( 0, 0, r=-3 )
cmds.polyProjection( 'pSphere1.f[0:399]', type='Spherical' )
Result: polySphProj1 ---


---
Return:
---


    string: Name of node created

Flags:
---


---
constructionHistory(ch): boolean
    properties: create
    Turn the construction history on or off (where applicable).

---
createNewMap(cm): boolean
    properties: create
    Create new map if it does not exist.

---
imageCenterX(icx): float
    properties: create
    Specifies the X (U) translation of the projected UVs.
        Default is 0.5.

---
imageCenterY(icy): float
    properties: create
    Specifies the Y (V) translation of the projected UVs.
        Default is 0.5.

---
imageScaleU(isu): float
    properties: create
    Specifies the U scale factor of the projected UVs.
        Default is 1.

---
imageScaleV(isv): float
    properties: create
    Specifies the V scale factor of the projected UVs.
        Default is 1.

---
insertBeforeDeformers(ibd): boolean
    properties: create
    Specifies if the projection node should be inserted
        before or after deformer nodes already applied to the shape.
        Inserting the projection after the deformer leads to texture
        swimming during animation and is most often undesirable.
        Default is on.

---
keepImageRatio(kir): boolean
    properties: create
    Specifies if the xy scaling in the planar projection has to be
        uniform.  By setting this flag, the texture aspect ratio is
        preserved.  This flag is ignored for cylindrical and spherical
        projections.

---
mapDirection(md): string
    properties: create
    Specifies the direction of the projection.  By specifying this flag, the
        projection placement values (pcx, pcy, pcz, rx, ry, rz, psu, psv) are
        internally computed.  If both this flag and the projection values are
        specified, the projection values are ignored.
        Valid Values are :
                X                       Projects along the X Axis
                Y                       Projects along the Y Axis
                Z                       Projects along the Z Axis
                bestPlane       Projects on the best plane fitting the object
                camera          Projects along the viewing direction
                perspective Creates perspective projection if current camera is perspective
        Default is bestPlane.

---
projectionCenterX(pcx): float
    properties: create
    Specifies the X coordinate of the center of the projection manipulator.

---
projectionCenterY(pcy): float
    properties: create
    Specifies the Y coordinate of the center of the projection manipulator.

---
projectionCenterZ(pcz): float
    properties: create
    Specifies the Z coordinate of the center of the projection manipulator.

---
projectionScaleU(psu): float
    properties: create
    Specifies the U scale component of the projection manipulator.

---
projectionScaleV(psv): float
    properties: create
    Specifies the V scale component of the projection manipulator.

---
rotateX(rx): float
    properties: create
    Specifies the X-axis rotation of the projection manipulator.

---
rotateY(ry): float
    properties: create
    Specifies the Y-axis rotation of the projection manipulator.

---
rotateZ(rz): float
    properties: create
    Specifies the Z-axis rotation of the projection manipulator.

---
rotationAngle(ra): float
    properties: create
    Specifies the rotation of the projected UVs in the UV space.
        Default is 0.

---
seamCorrect(sc): boolean
    properties: create
    Specifies if seam correction has to be done for spherical
        and cylindrical projections.  This flag is ignored, if the
        planar projection is specified.

---
smartFit(sf): boolean
    properties: create
    Specifies if the projection manipulator has to be placed
        fitting the object.  Used for cylindrical and spherical
        projections.  For smart fitting the planar projection, the
        mapDirection flag has to be used, since there are several
        options for smart fitting a planar projection.

---
type(t): string
    properties: create
    Specify the type of mapping to be performed.
        Valid values for the STRING are
         "planar"
         "cylindrical"
         "spherical"
        Default is planar.

---
uvSetName(uvs): string
    properties: create
    Specifies name of the uv set to work on.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyProjection.html 
    """


def polyPyramid(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: int, flagname: string, flagnodeState: int, flagnumberOfSides: int, flagnumderOfSides: int, flagobject: boolean, flagsideLength: linear, flagsubdivisionsCaps: int, flagsubdivisionsHeight: int, flagtexture: boolean) -> list[string]:
    """Synopsis:
---
---
 polyPyramid([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=int], [name=string], [nodeState=int], [numberOfSides=int], [numderOfSides=int], [object=boolean], [sideLength=linear], [subdivisionsCaps=int], [subdivisionsHeight=int], [texture=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyPyramid is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a pyramid, with 10 subdivisions on the caps,
15 subdivisions along the height and num ber of sides 5,
the side length of the pyramid is 20, the height of the pyramid is 10.
cmds.polyPyramid( sc=10, sh=15, ns=5, w=20)

Create a pyramid, called "mypyramid", olong height there are 5 subdivisions
and with 5 sides.
cmds.polyPyramid( n='mypyramid', sh=5, ns=5, sc=5)

Query the side length of "mypyramid"
w = cmds.polyPyramid( 'mypyramid', q=True, w=True )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the pyramid.
Q: When queried, this flag returns a float[3].

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createUVs(cuv): int
    properties: create, query, edit
    Create UVs or not.
0: No UVs
1: No Normalization
2: Normalize
3: Normalize and Preserve Aspect Ratio
Default: 2

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
numberOfSides(ns): int
    properties: create, query, edit
    Number of sides of Pyramid.
Default: 4

---
numderOfSides(nsi): int
    properties: create, query, edit
    Number of sides of Pyramid.
Default: 4

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
sideLength(w): linear
    properties: create, query, edit
    Side length of the Pyramid.
Default: 1.0

---
subdivisionsCaps(sc): int
    properties: create, query, edit
    Subdivisions on bottom cap
Default: 0

---
subdivisionsHeight(sh): int
    properties: create, query, edit
    Subdivisions along the height.
Default: 1

---
texture(tx): boolean
    properties: create, query, edit
    Apply texture or not.
Default: true

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyPyramid.html 
    """


def polyQuad(flagangle: angle, flagcaching: boolean, flagconstructionHistory: boolean, flagkeepGroupBorder: boolean, flagkeepHardEdges: boolean, flagkeepTextureBorders: boolean, flagname: string, flagnodeState: int, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyQuad([angle=angle], [caching=boolean], [constructionHistory=boolean], [keepGroupBorder=boolean], [keepHardEdges=boolean], [keepTextureBorders=boolean], [name=string], [nodeState=int], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyQuad is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polyCube( n='plg1', sx=3, sy=3, sz=3, w=5, h=5, d=5 )
cmds.move( -5, 0, 0 )
cmds.polyCube( n='plg2', sx=3, sy=3, sz=3, w=5, h=5, d=5 )
cmds.move( 5, 0, 0 )
cmds.delete( 'plg1.f[9:17]' )
cmds.polyTriangulate( 'plg1.f[0:44]' )
cmds.delete( 'plg2.f[9:17]' )
cmds.polyTriangulate( 'plg2.f[0:44]' )
cmds.polyMoveVertex( 'plg1.vtx[20:35]', ltz=2.5 )
cmds.polyMoveVertex( 'plg2.vtx[20:35]', ltz=2.5 )

---
Only coplanar triangles will be merged.
cmds.polyQuad( 'plg1.f[0:89]', a=0.0 )

---
All possible triangles will be merged.
cmds.polyQuad( 'plg2.f[0:89]', a=180.0 )

---
Return:
---


    string: The node name.

Flags:
---


---
angle(a): angle
    properties: create, query, edit
    Angle threshold above which two triangles are not merged.
C: Default is 30 degrees. The range is [0.0, 180.0].
Q: When queried, this flag returns a float.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
keepGroupBorder(kgb): boolean
    properties: create, query, edit
    Keep facet group border :
If "on", the borders of selected faces are maintained,
otherwise the borders of selected facets may be modified.
C: Default is "on".
Q: When queried, this flag returns an int.

---
keepHardEdges(khe): boolean
    properties: create, query, edit
    Keep hard edges :
If "on", the hard edges of selected faces are maintained,
otherwise they may be deleted between two triangles.
C: Default is "on".
Q: When queried, this flag returns an int.

---
keepTextureBorders(ktb): boolean
    properties: create, query, edit
    Keep texture border :
If "on", the borders of texture maps are maintained,
otherwise the boreders of texture maps may be modified.
C: Default is "on".
Q: When queried, this flag returns an int.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyQuad.html 
    """


def polyQueryBlindData(flagassociationType: string, flagbinaryData: string, flagbooleanData: boolean, flagdoubleData: float, flagintData: int, flaglongDataName: string, flagmaxValue: float, flagminValue: float, flagshortDataName: string, flagshowComp: boolean, flagstringData: string, flagsubString: string, flagtypeId: int) -> string:
    """Synopsis:
---
---
 polyQueryBlindData([associationType=string], [binaryData=string], [booleanData=boolean], [doubleData=float], [intData=int], [longDataName=string], [maxValue=float], [minValue=float], [shortDataName=string], [showComp=boolean], [stringData=string], [subString=string], [typeId=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyQueryBlindData is NOT undoable, NOT queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

cmds.polyQueryBlindData( 'pPlane1.vtx[2]', 'pPlane1.vtx[8]', id=9001, associationType='vertex', ldn='bdFloat', dbd=234 )

cmds.polyQueryBlindData( id=9005, sc='pPlane1.vtx[0:100]' )

cmds.polyQueryBlindData( 'pPlane1.f[0:10]', sc='pPlane1.vtx[0:100]' )

---
Return:
---


    string: Blind data

Flags:
---


---
associationType(at): string
    properties: create
    Specifies the dataTypes that are part of BlindData node being queried.
Allowable associations are "object" for any object, and "vertex" "edge" and
"face" for mesh objects.

---
binaryData(bnd): string
    properties: create
    Specifies the binary string value to search for

---
booleanData(bd): boolean
    properties: create
    Specifies the string value to search for

---
doubleData(dbd): float
    properties: create
    Specifies the double/float value to search for

---
intData(ind): int
    properties: create
    Specifies the integer value to search for

---
longDataName(ldn): string
    properties: create, multiuse
    Specifies the long name of the data that is being queried by this command.

---
maxValue(max): float
    properties: create
    Specifies the maximum value to search for.  This option will query float,
double, and integer types of blind data.

---
minValue(min): float
    properties: create
    Specifies the minimum value to search for.  This option will query float,
double and integer types of blind data.

---
shortDataName(sdn): string
    properties: create, multiuse
    Specifies the short name of the data that is being queried by this command.

---
showComp(sc): boolean
    properties: create
    The showComponent option controls whether the object.[component].attribute
name is output preceeding the actual value.  If the showComponent option
is used then the restriction of only returning 1 type of blind data (i.e.
one of integer, float, double... is removed, as the return for all are
strings.
If the association is object and not component, then this option will
still cause all the attribute names to be printed

---
stringData(sd): string
    properties: create
    Specifies the string value to search for

---
subString(ss): string
    properties: create
    Specifies the substring that should be checked against a STRING type blind
data.  If the sub string is found query is successful.  Will not look at non
String type blind data elements.

---
typeId(id): int
    properties: create
    Specifies the typeId of the BlindData type being queried.  If the typeId
is not specified, then all of the components that match the query will be
output.  The typeId of the elements found will be output if the ShowComponents
option is used.  Will be in the format "object.component.attribute::typeId".
If the typeId is specifed then the "::typeId" portion will not be output with
the ShowComponents option.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyQueryBlindData.html 
    """


def polyReduce(flagcaching: boolean, flagcachingReduce: boolean, flagcolorWeights: float, flagcompactness: float, flagconstructionHistory: boolean, flaggeomWeights: float, flaginvertVertexWeights: boolean, flagkeepBorder: boolean, flagkeepBorderWeight: float, flagkeepColorBorder: boolean, flagkeepColorBorderWeight: float, flagkeepCreaseEdge: boolean, flagkeepCreaseEdgeWeight: float, flagkeepFaceGroupBorder: boolean, flagkeepFaceGroupBorderWeight: float, flagkeepHardEdge: boolean, flagkeepHardEdgeWeight: float, flagkeepMapBorder: boolean, flagkeepMapBorderWeight: float, flagkeepOriginalVertices: boolean, flagkeepQuadsWeight: float, flagname: string, flagnodeState: int, flagpercentage: float, flagpreserveLocation: boolean, flagpreserveTopology: boolean, flagreplaceOriginal: boolean, flagsharpness: float, flagsymmetryPlaneW: float, flagsymmetryPlaneX: float, flagsymmetryPlaneY: float, flagsymmetryPlaneZ: float, flagsymmetryTolerance: float, flagtermination: int, flagtriangleCount: int, flagtriangulate: boolean, flaguseVirtualSymmetry: int, flaguvWeights: float, flagversion: int, flagvertexCount: int, flagvertexMapName: string, flagvertexWeightCoefficient: float, flagweightCoefficient: float) -> string:
    """Synopsis:
---
---
 polyReduce([caching=boolean], [cachingReduce=boolean], [colorWeights=float], [compactness=float], [constructionHistory=boolean], [geomWeights=float], [invertVertexWeights=boolean], [keepBorder=boolean], [keepBorderWeight=float], [keepColorBorder=boolean], [keepColorBorderWeight=float], [keepCreaseEdge=boolean], [keepCreaseEdgeWeight=float], [keepFaceGroupBorder=boolean], [keepFaceGroupBorderWeight=float], [keepHardEdge=boolean], [keepHardEdgeWeight=float], [keepMapBorder=boolean], [keepMapBorderWeight=float], [keepOriginalVertices=boolean], [keepQuadsWeight=float], [name=string], [nodeState=int], [percentage=float], [preserveLocation=boolean], [preserveTopology=boolean], [replaceOriginal=boolean], [sharpness=float], [symmetryPlaneW=float], [symmetryPlaneX=float], [symmetryPlaneY=float], [symmetryPlaneZ=float], [symmetryTolerance=float], [termination=int], [triangleCount=int], [triangulate=boolean], [useVirtualSymmetry=int], [uvWeights=float], [version=int], [vertexCount=int], [vertexMapName=string], [vertexWeightCoefficient=float], [weightCoefficient=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyReduce is undoable, queryable, and editable.
The algorithm for polyReduce was changed in 2014 to use a new algorithm derived
from Softimage. However, the command still defaults to using the old algorithm
for backwards compatibility.  Therefore, we recommend setting the version flag
to 1 for best results as the new algorithm is better at preserving geometry
features.  Additionally, some flags only apply to a specific algorithm and
this is documented for each flag.




Example:
---
import maya.cmds as cmds

cmds.polySphere( ver=1, n='plg' )
cmds.polyReduce( ver=1, p=35, 'plg.f[0:399]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
cachingReduce(cr): boolean
    properties: create, query, edit
    Cache intermediate reductions for speed at the expense of memory.
It is recommended that caching be enabled when using the new
algorithm. (-version 1)  However, caching is not recommended
when using then old algorithm because it can cause stability
issues.
C: Default is false.
Q: When queried, this flag returns a boolean.

---
colorWeights(cwt): float
    properties: create, query, edit
    This flag only applies when using the old algorithm and
is provided for backwards compatibility.
How much consideration vertex color is given in the reduction
algorithm. A higher weight means the reduction will try
harder to preserve vertex coloring.
C: Default is 0.
Q: When queried, this flag returns a float.

---
compactness(com): float
    properties: create, query, edit
    This flag only applies when using the old algorithm and
is provided for backwards compatibility.
Tolerance for compactness for the generated triangles
A value of 0 will accept all triangles during decimation
A value close to 0 will attempt to eliminate triangles
that have collinear edges (zero area triangles)
A value closer to 1 will attempt to eliminate triangles
that are not strictly equilateral (of equal lengths)
The closer to 1.0, the more expensive the computation
Q: When queried, this flag returns a float.

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
geomWeights(gwt): float
    properties: create, query, edit
    This flag only applies when using the old algorithm and
is provided for backwards compatibility.
How much consideration vertex positions are given in the
reduction algorithm.  A higher weight means the reduction
will try harder to preserve geometry.
C: Default is 1.
Q: When queried, this flag returns a float.

---
invertVertexWeights(iwt): boolean
    properties: create, query, edit
    This flag controls how weight map values are interpreted.
If true, a vertex weight of 1.0 means a vertex is unlikely to be reduced.
If false, a vertex weight of 0.0 means a vertex is unlikely to be reduced.
This flag only applies when using the new algorithm. (-version 1)
C: Default is true.
Q: When queried, this flag returns a boolean.

---
keepBorder(kb): boolean
    properties: create, query, edit
    If true, reduction will try to retain geometric borders and
the border of the selection.
C: Default is true.
Q: When queried, this flag returns a boolean.

---
keepBorderWeight(kbw): float
    properties: create, query, edit
    If keepBorder is on, this flag specifies the weight to assign
to borders.  Setting this value to 0 will disable border preservation
and a value of 1 will exactly preserve all border vertices which is
useful for matching adjacent meshes.  This flag only applies
when using the new algorithm. (-version 1)
C: Default is 0.5.
Q: When queried, this flag returns a float.

---
keepColorBorder(kcb): boolean
    properties: create, query, edit
    If true, reduction will try to retain color borders.  These are
determined according to color Ids.  This flag only applies
when using the new algorithm. (-version 1)
C: Default is true.
Q: When queried, this flag returns a boolean.

---
keepColorBorderWeight(kcw): float
    properties: create, query, edit
    If keepColorBorder is on, this flag specifies the weight to
assign to color borders.  Setting this value to 0 will disable
color border preservation and a value of 1 will exactly preserve
all color borders.  This flag only applies when using the new
algorithm. (-version 1)
C: Default is 0.5.
Q: When queried, this flag returns a float.

---
keepCreaseEdge(kce): boolean
    properties: create, query, edit
    If true, reduction will try to retain crease edges.
C: Default is true.  This flag only applies
when using the new algorithm. (-version 1)
C: Default is true.
Q: When queried, this flag returns a boolean.

---
keepCreaseEdgeWeight(cew): float
    properties: create, query, edit
    If keepCreaseEdge is on, this flag specifies the weight to assign
to crease edges.  Setting this value to 0 will disable crease
edge preservation and a value of 1 will exactly preserve all crease edges.
This flag only applies when using the new algorithm. (-version 1)
C: Default is 0.5.
Q: When queried, this flag returns a float.

---
keepFaceGroupBorder(kfb): boolean
    properties: create, query, edit
    If true, reduction will try to retain borders of face groups,
which are mostly used to define material assignments.  This
flag only applies when using the new algorithm. (-version 1)
C: Default is true.
Q: When queried, this flag returns a boolean.

---
keepFaceGroupBorderWeight(kfw): float
    properties: create, query, edit
    If keepFaceGroupBorder is on, this flag specifies the weight to
assign to material borders.  Setting this value to 0 will disable
group border preservation and a value of 1 will exactly preserve all
group borders.  This flag only applies when using the new
algorithm. (-version 1)
C: Default is 0.5.
Q: When queried, this flag returns a float.

---
keepHardEdge(khe): boolean
    properties: create, query, edit
    If true, reduction will try to retain hard edges.
C: Default is true.
Q: When queried, this flag returns a boolean.

---
keepHardEdgeWeight(khw): float
    properties: create, query, edit
    If keepHardEdge is on, this flag specifies the weight to assign
to hard edges.  Setting this value to 0 will disable hard
edge preservation and a value of 1 will exactly preserve all hard edges.
This flag only applies when using the new algorithm. (-version 1)
C: Default is 0.5.
Q: When queried, this flag returns a float.

---
keepMapBorder(kmb): boolean
    properties: create, query, edit
    If true, reduction will try to retain UV borders.  A UV border
is present if the faces on either side of the edge do not share
UV Ids.
C: Default is true.
Q: When queried, this flag returns a boolean.

---
keepMapBorderWeight(kmw): float
    properties: create, query, edit
    If keepMapBorder is on, this flag specifies the weight to assign
to UV map borders.  Setting this value to 0 will disable UV map
border preservation and a value of 1 will exactly preserve all UV borders.
This flag only applies when using the new algorithm. (-version 1)
C: Default is 0.5.
Q: When queried, this flag returns a float.

---
keepOriginalVertices(kev): boolean
    properties: create, query, edit
    This flag only applies when using the old algorithm and
is provided for backwards compatibility.
If true, vertices will try to retain their original positions
and will not be repositioned for optimal shape.
NOTE: In the newer algorithm vertices always retain
their exact original positions. (though the Ids will change)
C: Default is false.
Q: When queried, this flag returns a boolean.

---
keepQuadsWeight(kqw): float
    properties: create, query, edit
    This flag controls how much consideration is given to
oreserving quad faces during reduction.  A higher
weight means the reduction will try harder to keep quad
faces and avoid creation of triangles. If the version
flag is set to 1 (-version 1) and the keepQuadsWeight
flag is set to 1.0 then a special quad reduction algorithm
is used that does a better job of preserving quads.
Howver, this special quad reduction algorithm does
not support symmetry so those flags will be ignored
when the keepQuadsWeight flag is set to 1.0.
C: Default is 0.
Q: When queried, this flag returns a float.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
percentage(p): float
    properties: create, query, edit
    This flag specifies how many vertices to remove during reduction as a
percentage of the original mesh.  This flag only applies if the termination
flag is set to 0 or when using the old algorithm.
C: Default is 0. 100 will remove every possible vertex, 0 will remove none.
Q: When queried, this flag returns a float.

---
preserveLocation(pl): boolean
    properties: create
    This flag guarantees that if the original geometry is preserved, the new
geometry will have the same location.
C: Default is false.

---
preserveTopology(top): boolean
    properties: create, query, edit
    this flag guarantees that the topological type will be preserved during
reduction.  In particular, if the input is manifold then the output will be
manifold.  This option also prevents holes in the mesh from being closed off.
This flag only applies when using the new algorithm. (-version 1)
C: Default is true.
Q: When queried, this flag returns a boolean.

---
replaceOriginal(rpo): boolean
    properties: create
    Create "in place" (i.e., replace) (not available in all commands). NOTE:
This flag is intended for use by the "Reduce" menu item. If
'polyReduce -rpo 0' is executed from the command line, Shader information will
not be copied from the original mesh to the result.

---
sharpness(shp): float
    properties: create, query, edit
    Sharpness controls the balance between preserving small, sharp
details versus larger shapes.  At low values, details that are
small relative to the general shape of the object are more
likely to be collapsed.  At high values, they are more likely
to be kept.  This flag only applies when using the new
algorithm. (-version 1)
C: Default is 0.
Q: When queried, this flag returns a float.

---
symmetryPlaneW(sw): float
    properties: create, query, edit
    W value of the symmetry plane.  This flag only applies
when using the new algorithm (-version 1) and the
useVirtualSymmetry flag is set to 2.
C: Default is 0.
Q: When queried, this flag returns a float.

---
symmetryPlaneX(sx): float
    properties: create, query, edit
    X value of the symmetry plane.  This flag only applies
when using the new algorithm (-version 1) and the
useVirtualSymmetry flag is set to 2.
C: Default is 0.
Q: When queried, this flag returns a float.

---
symmetryPlaneY(sy): float
    properties: create, query, edit
    Y value of the symmetry plane.  This flag only applies
when using the new algorithm (-version 1) and the
useVirtualSymmetry flag is set to 2.
C: Default is 0.
Q: When queried, this flag returns a float.

---
symmetryPlaneZ(sz): float
    properties: create, query, edit
    Z value of the symmetry plane.  This flag only applies
when using the new algorithm (-version 1) and the
useVirtualSymmetry flag is set to 2.
C: Default is 0.
Q: When queried, this flag returns a float.

---
symmetryTolerance(stl): float
    properties: create, query, edit
    Tolerance to use when applying symmetry.
For each vertex of the mesh, we find its exact symmetric point,
then we look for the closest vertex to the exact symmetry up to
the tolerance distance.  Higher values risk finding more
spurious symmetries, lower values might miss symmetries.
The value is distance in object space.  This flag only applies
when using the new algorithm (-version 1) and the
useVirtualSymmetry flag is not set to 0.
C: Default is 0.
Q: When queried, this flag returns a float.

---
termination(trm): int
    properties: create, query, edit
    This flag specifies the termination condition to use
when reducing the mesh.  This flag only applies to the
new algorithm. (-version 1)
0 Percentage
1 Vertex count
2 Triangle count
C: Default is 0.
Q: When queried, this flag returns an integer.

---
triangleCount(tct): int
    properties: create, query, edit
    This flag specifies a target number of triangles to retain after reduction.
Note that other factors such as quad and feature preservation
may take precendence and cause the actual number of triangles to be different.
This flag only applies when using the new algorithm (-version 1)
and the termination flag is set to 2.
C: Default is 0.
Q: When queried, this flag returns an integer.

---
triangulate(t): boolean
    properties: create, query, edit
    This flag only applies when using the old algorithm and
is provided for backwards compatibility.
This attribute specifies if the geometry
or the selected faces has to be triangulated,
before performing reduction.
C: Default is true.
Q: When queried, this flag returns a boolean.

---
useVirtualSymmetry(uvs): int
    properties: create, query, edit
    This flag controls whether symmetry is preserved during the
reduction. This flag only applies when using the new
algorithm (-version 1) and the keepQuadsWeight flag is less
than 1.0.
0 No symmetry preservation
1 Automatic. Try to find suitable symmetry during reduction.
2 Plane.  Specify a symmetry plane to use during reduction.
C: Default is 0.
Q: When queried, this flag returns an integer.

---
uvWeights(uwt): float
    properties: create, query, edit
    This flag only applies when using the old algorithm and
is provided for backwards compatibility.
How much consideration uv positions are given in the
reduction algorithm. A higher weight means the
reduction will try harder to preserve uv positions.
C: Default is 0.
Q: When queried, this flag returns a float.

---
version(ver): int
    properties: create, query, edit
    Version of the poly reduce algorithm to use.
0 Old algorithm used in Maya 2013 and prior for backwards compatibility
1 New algorithm derived from Softimage and used in Maya 2014 and later
The default is 0 for backwards compatibility but for best results
it is recommended that the new algorithm is used as it is better at
preserving mesh details. Some flags only apply to a specific algorithm
and this is documented for each flag.
C: Default is 0 for backwards compatibility.
Q: When queried, this flag returns an integer.

---
vertexCount(vct): int
    properties: create, query, edit
    This flag specifies a target number of vertices to retain after reduction.
Note that other factors such as quad and feature preservation
may take precendence and cause the actual number of vertices to be different.
This flag only applies when using the new algorithm (-version 1)
and the termination flag is set to 1.
C: Default is 0.
Q: When queried, this flag returns an integer.

---
vertexMapName(vmp): string
    properties: create, query
    Name of a color set to be added to the output mesh that stores
a mapping from vertices in the output mesh to vertices in the
input mesh.  The color set is RGB.  The original vertex Id that
maps to an output vertex is of a vertex is 65536*r + g where r
and g are the red and green channel at a vertex. The blue
channel is always zero.  Each vertex in the output mesh has a
shared color. This flag only applies when using the new
algorithm. (-version 1)
Q: When queried, this flag returns a string.

---
vertexWeightCoefficient(vwc): float
    properties: create, query, edit
    This flag specifies a constant value to multiply to each weight map value.
A value of zero turns off the weight map.  This flag only applies
when using the new algorithm. (-version 1)
C: Default is 1.
Q: When queried, this flag returns a float.

---
weightCoefficient(wc): float
    properties: create, query, edit
    This flag only applies when using the old algorithm and
is provided for backwards compatibility.
The weight of each vertex is multiplied with this coefficient
when the reduction is performed.  This value does not have
to be edited, normally.  It gives finer control over the
weighted reduction. This attribute is replaced by
vertexWeightCoefficient in the new algorithm when the version
flag is set to 1.
C: Default is 10000.
Q: When queried, this flag returns a float.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyReduce.html 
    """


def polyRemesh(flagcaching: boolean, flagcollapseThreshold: float, flagconstructionHistory: boolean, flaginterpolationType: int, flagmaxEdgeLength: float, flagname: string, flagnodeState: int, flagsmoothStrength: float, flagtessellateBorders: boolean, flaguseRelativeValues: boolean) -> string:
    """Synopsis:
---
---
 polyRemesh([caching=boolean], [collapseThreshold=float], [constructionHistory=boolean], [interpolationType=int], [maxEdgeLength=float], [name=string], [nodeState=int], [smoothStrength=float], [tessellateBorders=boolean], [useRelativeValues=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyRemesh is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polySphere( r=10 )
cmds.polyRemesh( maxEdgeLength=1 )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
collapseThreshold(cot): float
    properties: create, query, edit
    A percentage of the maxEdgeLength. Edges shorter than this percentage will be reduced to a single vertex.

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
interpolationType(ipt): int
    properties: create, query, edit
    Algorithm used for interpolating new vertices

---
maxEdgeLength(mel): float
    properties: create, query, edit
    Triangle edges longer than this value will be split into two edges.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
smoothStrength(smt): float
    properties: create, query, edit
    Amount of smoothing applied to the vertices after remeshing.

---
tessellateBorders(tsb): boolean
    properties: create, query, edit
    Specifies if the borders of the selected region are allowed to be remeshed.

---
useRelativeValues(urv): boolean
    properties: create, query, edit
    Specifies if the refine threshold value is relative to the average edge length of the input mesh.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyRemesh.html 
    """


def polyRetopo() -> string:
    """Synopsis:
---
---
 polyRetopo()  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyRetopo is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.polyRetopo

---
Return:
---


    string: The node name.

Flags:
---


URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyRetopo.html 
    """


def polySelect(flagadd: boolean, flagaddFirst: boolean, flagasSelectString: boolean, flagdeselect: boolean, flagedgeBorder: uint, flagedgeBorderPath: tuple[int, int], flagedgeBorderPattern: tuple[int, int], flagedgeLoop: uint, flagedgeLoopOrBorder: uint, flagedgeLoopOrBorderPattern: tuple[int, int], flagedgeLoopPath: tuple[int, int], flagedgeLoopPattern: tuple[int, int], flagedgeRing: uint, flagedgeRingPath: tuple[int, int], flagedgeRingPattern: tuple[int, int], flagedgeUVLoopOrBorder: uint, flageveryN: uint, flagextendToShell: uint, flagnoSelection: boolean, flagreplace: boolean, flagshortestEdgePath: tuple[int, int], flagshortestEdgePathUV: tuple[int, int], flagshortestFacePath: tuple[int, int], flagtoggle: boolean) -> list[int]:
    """Synopsis:
---
---
 polySelect([add=boolean], [addFirst=boolean], [asSelectString=boolean], [deselect=boolean], [edgeBorder=uint], [edgeBorderPath=[int, int]], [edgeBorderPattern=[int, int]], [edgeLoop=uint], [edgeLoopOrBorder=uint], [edgeLoopOrBorderPattern=[int, int]], [edgeLoopPath=[int, int]], [edgeLoopPattern=[int, int]], [edgeRing=uint], [edgeRingPath=[int, int]], [edgeRingPattern=[int, int]], [edgeUVLoopOrBorder=uint], [everyN=uint], [extendToShell=uint], [noSelection=boolean], [replace=boolean], [shortestEdgePath=[int, int]], [shortestEdgePathUV=[int, int]], [shortestFacePath=[int, int]], [toggle=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySelect is undoable, queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

cmds.polySelect( 'pCube1', edgeRing=1 )
cmds.polySelect( 'pCube1', toggle=True, edgeRingPath=(1, 10) )
cmds.polySelect( 'pCube1', ns=True, edgeRingPath=(1, 10) )
cmds.polySelect( 'pCube1', edgeRingPath=((1, 10), (11, 20)) )
cmds.polySelect( 'pPlane1', shortestEdgePath=(10, 100) )

---
Return:
---


    list[int]: List of selected components.

Flags:
---


---
add(add): boolean
    properties: create, query
    Indicates that the specified items should be
added to the active list without removing existing
items from the active list.

---
addFirst(af): boolean
    properties: create, query
    Indicates that the specified items should be
added to the front of the active list without
removing existing items from the active list.

---
asSelectString(ass): boolean
    properties: create, query
    Changes the return type from an integer array to
a string array which can be used as a selection string.

---
deselect(d): boolean
    properties: create, query
    Indicates that the specified items should
be removed from the active list if they are on the
active list.

---
edgeBorder(eb): uint
    properties: create, query, multiuse
    Select all conected border edges starting at the given edge.
      In query mode, this flag needs a value.

---
edgeBorderPath(ebp): [int, int]
    properties: create, query, multiuse
    Given two edges on the same border, this will select
the edges on the border in the path between them.
      In query mode, this flag needs a value.

---
edgeBorderPattern(bpt): [int, int]
    properties: create, query, multiuse
    Given two edges on the same border, this will check how
many edges there are between the given edges and then
continue that pattern of selection around the border.
      In query mode, this flag needs a value.

---
edgeLoop(el): uint
    properties: create, query, multiuse
    Select an edge loop starting at the given edge.
      In query mode, this flag needs a value.

---
edgeLoopOrBorder(elb): uint
    properties: create, query, multiuse
    Select an edge loop or all conected border edges,
depending on whether the edge is on a border or not,
starting at the given edge.
      In query mode, this flag needs a value.

---
edgeLoopOrBorderPattern(lbp): [int, int]
    properties: create, query, multiuse
    Given two edges either on the same edge loop or on the
same edge border, this will check how many edges there
are between the given edges and then continue that pattern
of selection around the edge loop or edge border.
      In query mode, this flag needs a value.

---
edgeLoopPath(elp): [int, int]
    properties: create, query, multiuse
    Given two edges that are on the same edge loop, this
will select the shortest path between them on the loop.
      In query mode, this flag needs a value.

---
edgeLoopPattern(lpt): [int, int]
    properties: create, query, multiuse
    Given two edges on the same edge loop, this will check how
many edges there are between the given edges and then
continue that pattern of selection around the edge loop.
      In query mode, this flag needs a value.

---
edgeRing(er): uint
    properties: create, query, multiuse
    Select an edge ring starting at the given edge.
      In query mode, this flag needs a value.

---
edgeRingPath(erp): [int, int]
    properties: create, query, multiuse
    Given two edges that are on the same edge ring, this
will select the shortest path between them on the ring.
      In query mode, this flag needs a value.

---
edgeRingPattern(rpt): [int, int]
    properties: create, query, multiuse
    Given two edges on the same edge ring, this will check how
many edges there are between the given edges and then
continue that pattern of selection around the edge ring.
      In query mode, this flag needs a value.

---
edgeUVLoopOrBorder(euv): uint
    properties: create, query, multiuse
    Select an edge loop or border, terminating at UV borders.
      In query mode, this flag needs a value.

---
everyN(en): uint
    properties: create
    Number of elements to stride over. If less than 1 then
use 1, meaning every element. 2 means every second one, etc.

---
extendToShell(ets): uint
    properties: create, query, multiuse
    Select the poly shell given a face id.
      In query mode, this flag needs a value.

---
noSelection(ns): boolean
    properties: create, query
    If this flag is used then the selection is not
changed at all.

---
replace(r): boolean
    properties: create, query
    Indicates that the specified items should
replace the existing items on the active list.

---
shortestEdgePath(sep): [int, int]
    properties: create, query, multiuse
    Given two vertices, this will select the shortest path
between them in the 3d object space.
      In query mode, this flag needs a value.

---
shortestEdgePathUV(spu): [int, int]
    properties: create, query, multiuse
    Given two UVs, this will select the shortest path
between them in the 2d texture space.
      In query mode, this flag needs a value.

---
shortestFacePath(sfp): [int, int]
    properties: create, query, multiuse
    Given two faces, this will select the shortest path
between them in the 3d object space.
      In query mode, this flag needs a value.

---
toggle(tgl): boolean
    properties: create, query
    Indicates that those items on the given list which
are on the active list should be removed from the active
list and those items on the given list which are not on
the active list should be added to the active list.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySelect.html 
    """


def polySelectConstraint(flagangle: int, flaganglePropagation: boolean, flagangleTolerance: float, flaganglebound: tuple[angle, angle], flagborder: boolean, flagborderPropagation: boolean, flagconvexity: int, flagcrease: boolean, flagdisable: boolean, flagdist: int, flagdistaxis: tuple[float, float, float], flagdistbound: tuple[float, float], flagdistpoint: tuple[float, float, float], flagedgeDistance: uint, flaggeometricarea: int, flaggeometricareabound: tuple[float, float], flagholes: int, flaglength: int, flaglengthbound: tuple[float, float], flagloopPropagation: boolean, flagmax2dAngle: float, flagmax3dAngle: float, flagmode: int, flagnonmanifold: int, flagoppositeEdges: boolean, flagorder: int, flagorderbound: tuple[int, int], flagorient: int, flagorientaxis: tuple[float, float, float], flagorientbound: tuple[float, float], flagplanarity: int, flagpropagate: int, flagrandom: int, flagrandomratio: float, flagreturnSelection: boolean, flagringPropagation: boolean, flagshell: boolean, flagsize: int, flagsmoothness: int, flagstateString: boolean, flagtextured: int, flagtexturedarea: int, flagtexturedareabound: tuple[float, float], flagtextureshared: int, flagtopology: int, flagtype: int, flaguvBorderSelection: boolean, flaguvConstraint: boolean, flaguvEdgeLoopPropagation: boolean, flaguvEdgeRingPropagation: boolean, flaguvFaceOrientation: int, flaguvShell: boolean, flagvisibility: int, flagvisibilityangle: angle, flagvisibilitypoint: tuple[float, float, float], flagwhere: int, flagwholeSensitive: boolean) -> None:
    """Synopsis:
---
---
 polySelectConstraint([angle=int], [anglePropagation=boolean], [angleTolerance=float], [anglebound=[angle, angle]], [border=boolean], [borderPropagation=boolean], [convexity=int], [crease=boolean], [disable=boolean], [dist=int], [distaxis=[float, float, float]], [distbound=[float, float]], [distpoint=[float, float, float]], [edgeDistance=uint], [geometricarea=int], [geometricareabound=[float, float]], [holes=int], [length=int], [lengthbound=[float, float]], [loopPropagation=boolean], [max2dAngle=float], [max3dAngle=float], [mode=int], [nonmanifold=int], [oppositeEdges=boolean], [order=int], [orderbound=[int, int]], [orient=int], [orientaxis=[float, float, float]], [orientbound=[float, float]], [planarity=int], [propagate=int], [random=int], [randomratio=float], [returnSelection=boolean], [ringPropagation=boolean], [shell=boolean], [size=int], [smoothness=int], [stateString=boolean], [textured=int], [texturedarea=int], [texturedareabound=[float, float]], [textureshared=int], [topology=int], [type=int], [uvBorderSelection=boolean], [uvConstraint=boolean], [uvEdgeLoopPropagation=boolean], [uvEdgeRingPropagation=boolean], [uvFaceOrientation=int], [uvShell=boolean], [visibility=int], [visibilityangle=angle], [visibilitypoint=[float, float, float]], [where=int], [wholeSensitive=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySelectConstraint is undoable, queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

cmds.selectMode( co=True )

<b>Propagation</b>

cmds.polyPlane( n='plg', w=5, h=5 )
cmds.delete( 'plg.f[20:29]' )
cmds.selectType( pf=True )
cmds.polySelectConstraint( sh=True ) next mouse selections will propagate to all shell
cmds.polySelectConstraint( sh=False )
cmds.polySelectConstraint( bo=True ) next mouse selections will propagate along border
cmds.polySelectConstraint( bo=False )
cmds.polySelectConstraint( cr=True ) next mouse selections will propagate to all connected creased components
cmds.polySelectConstraint( cr=False )

cmds.select( 'plg.f[54:55]' )
cmds.polySelectConstraint( pp=1 )
cmds.polySelectConstraint( pp=1 ) to get more and more
cmds.polySelectConstraint( pp=1 )
cmds.polySelectConstraint( pp=2 ) to get less
cmds.polySelectConstraint( pp=3 ) to get selection border
cmds.delete( 'plg' )

<b>Propagation along loop</b>

cmds.polyPlane( n='plg', w=5, h=5 )
cmds.selectType( pf=True )
cmds.select( 'plg.f[42:43]', 'plg.f[53]', 'plg.f[76]' )
cmds.polySelectConstraint( pp=5 ) grow face selection along loop
cmds.polySelectConstraint( pp=6 ) shrink face selection along loop
cmds.delete( 'plg' )

cmds.polyPlane( n='plg', w=5, h=5 )
cmds.selectType( pe=True )
cmds.select( 'plg.e[113]', 'plg.e[115:116]' )
cmds.polySelectConstraint( pp=5 ) grow edge selection along loop
cmds.polySelectConstraint( pp=6 ) shrink edge selection along loop
cmds.delete( 'plg' )

cmds.polyPlane( n='plg', w=5, h=5 )
cmds.selectType( pv=True )
cmds.select( 'plg.vtx[59:61]' )
cmds.polySelectConstraint( pp=5 ) grow vertex selection along loop
cmds.polySelectConstraint( pp=6 ) shrink vertex selection along loop
cmds.delete( 'plg' )

cmds.polyPlane( n='plg', w=5, h=5 )
cmds.selectType( puv=True )
cmds.select( 'plg.map[71]', 'plg.map[59:60]' )
cmds.polySelectConstraint( pp=5 ) grow UV selection along loop
cmds.polySelectConstraint( pp=6 ) shrink UV selection along loop
cmds.delete( 'plg' )

---
<b>Properties</b>

---
location
cmds.polyPlane( n='plg', w=5, h=5 )
cmds.selectType( pv=True )
cmds.polySelectConstraint( m=3, t=1, w=1 ) to get border vertices
cmds.polySelectConstraint( m=3, t=1, w=2 ) to get inner vertices
cmds.polySelectConstraint( w=0 ) turn off location constraint
cmds.delete( 'plg' )

---
edge smoothness
cmds.polyCylinder( n='plg' )
cmds.selectType( pe=True )
cmds.polySelectConstraint( m=3, t=0x8000, sm=1 ) to get hard edges
cmds.polySelectConstraint( m=3, t=0x8000, sm=2 ) to get soft edges
cmds.polySelectConstraint( sm=0 ) turn off edge smoothness constraint
cmds.delete( 'plg' )

---
face size
cmds.polyCylinder( n='plg', sz=1 )
cmds.delete( 'plg.f[40:59]' )
cmds.polyCloseBorder( 'plg.e[27]' )
cmds.selectType( pf=True )
cmds.polySelectConstraint( m=3, t=8, sz=1 ) to get triangles
cmds.polySelectConstraint( m=3, t=8, sz=2 ) to get quads
cmds.polySelectConstraint( m=3, t=8, sz=3 ) to get N-sided
cmds.polySelectConstraint( sz=0 ) turn off face size constraint
cmds.delete( 'plg' )

---
face planarity
   polyPlane -n plg -w 5 -h 5; polyMoveVertex -ltz 1 plg.vtx[79] plg.vtx[85];
cmds.selectType( pf=True )
cmds.polySelectConstraint( m=3, t=8, p=1 ) to get non-planar faces
cmds.polySelectConstraint( m=3, t=8, p=2 ) to get planar faces
cmds.polySelectConstraint( p=0 ) turn off face planarity constraint
cmds.delete( 'plg' )

---
face convexity
cmds.polyPlane( n='plg', w=5, h=5 )
cmds.delete( 'plg.f[51]', 'plg.f[61]', 'plg.f[52:53]' )
cmds.polyCloseBorder( 'plg.e[146]' )
cmds.selectType( pf=True )
cmds.polySelectConstraint( m=3, t=8, c=1 )to get non-convex faces
cmds.polySelectConstraint( m=3, t=8, c=2 )to get convex faces
cmds.polySelectConstraint( c=0 ) turn off face convexity constraint
cmds.delete( 'plg' )

---
face holes
cmds.polyCreateFacet( n='plg', p=[(-2, 2, 0), (-2, -2, 0), (2, -2, 0), (2, 2, 0)] )
cmds.polyAppend( a=[2, (6, -2, 0), (6, 2, 0), (), (3, 1, 0), (3, -1, 0), (5, 0, 0)] )
cmds.selectType( pf=True )
cmds.polySelectConstraint( m=3, t=8, h=1 )to get holed faces
cmds.polySelectConstraint( m=3, t=8, h=2 )to get non-holed faces
cmds.polySelectConstraint( h=0 )turn off hole constraint
cmds.delete( 'plg' )

---
face mapping
cmds.polyPlane( n='plg', w=5, h=5 )
cmds.polyMapDel( 'plg.f[60:69]' )
cmds.selectType( pf=True )
cmds.polySelectConstraint( m=3, t=8, tx=1 ) to get mapped faces
cmds.polySelectConstraint( m=3, t=8, tx=2 ) to get non-mapped faces
cmds.polySelectConstraint( tx=0 ) turn off face mapping constraint
cmds.delete( 'plg' )

---
face topology
cmds.polyCreateFacet( n='plg', p=((-3, 3, 0),(-3, -3, 0),(3, -3, 0),(3, 3, 0)) )
cmds.polyAppend( a= [2, (8, -3, 0), (8, 3, 0)] )
cmds.polyAppend( a= (4, 6, 5 ) )
cmds.polyAppend( a =[0, (-7, 2, 0),(-7, -1, 0),(-8, 2, 0),(-5, 4, 0)] )
cmds.selectType( pf=True)
cmds.polySelectConstraint( m=3, t=8, tp=1 ) to get non triangulatable faces
cmds.polySelectConstraint( m=3, t=8, tp=2 ) to get lamina faces
cmds.polySelectConstraint( tp=0 ) turn off the face topology constraint
cmds.delete( 'plg' )

---
<b>Length</b>
cmds.polyCylinder( n='plg', sz=1, h=3 )
cmds.selectType( pe=True )
cmds.polySelectConstraint( m=3, t=0x8000, l=True, lb=(2, 4) ) to get edges of length 2 to 4 units
cmds.polySelectConstraint( m=3, t=0x8000, l=True, lb=(1, 2) ) to get edges of length 1 to 2 units
cmds.polySelectConstraint( l=False ) turn off the length constraint
cmds.delete( 'plg' )

---
<b>Angle</b>
cmds.polyCube( n='plg', w=5, h=5, d=5 )
cmds.polyBevel( 'plg.e[7]', sg=1 )
cmds.polyBevel( 'plg.e[9]', sg=3 )
cmds.selectType( pe=True )
cmds.polySelectConstraint( m=3, t=0x8000, a=True, ab=(0, 89) ) to get edges with angle between 0-89
cmds.polySelectConstraint( m=3, t=0x8000, a=True, ab=(45, 89) ) to get edges with angle between 45-89
cmds.polySelectConstraint( a=False ) turn off angle constraint
cmds.delete( 'plg' )

---
<b>3D Area</b>
cmds.polyPlane( n='plg', w=5, h=5 )
cmds.polyMoveFacet( 'plg.f[70:79]', ls=(.5, .5, 0) )
cmds.selectType( pf=True )
cmds.polySelectConstraint( m=3, t=8, ga=True, gab=(0, 0.2) ) to get faces with area between 0 and 0.2
cmds.polySelectConstraint( m=3, t=8, ga=True, gab=(0.2, 0.3) ) to get faces with area between 0 and 0.2
cmds.polySelectConstraint( ga=False ) turn off 3D area constraint
cmds.delete( 'plg' )

---
<b>2D area</b>
cmds.polyCylinder( n='plg' )
cmds.selectType( pf=True )
cmds.polySelectConstraint( m=3, t=8, ta=True, tab=(0, 0.5) ) to get face with texture area between 0-0.5
cmds.polySelectConstraint( ta=True ) turn off the 2D area constraint
cmds.delete( 'plg' )

---
<b>Distance</b>
cmds.polyPlane( n='plg', w=5, h=5 )
cmds.selectType( pv=True )
cmds.polySelectConstraint( m=3, t=1, d=1, db=(0, 5), dp=(5, 0, 0) ) to get vertices located
between 0-5 units from a given point
cmds.polySelectConstraint( m=3, t=1, d=1, db=(5, 5), dp=(5, 0, 0) ) to get vertices located
at exactly 5 units from a given point
cmds.polySelectConstraint( m=3, t=1, d=2, db=(5, 6), dp=(5, 0, 0) ) to get vertices located
between 5-6 units from a given axis
cmds.polySelectConstraint( d=0 )turn off the distance constraint
cmds.delete( 'plg' )

---
<b>Orientation</b>
cmds.polySphere( n='plg' )
cmds.selectType( pv=True' )
cmds.polySelectConstraint( m=3, t=1, o=1, ob=(0, 30), oa=(0, 1, 0) )to get vertices oriented between
0-30 degree to a given axis
cmds.polySelectConstraint( m=3, t=1, o=2, ob=(0, 30), oa=(0, 1, 0) )
cmds.polySelectConstraint( o=0 )turn off the orintation constraint
cmds.delete( 'plg' )

---
<b>Order (Neighbor)</b>
cmds.polyPlane( n='plg', w=5, h=5 )
cmds.selectType( pv=True )
cmds.polySelectConstraint( m=3, t=1, order=True, orb=(0, 2) ) to get vertices with 0 to 2 neighbors
cmds.polySelectConstraint( order=False ) turn off the order (neighbor) constraint
cmds.delete( 'plg' )

---
<b>Visibility</b>
cmds.polySphere( n='plg' )
cmds.selectType( pv=True )
cmds.polySelectConstraint( m=3, t=1, v=True, va=60, vp=(10, 0, 0) ) to get vertices in the 60 degree angle from a given point
cmds.polySelectConstraint( v=False ) turn off the visbility constraint
cmds.delete( 'plg' )

---
<b>Random</b>
cmds.polyPlane( n='plg', w=5, h=5 )
cmds.selectType( pv=True )
cmds.polySelectConstraint( m=3, t=1, r=True, rr=.5 )
cmds.polySelectConstraint( r= False ) turn off the random constraint
cmds.delete( 'plg' )

NOTE: Make sure you turn off the constraint you have used. Otherwise it may
affect your next selection (if <i>mode</i> flag is ON).

---


Flags:
---


---
angle(a): int
    properties: create, query
    0(off) 1(on).

---
anglePropagation(ap): boolean
    properties: create, query
    If true, selection will be extended to all connected components whose normal
is close to any of the normals of the original selection (see angleTolerance)

---
angleTolerance(at): float
    properties: create, query
    When angle propagation is turned on, this controls what is the maximum
difference of the normal vectors where the selection propagates.

---
anglebound(ab): [angle, angle]
    properties: create, query
    min and max angles.  The given value should be in the current units that
Maya is using.  See the examples for how to check the current unit.
For vertices :    angle between the 2 edges owning the vertex.
For edges :        angle between the 2 faces owning the edge.

---
border(bo): boolean
    properties: create, query
    Use "-uvConstraint true" to edit/query UV view constraint.
If true, selection will be extended to all connected border components
so that the whole "loop" is selected. It also removes all nonborder components
from the existing selection (compatibility mode)

---
borderPropagation(bp): boolean
    properties: create, query
    If true, selection will be extended to all connected border components
so that the whole "loop" is selected.

---
convexity(c): int
    properties: create, query
    0(off) 1(concave) 2(convex).

---
crease(cr): boolean
    properties: create, query
    If true, selection will be extended to all connected creased components.

---
disable(dis): boolean
    properties: create
    Toggles off all constraints for all component types, but
leaves the other constraint parameters. 
This flag may be used together with other ones toggling some
constraints on : if so, all constraints are
disabled first (no matter the position of the -disable flag in
the command line) then the specified ones are activated.

---
dist(d): int
    properties: create, query
    0(off) 1(to point) 2(to axis) 3(to plane).

---
distaxis(da): [float, float, float]
    properties: create, query
    axis. (Normal to the plane in case of distance to plane).

---
distbound(db): [float, float]
    properties: create, query
    min and max distances.

---
distpoint(dp): [float, float, float]
    properties: create, query
    point. (Axis/plane origin in case of distance to axis/plane).

---
edgeDistance(ed): uint
    properties: create
    Maximum distance (number of edges) to extend the edge selection for "Contiguous Edges" propagate mode. 0 means to ignore the distance constraint.

---
geometricarea(ga): int
    properties: create, query
    0(off) 1(on).

---
geometricareabound(gab): [float, float]
    properties: create, query
    min and max areas.

---
holes(h): int
    properties: create, query
    0(off) 1(holed) 2(non holed).

---
length(l): int
    properties: create, query
    0(off) 1(on).

---
lengthbound(lb): [float, float]
    properties: create, query
    min and max lengths.

---
loopPropagation(lp): boolean
    properties: create, query
    If true, edge selection will be extended to a loop.

---
max2dAngle(m2a): float
    properties: create
    Maximum angle between two consecutive edges in the 2d tangent plane for "Contiguous Edges" propagate mode.

---
max3dAngle(m3a): float
    properties: create
    Maximum angle between two consecutive edges in 3d space for "Contiguous Edges" propagate mode.

---
mode(m): int
    properties: create, query
    0(Off) 1(Next) 2(Current and Next) 3(All and Next).
Off :             no constraints are used at all.
Next :             constraints will be used to filter next selections.
Current and Next :    constraints will be aplied on current selection
and then used to filter next selections.
All and Next :        all items satisfying constraints are selected.

---
nonmanifold(nm): int
    properties: create, query
    0(off) 1(on)

---
oppositeEdges(oe): boolean
    properties: create
    Use the opposite edges

---
order(order): int
    properties: create, query
    0(off) 1(on).

---
orderbound(orb): [int, int]
    properties: create, query
    min and max orders.
number of owning edges.

---
orient(o): int
    properties: create, query
    0(off) 1(orientation) 2(direction).

---
orientaxis(oa): [float, float, float]
    properties: create, query
    axis.

---
orientbound(ob): [float, float]
    properties: create, query
    min and max angles.  The given value should be in the current units that
Maya is using.  See the examples for how to check the current unit.

---
planarity(p): int
    properties: create, query
    0(off) 1(non planar) 2(planar).

---
propagate(pp): int
    properties: create, query
    0(Off) 1(More) 2(Less) 3(Border) 4(Contiguous Edges) 5(Grow Along Loop) 6(Shrink Along Loop).
More :        will add current selection border to current selection.
Less :        will remove current selection border from current selection.
Border :    will keep only current selection border.
Contiguous Edges :    Add edges aligned with the current
edges selected. The direction and number of edges selected is
controlled by the -m2a, -m3a, and -ed flags.
Grow Along Loop:    Will grow current selection along loop, support face, edge, vertex and UV.
Shrink Along Loop:    Will shrink current selection along loop, support face, edge, vertex and UV.

---
random(r): int
    properties: create, query
    0(off) 1(on).

---
randomratio(rr): float
    properties: create, query
    ratio [0,1].

---
returnSelection(rs): boolean
    properties: create
    If true, current selection will not be modified, instead the new selection will be returned as result.

---
ringPropagation(rp): boolean
    properties: create, query
    If true, edge selection will be extended to a ring.

---
shell(sh): boolean
    properties: create, query
    If true, selection will be extended to all connected components
so that the whole piece of object is selected.

---
size(sz): int
    properties: create, query
    0(off) 1(triangles) 2(quads) 3(nsided).

---
smoothness(sm): int
    properties: create, query
    0(off) 1(hard) 2(smooth).

---
stateString(sts): boolean
    properties: query
    Query only flag. Returns the MEL command that would restore all
the current settings.

---
textured(tx): int
    properties: create, query
    0(off) 1(mapped) 2(unmapped).

---
texturedarea(ta): int
    properties: create, query
    0(off) 1(Area specified is unsigned) 2(Area specified is signed).

---
texturedareabound(tab): [float, float]
    properties: create, query
    min and max areas.

---
textureshared(ts): int
    properties: create, query
    0(off) 1(on).
This option will select any UVs on the currentMap which are shared
by more than one vertex

---
topology(tp): int
    properties: create, query
    0(off) 1(non triangulatable) 2(lamina) 3(non triangulatable and lamina)

---
type(t): int
    properties: create, query
    0x0000(none)
0x0001(vertex)
0x8000(edge)
0x0008(face)
0x0010(texture coordinates)

---
uvBorderSelection(ubs): boolean
    properties: create, query
    This flag only works on UV view
If true, selection will be extended to all UV border components
It also removes all components not on UV border from the existing selection

---
uvConstraint(uvc): boolean
    properties: create
    If true, applicable constraint flags will work on UV view.
      In query mode, this flag can accept a value.

---
uvEdgeLoopPropagation(ulp): boolean
    properties: create, query
    Use "-uvConstraint true" to edit/query UV view constraint.
If true, UV edge selection will be extended to a loop.

---
uvEdgeRingPropagation(urp): boolean
    properties: create, query
    This flag only works on UV view
If true, UV edge selection will be extended to a ring.

---
uvFaceOrientation(ufo): int
    properties: create, query
    This flag only works on UV view
0(Off) 1(Front Face) 2(Back Face).

---
uvShell(uv): boolean
    properties: create, query
    If true, selection will be extended to all connected components in UV space

---
visibility(v): int
    properties: create, query
    0(off) 1(on).

---
visibilityangle(va): angle
    properties: create, query
    angle [0,360].

---
visibilitypoint(vp): [float, float, float]
    properties: create, query
    point.

---
where(w): int
    properties: create, query
    0(off) 1(on border) 2(inside).

---
wholeSensitive(ws): boolean
    properties: create, query
    Tells how to select faces : either
 by picking anywhere inside the face (if true)
 or by picking on the face center marker (if false).

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySelectConstraint.html 
    """


def polySelectConstraintMonitor(flagchangeCommand: tuple[string, string], flagcreate: boolean, flagdelete: boolean) -> None:
    """Synopsis:
---
---
 polySelectConstraintMonitor(
string
    , [changeCommand=[string, string]], [create=boolean], [delete=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySelectConstraintMonitor is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

create Monitor
cmds.polySelectConstraintMonitor( create=True )

set up a callback for when the constraints are changed
cmds.polySelectConstraintMonitor( changeCommand=('polygonConstraintUpdate', 'MyPanel'));

delete Monitor
cmds.polySelectConstraintMonitor( delete=True )

---


Flags:
---


---
changeCommand(cc): [string, string]
    properties: create
    Specifies the mel callback to refresh the window. First argument is
the callback, second is the window name.

---
create(c): boolean
    properties: create
    Specifies the Monitor should be created

---
delete(d): boolean
    properties: create
    Specifies that the Monitor should be removed

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySelectConstraintMonitor.html 
    """


def polySelectCtx(flagexists: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flagmode: int) -> None:
    """Synopsis:
---
---
 polySelectCtx([exists=boolean], [image1=string], [image2=string], [image3=string], [mode=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySelectCtx is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a poly plane
cmds.polyPlane(w=10, h=10, sx=10, sy=10, n='pPlane1')

Create a new poly select context, then switch to it
cmds.polySelectCtx('polySelectCtx1')
cmds.setToolTo('polySelectCtx1')

---


Flags:
---


---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
mode(m): int
    properties: create, query, edit
    Edge loop or Edge ring or Border edge mode

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySelectCtx.html 
    """


def polySelectEditCtx(flagabsoluteOffset: boolean, flagadjustEdgeFlow: float, flagautoComplete: boolean, flagdeleteEdge: boolean, flagdivisions: int, flagendVertexOffset: float, flagexists: boolean, flagfixQuads: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flaginsertWithEdgeFlow: boolean, flagmode: int, flagsmoothingAngle: angle, flagsplitType: int, flagstartVertexOffset: float, flaguseEqualMultiplier: boolean) -> string:
    """Synopsis:
---
---
 polySelectEditCtx([absoluteOffset=boolean], [adjustEdgeFlow=float], [autoComplete=boolean], [deleteEdge=boolean], [divisions=int], [endVertexOffset=float], [exists=boolean], [fixQuads=boolean], [image1=string], [image2=string], [image3=string], [insertWithEdgeFlow=boolean], [mode=int], [smoothingAngle=angle], [splitType=int], [startVertexOffset=float], [useEqualMultiplier=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySelectEditCtx is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a poly plane
cmds.polyPlane(w=10, h=10, sx=5, sy=5, n='pPlane1')

Create a new poly select and edit context, then switch to it
cmds.polySelectEditCtx('polySelectEditCtx1')
cmds.setToolTo('polySelectEditCtx1')

---
Return:
---


    string: The context name

Flags:
---


---
adjustEdgeFlow(aef): float
    properties: create, query, edit
    The weight value of the edge vertices to be positioned.
Default: 1.0f

---
divisions(div): int
    properties: create, query, edit
    Number of divisions.
Default: 2

---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
fixQuads(fq): boolean
    properties: create, query, edit
    Fixes splits which go across a quad face leaving a 5 and 3
sided faces by splitting from the middle of the new edge to
the vertex accross from the edge on the 5 sided face.
Default: false

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
insertWithEdgeFlow(ief): boolean
    properties: create, query, edit
    True to enable edge flow. Otherwise, the edge flow is disabled.
Default: false

---
smoothingAngle(sma): angle
    properties: create, query, edit
    Angle below which new edges will be smoothed
Default: kPi

---
splitType(stp): int
    properties: create, query, edit
    Format: 0 - Absolute, 1 - Relative, 2 - Multi
Default: TdnpolySplitRing::Relative

---
useEqualMultiplier(uem): boolean
    properties: create, query, edit
    Changes how the profile curve effects the offset when doing
a multisplit.  If true then the verts will be offset the same distance
based on the shortest edge being split.  If false then each inserted
edge loop will be offset a distance relative to the length of the edge
that is being split.
Default: true

---
absoluteOffset(abo): boolean
    properties: create, query, edit
    This flag is deprecated. Use splitType/stp instead.
This flag is deprecated. Use splitType/stp instead.

---
autoComplete(ac): boolean
    properties: create
    If true then use auto completion on selections

---
deleteEdge(de): boolean
    properties: create, query, edit
    When true, the end edges are deleted so the end triangles are converted to quads.

---
endVertexOffset(evo): float
    properties: create, query, edit
    Weight value controlling the offset of the end vertex of the edgeloop.

---
mode(m): int
    properties: create, query, edit
    which mode to work on.  Available modes are 1-loop and 2-ring

---
startVertexOffset(svo): float
    properties: create, query, edit
    Weight value controlling the offset of the start vertex of the edgeloop.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySelectEditCtx.html 
    """


def polySeparate(flagcaching: boolean, flagnodeState: int, flagremoveShells: boolean, flagseparateSpecificShell: int) -> list[string]:
    """Synopsis:
---
---
 polySeparate(
[poly]
    , [caching=boolean], [nodeState=int], [removeShells=boolean], [separateSpecificShell=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySeparate is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polyPlane( n='plg', w=5, h=5 )
cmds.delete( 'plg.f[20:29]' )

cmds.polySeparate( 'plg' )

---
Return:
---


    list[string]: Object name(s) and node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
removeShells(rs): boolean
    properties: create
    Remove the shells after creation.

---
separateSpecificShell(sss): int
    properties: create, multiuse
    List of shell ids to be separated.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySeparate.html 
    """


def polySetToFaceNormal(flagsetUserNormal: boolean) -> string:
    """Synopsis:
---
---
 polySetToFaceNormal([setUserNormal=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySetToFaceNormal is undoable, NOT queryable, and NOT editable. userNormal 


Example:
---
import maya.cmds as cmds

Create user normals and set them to the face normals
cmds.polySetToFaceNormal( setUserNormal=True )

Set the normals to the default normal values (internally computed)
cmds.polySetToFaceNormal()

---
Return:
---


    string: of the node name

Flags:
---


---
setUserNormal(su): boolean
    properties: create
    when this flag is presented, user normals will be created on each vertex
face and the values will be the face normal value. Otherwise the normal
values will be the internal computing results. Default is false.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySetToFaceNormal.html 
    """


def polySewEdge(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int, flagtexture: boolean, flagtolerance: linear, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polySewEdge([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int], [texture=boolean], [tolerance=linear], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySewEdge is undoable, queryable, and editable.
Perform pair-wise comparison of selected edges. Pairs whose
corresponding vertices meet threshold conditions and whose
orientations are aligned (i.e. their respective normals point
in the same direction) are merged, as are the vertices (in
other words, vertices are shared).
Resulting mesh may have extra vertices or edges to ensure
geometry is valid.
Edges must be on the same object to be merged.
Default : share only vertices lying exactly at the same place.
(polySewEdge -t 0.0)




Example:
---
import maya.cmds as cmds

cmds.polyPlane( sx=1, sy=1, n='plg1' )
cmds.polyPlane( sx=1, sy=1, n='plg2' )
cmds.rotate( 0, 0, 30, 'plg1' )
cmds.rotate( 0, 0, -30, 'plg2' )
cmds.move( -0.5, 0, 0, 'plg1', ws=True )
cmds.move( 0.5, 0, 0, 'plg2', ws=True )
For the polyUnite we assume that plg1's shape node is named
 plg1Shape, plg2's shape node is plg2Shape, and the resulting
 transform is named polySurface1. One or more of these may not
 hold true if objects have previously been created and
 manipulated in the scene.
cmds.polyUnite( 'plg1Shape', 'plg2Shape' )
cmds.polySewEdge( 'polySurface1.e[2]', 'polySurface1.e[5]', t=0.25 )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
texture(tx): boolean
    properties: create, query, edit
    If true : texture is sewn as well as the 3d edge.
C: Default is true.
Q: When queried, this flag returns an int.

---
tolerance(t): linear
    properties: create, query, edit
    The tolerance to sew edges (edge distance)
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySewEdge.html 
    """


def polyShortestPathCtx(flagexists: boolean, flagimage1: string, flagimage2: string, flagimage3: string) -> None:
    """Synopsis:
---
---
 polyShortestPathCtx([exists=boolean], [image1=string], [image2=string], [image3=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyShortestPathCtx is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

To create a new poly shortest edge path context:
---

cmds.polyShortestPathCtx( 'PolyViewPortShortestPath' )

---


Flags:
---


---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyShortestPathCtx.html 
    """


def polySlideEdge(flagabsolute: boolean, flagdirection: uint, flagedgeDirection: float, flagsymmetry: boolean) -> boolean:
    """Synopsis:
---
---
 polySlideEdge([absolute=boolean], [direction=uint], [edgeDirection=float], [symmetry=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySlideEdge is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

Moves the selected edge loops to the left by 50% of their neighbouring left edges
cmds.polySlideEdge(edgeDirection=0.5, direction=1)

Moves the selected edge loops to the right by 200% of the length of the shortest neighbouring right edge
cmds.polySlideEdge(edgeDirection=2, absolute=True)

---
Return:
---


    boolean: Success value

Flags:
---


---
absolute(a): boolean
    properties: create
    This flag specifies whether or not the command uses absolute mode
If in absolute then all vertices will move the same distance (the
specified percentage of the smallest edge)
C: Default is off

---
direction(d): uint
    properties: create
    This flag specifies the direction of the slide edge movement
0: is left direction (relative)
1: is right direction (relative)
2: is normal direction (relative)
C: Default is 0

---
edgeDirection(ed): float
    properties: create
    This flag specifies the relative percentage to move along the edges on
either side of the vertices along the edge loop
C: Default is 0.0

---
symmetry(sym): boolean
    properties: create
    This flag specifies whether or not the command will do a symmetrical slide. Only takes effect
when symmetry is enabled.
C: Default is off

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySlideEdge.html 
    """


def polySmooth(flagcaching: boolean, flagconstructionHistory: boolean, flagcontinuity: float, flagdegree: int, flagdivisions: int, flagdivisionsPerEdge: int, flagkeepBorder: boolean, flagkeepHardEdge: boolean, flagkeepMapBorders: int, flagkeepSelectionBorder: boolean, flagkeepTesselation: boolean, flagkeepTessellation: boolean, flagmethod: int, flagname: string, flagnodeState: int, flagosdCreaseMethod: int, flagosdFvarBoundary: int, flagosdFvarPropagateCorners: boolean, flagosdSmoothTriangles: boolean, flagosdVertBoundary: int, flagpropagateEdgeHardness: boolean, flagpushStrength: float, flagroundness: float, flagsmoothUVs: boolean, flagsubdivisionLevels: int, flagsubdivisionType: int) -> string:
    """Synopsis:
---
---
 polySmooth([caching=boolean], [constructionHistory=boolean], [continuity=float], [degree=int], [divisions=int], [divisionsPerEdge=int], [keepBorder=boolean], [keepHardEdge=boolean], [keepMapBorders=int], [keepSelectionBorder=boolean], [keepTesselation=boolean], [keepTessellation=boolean], [method=int], [name=string], [nodeState=int], [osdCreaseMethod=int], [osdFvarBoundary=int], [osdFvarPropagateCorners=boolean], [osdSmoothTriangles=boolean], [osdVertBoundary=int], [propagateEdgeHardness=boolean], [pushStrength=float], [roundness=float], [smoothUVs=boolean], [subdivisionLevels=int], [subdivisionType=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySmooth is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polyCube( n='plg1' )
cmds.move( -3, 0, 2 )
cmds.polyCube( n='plg2' )
cmds.move( -3, 0, -2 )
cmds.polyCube( n='plg3' )
cmds.move( 0, 0, 2 )
cmds.delete( 'plg3.f[1]' )
cmds.polyCube( n='plg4' )
cmds.move( 0, 0, -2 )
cmds.delete( 'plg4.f[1]' )
cmds.polyCube( n='plg5' )
cmds.move( 3, 0, 2 )
cmds.polyCube( n='plg6' )
cmds.move( 3, 0, -2 )

cmds.polyOptions( ao=True, db=1 )

only one division:
cmds.polySmooth( 'plg1.f[0:5]', dv=1 )

2 divisions produces a round-ish object
cmds.polySmooth( 'plg2.f[0:5]', dv=2 )

keep border edges
cmds.select( 'plg3.f[0:4]' )
cmds.polySmooth( kb=1 )

don't keep border edges
cmds.select( 'plg4.f[0:4]' )
cmds.polySmooth( kb=0 )

1 division, continuity 0.2
cmds.select( 'plg5' )
cmds.polySmooth( c=0.2 )

1 division, continuity 0.8
cmds.polySmooth( 'plg6.f[0:5]', c=0.8 )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
continuity(c): float
    properties: create, query, edit
    This flag specifies the smoothness parameter. The minimum value of 0.0
specifies that the faces should only be subdivided. Maximum value of 1.0 smooths
the faces as much as possible.
C: Default is 1.0
Q: When queried, this flag returns a float.

---
degree(deg): int
    properties: create
    Degree of the resulting limit surface

---
divisions(dv): int
    properties: create, query, edit
    This flag specifies the number of recursive smoothing steps.
C: Default is 1.
Q: When queried, this flag returns an int.

---
divisionsPerEdge(dpe): int
    properties: create
    Number of subdivisions along one edge for each step.

---
keepBorder(kb): boolean
    properties: create, query, edit
    If on, the border of the object will not move during smoothing operation.
C: Default is "on".
Q: When queried, this flag returns an int.

---
keepHardEdge(khe): boolean
    properties: create, query, edit
    If true, vertices on hard edges will not be modified.
C: Default is false.
Q: When queried, this flag returns a boolean.

---
keepMapBorders(kmb): int
    properties: create
    Treatment of UV map borders
0 - all map border edges will be smoothed
1 - map borders that are also geometry borders will be smoothed
2 - no map borders will be smoothed

---
keepSelectionBorder(ksb): boolean
    properties: create, query, edit
    If true, vertices on border of the selection will not be modified.
C: Default is false.
Q: When queried, this flag returns a boolean.

---
keepTesselation(xkt): boolean
    properties: create
    If true: the object will be smoothed consistently from frame to frame.
This is best when the object is being deformed or animated .
If false: non-starlike faces will be triangulated before being
smoothed.  This avoids self-overlapping faces, but could lead to a
change in topology (number of vertices/faces) from frame to frame,
during an animated deformation.

---
keepTessellation(kt): boolean
    properties: create
    If true: the object will be smoothed consistently from frame to frame.
This is best when the object is being deformed or animated .
If false: non-starlike faces will be triangulated before being
smoothed.  This avoids self-overlapping faces, but could lead to a
change in topology (number of vertices/faces) from frame to frame,
during an animated deformation.

---
method(mth): int
    properties: create
    Type of smoothing algorithm to use
0 - exponential - traditional smoothing
1 - linear - number of faces per edge grows linearly

---
osdCreaseMethod(ocr): int
    properties: create, query, edit
    Controls how boundary edges and vertices are interpolated.

---
osdFvarBoundary(ofb): int
    properties: create, query, edit
    Controls how boundaries are treated for face-varying data (UVs and Vertex Colors).

---
osdSmoothTriangles(ost): boolean
    properties: create, query, edit
    Apply a special subdivision rule be applied to all triangular faces
that was empirically determined to make triangles subdivide more smoothly.

---
osdVertBoundary(ovb): int
    properties: create, query, edit
    Controls how boundary edges and vertices are interpolated.

---
propagateEdgeHardness(peh): boolean
    properties: create, query, edit
    If true, edges which are a result of smoothed edges will be given
the same value for their edge hardness.  New subdivided edges will
always be smooth.
C: Default is false.
Q: When queried, this flag returns a boolean.

---
pushStrength(ps): float
    properties: create
    COMMENT 0.0 is approximation, 1.0 is interpolation scheme

---
roundness(ro): float
    properties: create
    When 1.0, push vectors are renormalized to keep length constant

---
smoothUVs(suv): boolean
    properties: create
    If true: UVs as well as geometry will be smoothed

---
subdivisionLevels(sl): int
    properties: create
    Number of times the subdivide and smooth operation is run.

---
subdivisionType(sdt): int
    properties: create, query, edit
    The subdivision method used for smoothing.
C: Default is 0.
0: Maya Catmull-Clark
1: OpenSubdiv Catmull-Clark

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySmooth.html 
    """


def polySoftEdge(flagangle: angle, flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polySoftEdge([angle=angle], [caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySoftEdge is undoable, queryable, and editable.
An edge will be made hard if the angle between two owning
faces is sharper (larger) than the smoothing angle.
An edge wil be made soft if the angle between two owning
facets is flatter (smaller) than the smoothing angle.




Example:
---
import maya.cmds as cmds

Turn smooth shading on
Soft and hard edges are much easier to see with smooth shading on
currentPanel = cmds.getPanel(withFocus= True)
if currentPanel != '':
        cmds.modelEditor(currentPanel, edit=True, da='smoothShaded', dl='default')

cmds.polySphere(n= 'plg', sx= 15, sy= 10 )
hard bottom
cmds.select( 'plgShape.e[0:59]', 'plgShape.e[135:194]', 'plgShape.e[255:269]', r=True )
cmds.polySoftEdge( a=0 )
smooth top
cmds.select( 'plg.e[75:134]', 'plg.e[195:254]', 'plg.e[270:284]', r=True )
cmds.polySoftEdge( a=180 )
cmds.select( 'plg' )
cmds.polyOptions( ao=True, se=True )

Set display mode back to wireframe (default mode)
currentPanel = cmds.getPanel(withFocus= True)
if currentPanel != '':
        cmds.modelEditor(currentPanel, edit=True, da='wireframe')

---
Return:
---


    string: The name of the polySoftEdge node.

Flags:
---


---
angle(a): angle
    properties: create, query, edit
    Smoothing angle.
C: Default is 30 degrees.
Q: When queried, this flag returns a float.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySoftEdge.html 
    """


def polySphere(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: int, flagname: string, flagnodeState: int, flagobject: boolean, flagradius: linear, flagsubdivisionsAxis: int, flagsubdivisionsHeight: int, flagsubdivisionsX: int, flagsubdivisionsY: int, flagtexture: int) -> list[string]:
    """Synopsis:
---
---
 polySphere([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=int], [name=string], [nodeState=int], [object=boolean], [radius=linear], [subdivisionsAxis=int], [subdivisionsHeight=int], [subdivisionsX=int], [subdivisionsY=int], [texture=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySphere is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a sphere, with 10 subdivisions in the X direction,
and 15 subdivisions in the Y direction,
the radius of the sphere is 20.
cmds.polySphere(sx=10, sy=15, r=20)

Create a sphere, called "mySphere", on each direction there are 5 subdivisions.
cmds.polySphere( n='mySphere', sx=5, sy=5)

Query the radius of the new sphere
r = cmds.polySphere( 'mySphere', q=True, sx=True )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the sphere.
Q: When queried, this flag returns a float[3].

---
createUVs(cuv): int
    properties: create
    This flag alows a specific UV mechanism to be selected, while creating the sphere.
The valid values are 0, 1, or 2.
0 implies that no UVs will be generated (No texture to be applied).

1 implies UVs are created with pinched at poles

2 implies UVs are created with sawtooth at poles

  For better understanding of these options, you may have to open the
     texture view window

C: Default is 2

---
radius(r): linear
    properties: create, query, edit
    This flag specifies the radius of the sphere.
C: Default is 0.5.
Q: When queried, this flag returns a float.

---
subdivisionsAxis(sa): int
    properties: create, query, edit
    Subdivisions around the axis.

---
subdivisionsHeight(sh): int
    properties: create, query, edit
    Subdivisions along the height of the sphere.

---
subdivisionsX(sx): int
    properties: create, query, edit
    This specifies the number of subdivisions in the X direction for the sphere.
C: Default is 20.
Q: When queried, this flag returns an int.

---
subdivisionsY(sy): int
    properties: create, query, edit
    This flag specifies the number of subdivisions in the Y direction for the sphere.
C: Default is 20.
Q: When queried, this flag returns an int.

---
texture(tx): int
    properties: create
    This flag is obsolete and will be removed in the next release.
The -cuv/createUVs flag should be used instead.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySphere.html 
    """


def polySphericalProjection(flagcaching: boolean, flagconstructionHistory: boolean, flagcreateNewMap: boolean, flagimageCenter: tuple[float, float], flagimageCenterX: float, flagimageCenterY: float, flagimageScale: tuple[float, float], flagimageScaleU: float, flagimageScaleV: float, flaginsertBeforeDeformers: boolean, flagkeepImageRatio: boolean, flagmapDirection: string, flagname: string, flagnodeState: int, flagperInstance: boolean, flagprojectionCenter: tuple[linear, linear, linear], flagprojectionCenterX: linear, flagprojectionCenterY: linear, flagprojectionCenterZ: linear, flagprojectionHorizontalSweep: linear, flagprojectionScale: tuple[linear, linear], flagprojectionScaleU: linear, flagprojectionScaleV: linear, flagradius: linear, flagrotate: tuple[angle, angle, angle], flagrotateX: angle, flagrotateY: angle, flagrotateZ: angle, flagrotationAngle: angle, flagseamCorrect: boolean, flagsmartFit: boolean, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polySphericalProjection([caching=boolean], [constructionHistory=boolean], [createNewMap=boolean], [imageCenter=[float, float]], [imageCenterX=float], [imageCenterY=float], [imageScale=[float, float]], [imageScaleU=float], [imageScaleV=float], [insertBeforeDeformers=boolean], [keepImageRatio=boolean], [mapDirection=string], [name=string], [nodeState=int], [perInstance=boolean], [projectionCenter=[linear, linear, linear]], [projectionCenterX=linear], [projectionCenterY=linear], [projectionCenterZ=linear], [projectionHorizontalSweep=linear], [projectionScale=[linear, linear]], [projectionScaleU=linear], [projectionScaleV=linear], [radius=linear], [rotate=[angle, angle, angle]], [rotateX=angle], [rotateY=angle], [rotateZ=angle], [rotationAngle=angle], [seamCorrect=boolean], [smartFit=boolean], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySphericalProjection is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a sphere with default UVs.
cmds.polySphere( n='sphere', r=10 )

Create a lambert node.
cmds.shadingNode( 'lambert', '-n', 'myLambert', asShader=True )
cmds.sets( renderable=True, noSurfaceShader=True, empty=True, name='myLambertSG' )
cmds.connectAttr( 'myLambert.outColor', 'myLambertSG.surfaceShader', f=True )

Create a texture checker.
cmds.shadingNode( 'checker', asTexture=True )
cmds.shadingNode( 'place2dTexture', asUtility=True )
cmds.connectAttr( 'place2dTexture1.outUV', 'checker1.uv' )

Assign the texture the the lambert node.
cmds.connectAttr( 'checker1.outColor', 'myLambert.color', f=True )

Set the textured display mode.
currentPanel = cmds.getPanel(withFocus= True)
if currentPanel != '':
        cmds.modelEditor(currentPanel, edit=True, da='smoothShaded', displayTextures=True, dl='default')

Assign the lambert shader to all faces of the sphere.
cmds.sets('sphere.f[0:399]', edit=True, forceElement= 'myLambertSG' )

Replace default UVs on the top of the sphere :
Rotates the map of 45 degrees and reduces its aperture to 20 degrees in both directions
cmds.polySphericalProjection( 'sphere.f[180:359]', 'sphere.f[380:399]', ra=45.0, pc=(0, 0, 0), ps=(20, 20) )

Set the wireframe display mode.
currentPanel = cmds.getPanel(withFocus= True)
if currentPanel != '':
        cmds.modelEditor(currentPanel, edit=True, da='wireframe')

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createNewMap(cm): boolean
    properties: create, query
    This flag when set true will create a new map with
a the name passed in, if the map does not already exist.

---
insertBeforeDeformers(ibd): boolean
    properties: create
    This flag specifies if the projection node should be inserted before
or after deformer nodes already applied to the shape. Inserting the
projection after the deformer leads to texture swimming during
animation and is most often undesirable.
C: Default is on.

---
keepImageRatio(kir): boolean
    properties: create
    True means keep any image ratio

---
mapDirection(md): string
    properties: create
    This flag specifies the mapping direction.
'x', 'y' and 'z' projects the map along the corresponding axis.
'c' projects along the current camera viewing direction.
'p' does perspective projection if current camera is perspective.
'b' projects along the best plane fitting the objects selected.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
perInstance(pi): boolean
    properties: create
    True if the new map is per-instance, otherwise it is shared.

---
smartFit(sf): boolean
    properties: create
    True means use the smart fit algorithm

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

---
imageCenter(ic): [float, float]
    properties: create, query, edit
    This flag specifies the center point of the 2D model layout.
C: Default is 0.5 0.5.
Q: When queried, this flag returns a float[2].

---
imageCenterX(icx): float
    properties: create, query, edit
    This flag specifies X for the center point of the 2D model layout.
C: Default is 0.5.
Q: When queried, this flag returns a float.

---
imageCenterY(icy): float
    properties: create, query, edit
    This flag specifies Y for the center point of the 2D model layout.
C: Default is 0.5.
Q: When queried, this flag returns a float.

---
imageScale(imageScale): [float, float]
    properties: create, query, edit
    This flag specifies the UV scale : Enlarges or reduces the 2D version of the model in U
or V space relative to the 2D centerpoint.
C: Default is 1.0 1.0.
Q: When queried, this flag returns a float[2].

---
imageScaleU(isu): float
    properties: create, query, edit
    This flag specifies the U scale : Enlarges or reduces the 2D version of the model in U space relative to the 2D centerpoint.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
imageScaleV(isv): float
    properties: create, query, edit
    This flag specifies the V scale : Enlarges or reduces the 2D version of the model in V space relative to the 2D centerpoint.
C: Default is 1.0.
Q: When queried, this flag returns a float.

---
projectionCenter(pc): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the origin point from which the map is projected.
C: Default is 0.0 0.0 0.0.
Q: When queried, this flag returns a float[3].

---
projectionCenterX(pcx): linear
    properties: create, query, edit
    This flag specifies X for the origin point from which the map is projected.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
projectionCenterY(pcy): linear
    properties: create, query, edit
    This flag specifies Y for the origin point from which the map is projected.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
projectionCenterZ(pcz): linear
    properties: create, query, edit
    This flag specifies Z for the origin point from which the map is projected.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
projectionHorizontalSweep(phs): linear
    properties: create, query, edit
    The angle swept horizontally by the projection.  The range is [0, 360].

---
projectionScale(ps): [linear, linear]
    properties: create, query, edit
    This flag specifies the width and the height of the map relative to the 3D projection axis.
C: Default is 180.0 90.0.
Q: When queried, this flag returns a float[2].

---
projectionScaleU(psu): linear
    properties: create, query, edit
    This flag specifies the width of the map relative to the 3D projection axis : the scale aperture. The range is [0, 360].
C: Default is 180.0.
Q: When queried, this flag returns a float.

---
projectionScaleV(psv): linear
    properties: create, query, edit
    This flag specifies the height of the map relative to the 3D projection axis : the scale height.
C: Default is 90.0.
Q: When queried, this flag returns a float.

---
radius(r): linear
    properties: create, query, edit
    Used by the UI : Manipulator.

---
rotate(ro): [angle, angle, angle]
    properties: create, query, edit
    This flag specifies the mapping rotate angles.
C: Default is 0.0 0.0 0.0.
Q: When queried, this flag returns a float[3].

---
rotateX(rx): angle
    properties: create, query, edit
    This flag specifies X mapping rotate angle.
C: Default is 0.0.
Q: When queried, this flag returns a float[3].

---
rotateY(ry): angle
    properties: create, query, edit
    This flag specifies Y mapping rotate angle.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
rotateZ(rz): angle
    properties: create, query, edit
    This flag specifies Z mapping rotate angle.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
rotationAngle(ra): angle
    properties: create, query, edit
    This flag specifies the rotation angle in the mapping space.
When the angle is positive, then the map rotates
counterclockwise on the mapped model, whereas when it is
negative then the map rotates clockwise on the mapped model.
C: Default is 10.0.
Q: When queried, this flag returns a float.

---
seamCorrect(sc): boolean
    properties: create, query, edit
    This flag specifies to perform a seam correction
on the mapped faces.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySphericalProjection.html 
    """


def polySplit(flagadjustEdgeFlow: float, flagconstructionHistory: boolean, flagdetachEdges: boolean, flagedgepoint: tuple[int, float], flagfacepoint: tuple[int, float, float, float], flaginsertWithEdgeFlow: boolean, flaginsertpoint: tuple[int, float] | tuple[int | float, ...] | tuple[tuple, ...], flagname: string, flagprojectedCurve: name, flagprojectedCurveTolerance: float, flagsmoothingangle: angle, flagsubdivision: int) -> string:
    """Synopsis:
---
---
 polySplit([adjustEdgeFlow=float], [constructionHistory=boolean], [detachEdges=boolean], [edgepoint=[int, float]], [facepoint=[int, float, float, float]], [insertWithEdgeFlow=boolean], [insertpoint=[int, float, [, float, float, ]]], [name=string], [projectedCurve=name], [projectedCurveTolerance=float], [smoothingangle=angle], [subdivision=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySplit is undoable, queryable, and editable.
The first and last arguments must be edges. Intermediate points
may lie on either a shared face or an edge which neighbors the previous point.




Example:
---
import maya.cmds as cmds

Note that in Python, you must use the ip/insertpoint flag which determines
whether you are splitting an edge or a face based on the number of
arguments to the flag (2 for an edge, and 4 for a face)
cmds.polyCreateFacet( p=[(0, 2, 0), (0, -2, 0), (4, -2, 0), (4, 2, 0)] )
cmds.polySplit( ip=[(2, 0.1), (3, 0.5), (0, 2, -1, 0.0), (0, 0.9)] )

---
Return:
---


    string: The node name.

Flags:
---


---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
adjustEdgeFlow(aef): float
    properties: create, query, edit
    The weight value of the edge vertices to be positioned.

---
detachEdges(de): boolean
    properties: create
    Value of the detachEdges attribute for the resulting poly split node.

---
edgepoint(ep): [int, float]
    properties: create, multiuse
    The given edge is split into two new edges
by inserting a new vertex located the given percentage
along the edge.

Note: This flag is not recommended for use from Python.  See the
insertpoint flag instead.

---
facepoint(fp): [int, float, float, float]
    properties: create, multiuse
    A new vertex is inserted,
lying at the given coordinates inside the given face.
Coordinates are given in the local object space.

Note: This flag is not recommended for use from Python.  See the
insertpoint flag instead.

---
insertWithEdgeFlow(ief): boolean
    properties: create, query, edit
    True to enable edge flow. Otherwise, the edge flow is disabled.

---
insertpoint(ip): [int, float, [, float, float, ]]
    properties: create, multiuse
    This flag allows the caller to insert a new vertex into an edge or a face.

To insert a new vertex in an edge, pass the index of the edge and a percentage
along the edge at which to insert the new vertex.  When used to insert a
vertex into an edge, this flag takes two arguments.

To insert a new vertex into a face, pass the index of the face and three values
which define the coordinates for the insertion in local object space.  When
used to insert a vertex into a face, this flag takes four arguments.

This flag replaces the edgepoint and facepoint flags.

---
projectedCurve(pc): name
    properties: create, multiuse
    Curves to be projected.

---
projectedCurveTolerance(pct): float
    properties: create
    Tolerance for curve projection.

---
smoothingangle(sma): angle
    properties: create
    Subdivide new edges will be soft if less then this angle.
C: Default is 0.0

---
subdivision(s): int
    properties: create, query, edit
    Subdivide new edges into the given number of sections.
Edges involving free points won't be subdivided.
C: Default is 1 (no subdivision).
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySplit.html 
    """


def polySplitCtx(flagenablesnap: boolean, flagexists: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flagmagnetsnap: int, flagprecsnap: float, flagsmoothingangle: angle, flagsnaptoedge: boolean, flagsubdivision: int) -> None:
    """Synopsis:
---
---
 polySplitCtx([enablesnap=boolean], [exists=boolean], [image1=string], [image2=string], [image3=string], [magnetsnap=int], [precsnap=float], [smoothingangle=angle], [snaptoedge=boolean], [subdivision=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySplitCtx is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a poly plane
cmds.polyPlane(w=10, h=10, sx=1, sy=1, n='pPlane1')

Create a new poly split context, then switch to it
cmds.polySplitCtx('polySplitCtx1')
cmds.setToolTo('polySplitCtx1')

---


Flags:
---


---
enablesnap(es): boolean
    properties: create, query, edit
    Enable/disable custom magnet snapping to start/middle/end of edge

---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
magnetsnap(ms): int
    properties: create, query, edit
    number of extra magnets to snap onto, regularly spaced along the edge

---
precsnap(ps): float
    properties: create, query, edit
    precision for custom magnet snapping. Range[0,100]. Value 100
means any click on an edge will snap to either
extremities or magnets.

---
smoothingangle(sma): angle
    properties: create, query, edit
    the threshold that controls whether newly created edges are hard or soft

---
snaptoedge(ste): boolean
    properties: create, query, edit
    Enable/disable snapping to edge. If enabled any click in the
current face will snap to the closest valid edge. If there
is no valid edge, the click will be ignored.
NOTE: This is different from magnet snapping, which causes
the click to snap to certain points along the edge.

---
subdivision(s): int
    properties: create, query, edit
    number of sub-edges to add between 2 consecutive edge
points. Default is 1.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySplitCtx.html 
    """


def polySplitCtx2(flagadjustEdgeFlow: float, flagconstrainToEdges: boolean, flagedgeMagnets: int, flagexists: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flaginsertWithEdgeFlow: boolean, flagsnapTolerance: float, flagsnappedToEdgeColor: tuple[float, float, float], flagsnappedToFaceColor: tuple[float, float, float], flagsnappedToMagnetColor: tuple[float, float, float], flagsnappedToVertexColor: tuple[float, float, float]) -> None:
    """Synopsis:
---
---
 polySplitCtx2([adjustEdgeFlow=float], [constrainToEdges=boolean], [edgeMagnets=int], [exists=boolean], [image1=string], [image2=string], [image3=string], [insertWithEdgeFlow=boolean], [snapTolerance=float], [snappedToEdgeColor=[float, float, float]], [snappedToFaceColor=[float, float, float]], [snappedToMagnetColor=[float, float, float]], [snappedToVertexColor=[float, float, float]])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySplitCtx2 is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a poly plane
cmds.polyPlane(w=10, h=10, sx=1, sy=1, n='pPlane1')

Create a new poly split context, then switch to it
cmds.polySplitCtx2('polySplitCtx2')
cmds.setToolTo('polySplitCtx2')

---


Flags:
---


---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
adjustEdgeFlow(aef): float
    properties: create, query, edit
    The weight value of the edge vertices to be positioned.

---
constrainToEdges(cte): boolean
    properties: create, query, edit
    Enable/disable snapping to edge. If enabled any click in the
current face will snap to the closest valid edge. If there
is no valid edge, the click will be ignored.
NOTE: This is different from magnet snapping, which causes
the click to snap to certain points along the edge.

---
edgeMagnets(em): int
    properties: create, query, edit
    number of extra magnets to snap onto, regularly spaced along the edge

---
insertWithEdgeFlow(ief): boolean
    properties: create, query, edit
    True to enable edge flow. Otherwise, the edge flow is disabled.

---
snapTolerance(st): float
    properties: create, query, edit
    precision for custom magnet snapping. Range[0,1]. Value 1
means any click on an edge will snap to either
extremities or magnets.

---
snappedToEdgeColor(sec): [float, float, float]
    properties: create, query, edit
    Color for edge snapping.

---
snappedToFaceColor(sfc): [float, float, float]
    properties: create, query, edit
    Color for face snapping.

---
snappedToMagnetColor(smc): [float, float, float]
    properties: create, query, edit
    Color for magnet snapping.

---
snappedToVertexColor(svc): [float, float, float]
    properties: create, query, edit
    Color for vertex snapping.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySplitCtx2.html 
    """


def polySplitEdge(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int, flagoperation: int) -> string:
    """Synopsis:
---
---
 polySplitEdge([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int], [operation=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySplitEdge is undoable, queryable, and editable.
There are two operations for this command depending on the value of the
-operation flag.

If -operation is set to 1 then this command will split apart faces along all
selected manifold edges.

If -operation is set to 0 then this command will split non-manifold edges
so as to make them manifold edges. It creates the minimum number of edges
that can be created to make the edge manifold.

The default value for -operation is 1, operate on manifold edges.

Resulting mesh may have extra vertices or edges to ensure
geometry is valid.




Example:
---
import maya.cmds as cmds

An example taking a non-manifold edge and splitting it to
make it manifold
cmds.polyPlane( w=1, h=1, sx=10, sy=10, ax=(0, 1, 0), cuv=1, ch=1 )
cmds.scale( 15, 15, 15, r=True )
cmds.move( -8, 0, 6, r=True )

cmds.select( 'polyPlane1', addFirst=True )
cmds.setAttr( 'polyPlane1.subdivisionsWidth', 3 )
cmds.setAttr( 'polyPlane1.subdivisionsHeight', 3 )
cmds.select( 'pPlane1.e[12]', r=True )
cmds.polyExtrudeEdge( 'pPlane1.e[12]', ch=1, kft=0, pvx=-5.5, pvy=0.0, pvz=6.0 )
Result: polyExtrudeEdge1 ---

cmds.setAttr( 'polyExtrudeEdge1.localTranslate', 0, 0, 5.093611)
cmds.select( 'pPlane1.e[12]', r=True )
cmds.polySplitEdge(op=0)
Result: polySplitEdge1 ---


The edge is now split..
cmds.select( 'pPlane1.f[9]', r=True)
cmds.move(0, 0.5, 0, r=True)


An example which splits loops of manifold edges
cmds.polyPlane(w=10, h=10, sx=4, sy=4, ch=1, name='ManifoldTest')
cmds.select('ManifoldTest.e[3]', 'ManifoldTest.e[12:15]', 'ManifoldTest.e[21]', 'ManifoldTest.e[23]', 'ManifoldTest.e[29]')

cmds.polySplitEdge(operation=1)

cmds.select('ManifoldTest.f[1:3]', 'ManifoldTest.f[5]', 'ManifoldTest.f[9]')
cmds.move(0, 0, 5, r=True)

cmds.select('ManifoldTest.f[0]', 'ManifoldTest.f[4]', 'ManifoldTest.f[6:8]', 'ManifoldTest.f[10:15]')
cmds.move(0, 0, -5, r=True)

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
operation(op): int
    properties: create, query, edit
    0 means use a Non-Manifold method, 1 means use a Manifold method

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySplitEdge.html 
    """


def polySplitRing(flagadjustEdgeFlow: float, flagcaching: boolean, flagconstructionHistory: boolean, flagdirection: boolean, flagdivisions: int, flagenableProfileCurve: boolean, flagfixQuads: boolean, flaginsertWithEdgeFlow: boolean, flagname: string, flagnodeState: int, flagprofileCurveInputOffset: float, flagprofileCurveInputScale: float, flagprofileCurve_FloatValue: float, flagprofileCurve_Interp: int, flagprofileCurve_Position: float, flagrootEdge: int, flagsmoothingAngle: angle, flagsplitType: int, flaguseEqualMultiplier: boolean, flaguseFaceNormalsAtEnds: boolean, flagweight: float, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polySplitRing([adjustEdgeFlow=float], [caching=boolean], [constructionHistory=boolean], [direction=boolean], [divisions=int], [enableProfileCurve=boolean], [fixQuads=boolean], [insertWithEdgeFlow=boolean], [name=string], [nodeState=int], [profileCurveInputOffset=float], [profileCurveInputScale=float], [profileCurve_FloatValue=float], [profileCurve_Interp=int], [profileCurve_Position=float], [rootEdge=int], [smoothingAngle=angle], [splitType=int], [useEqualMultiplier=boolean], [useFaceNormalsAtEnds=boolean], [weight=float], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySplitRing is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polyCube()
cmds.select('pCube1.e[0:3]')
cmds.polySplitRing( sma=180, wt=0.2)

---
Return:
---


    string: The node name.

Flags:
---


---
adjustEdgeFlow(aef): float
    properties: create, query, edit
    The weight value of the edge vertices to be positioned.
Default: 1.0f

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
direction(dr): boolean
    properties: create, query, edit
    This attribute is used when doing an absolute split.  If true then the
distance is taken from the start vertex of the root edge.  If false the
distance is taken from the end vertext of the root edge.
Default: true

---
divisions(div): int
    properties: create, query, edit
    Number of divisions.
Default: 2

---
enableProfileCurve(epc): boolean
    properties: create, query, edit
    Enables the use of the profile curve.
Default: true

---
fixQuads(fq): boolean
    properties: create, query, edit
    Fixes splits which go across a quad face leaving a 5 and 3
sided faces by splitting from the middle of the new edge to
the vertex accross from the edge on the 5 sided face.
Default: false

---
insertWithEdgeFlow(ief): boolean
    properties: create, query, edit
    True to enable edge flow. Otherwise, the edge flow is disabled.
Default: false

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
profileCurveInputOffset(pio): float
    properties: create, query, edit
    Changes the offset to the multisplit profile curve.
eg. if the profile curve values go between 0 and 1 and this
value is set to -1 then the profile curves values will be
adjusted to go between -1 and 0.
Default: 0.0f

---
profileCurveInputScale(pis): float
    properties: create, query, edit
    Changes the range of values that the profile curve represents.
eg. if the profile curve values go between 0 and 1 and this
value is set to 2 then the profile curves values will be
adjusted to go between 0 and 2.
Default: 1.0f

---
profileCurve_FloatValue(pfv): float
    properties: create, query, edit
    ?????

---
profileCurve_Interp(pi): int
    properties: create, query, edit
    ?????
Default: 0

---
profileCurve_Position(pp): float
    properties: create, query, edit
    ?????

---
rootEdge(re): int
    properties: create, query, edit
    The weight attribute uses the start vertex of this
edge to determine where the new split occurs.
Default: -1

---
smoothingAngle(sma): angle
    properties: create, query, edit
    Angle below which new edges will be smoothed
Default: kPi

---
splitType(stp): int
    properties: create, query, edit
    Format: 0 - Absolute, 1 - Relative, 2 - Multi
Default: TdnpolySplitRing::Relative

---
useEqualMultiplier(uem): boolean
    properties: create, query, edit
    Changes how the profile curve effects the offset when doing
a multisplit.  If true then the verts will be offset the same distance
based on the shortest edge being split.  If false then each inserted
edge loop will be offset a distance relative to the length of the edge
that is being split.
Default: true

---
useFaceNormalsAtEnds(fne): boolean
    properties: create, query, edit
    When doing a multisplit on a set of non-closed edge ring
this will toggle the normals at the ends of the split to
be calculated as the edge normal or the face normal.
Default: true

---
weight(wt): float
    properties: create, query, edit
    Weight value controlling the relative positioning of the
new points on existing edges. Range is [0.0, 1.0].
Value of 0.1 indicates the new edges will be placed closer to
the start vertex of the first edge of the sequence of edges.
Default: 0.5

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySplitRing.html 
    """


def polySplitVertex(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polySplitVertex([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySplitVertex is undoable, queryable, and editable.  A mesh is made up
of one or more faces.  The faces are defined by edges which connect vertices
together.  Typically a face will share vertices and edges with adjacent
faces in the same mesh.  Sharing vertices and edges helps reduce the amount
of memory used by a mesh.  It also ensures that when a face is moved, all
the connected faces move together.
Sometimes you may want to separate a face from its connected faces so that
it may be moved in isolation.  There are three ways to accomplish this depending
upon which parts of the face you want to extract:


polySplitVertex split one or more vertices so that each face that
shared the vertex acquires its own copy of the vertex


polySplitEdge split one or more edges so that each face that shared
the vertex acquires its own copy of the edge


polyChipOff completely extract the face so that it has its own vertices
and edges



Notice that the area of affect of each operation is different.  polySplitVertex
will affect all the edges and faces that shared the vertex.  This is the broadest
effect.  polySplitEdge will only affect the faces which shared the edge and polyChipOff
will affect a specific face.  If we just count vertices to measure the effect of each
command when splitting all components of a face, starting from a 3x3 plane which has 16
vertices and we were to split the middle face:


polySplitVertex applied to the four vertices would end up creating 12 new vertices


polySplitEdge applied to the four edges would end up creating 4 new vertices


polyChipOff applied to the middle face would end up creating 4 new vertices



Note that polySplitVertex may create non-manifold geometry as a part of this operation.
You can use Polygons->Cleanup afterwards to to clean up any non-manifold geometry.




Example:
---
import maya.cmds as cmds

Objective: split the four middle vertices of a 3x3 plane so
that the middle face can be moved seperately

Create a 3x3 plane
---

cmds.polyPlane( sx=3, sy=3, name='polyPlane' )
Result: polyPlane polyPlane1

Count the number of vertices we start out with
---

cmds.polyEvaluate( 'polyPlane', vertex=True )
Result: 16

Split the four middle vertices
---

cmds.polySplitVertex( 'polyPlane.vtx[5]', 'polyPlane.vtx[6]', 'polyPlane.vtx[9]', 'polyPlane.vtx[10]' )
Result: polySplitVert1

Count the number of vertices we have now
---

cmds.polyEvaluate( 'polyPlane', vertex=True )
Result: 28

Note that because we split the 4 middle vertices, the 8
surrounding faces have become non-manifold

---
Return:
---


    string: The polySplitVert node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySplitVertex.html 
    """


def polyStraightenUVBorder(flagblendOriginal: float, flagcaching: boolean, flagconstructionHistory: boolean, flagcurvature: float, flaggapTolerance: int, flagname: string, flagnodeState: int, flagpreserveLength: float, flaguvSetName: string, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyStraightenUVBorder(
selectionList
    , [blendOriginal=float], [caching=boolean], [constructionHistory=boolean], [curvature=float], [gapTolerance=int], [name=string], [nodeState=int], [preserveLength=float], [uvSetName=string], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyStraightenUVBorder is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Create a plane and select it.
cmds.polyPlane()
cmds.select( 'pPlane1.map[0:65]', r=True )

Straighten half the border
cmds.polyStraightenUVBorder()

---
Return:
---


    string: The node name

Flags:
---


---
blendOriginal(bo): float
    properties: create, query
    Interpolation factor between the target and original UV
shape. When the value is 0, the UVs will exactly fit the
target curve. When the value is 1, no UV move.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
curvature(c): float
    properties: create, query
    How curved the UV path will be. 0 is a straight line.
When the values is 1, the mid point of the curve will be moved
away from a straight line by 1/2 the length of the UV segment.

---
gapTolerance(gt): int
    properties: create, query
    When non 0, Small gaps between UV selection are
filled. The integer number represent how many UVs must be
traversed to connect togeterh selected pieces.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
preserveLength(pl): float
    properties: create, query
    How much we want to respect the UV edge ratios. When
the value is 1, we build new UV position along the desired curve,
respecting the original UV spacings.
When the value is 0, new UVs are equally spaced along the curve.

---
uvSetName(uvs): string
    properties: create
    Name of the UV set to be created

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyStraightenUVBorder.html 
    """


def polySubdivideEdge(flagcaching: boolean, flagconstructionHistory: boolean, flagdivisions: int, flagname: string, flagnodeState: int, flagsize: linear, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polySubdivideEdge([caching=boolean], [constructionHistory=boolean], [divisions=int], [name=string], [nodeState=int], [size=linear], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySubdivideEdge is undoable, queryable, and editable.
Default : divide edge into two edges of equal length.




Example:
---
import maya.cmds as cmds

cmds.polyCube( n='plg', w=5, h=5, d=5 )
cmds.scale( 2, 2, 2 )
cmds.select( 'plg' )
cmds.polyOptions( ao=True, dv='true' )
cmds.select( cl=True )

Simple subdivision
cmds.select( 'plg.e[1]' )
cmds.polySubdivideEdge( dv=4 )
The selected edges are subdivided by 4 vertices (5 subedges).

Local bound
cmds.select( 'plg.e[7]' )
cmds.polySubdivideEdge( dv=4, s=1.5 )
The length of each subedge must be greater or equal to 1.5
in local space. Length of original edge is 5 in local space.
Min size indicates that only 3 subedges can be created.

World bound
cmds.select( 'plg.e[5]' )
cmds.polySubdivideEdge( dv=4, s=2, ws=True )
The length of each subedge has to be greater or equal to 2
in world space. Length of original edge is 10 in world space.
All required subdivisions are done.

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
divisions(dv): int
    properties: create, query, edit
    The maximum number of vertices to be inserted in each edge.
This number may be reduced if it creates edges shorter than the
specified minimum length.
C: Default is 1 (divide edges in half).
Q: When queried, this flag returns an int.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
size(s): linear
    properties: create, query, edit
    The minimum length of each subedge created. If the given
subdivision creates edges that are shorter than this length,
the number of divisions is changed to respect min length.
C: Default is 0.0.
Q: When queried, this flag returns a float.

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySubdivideEdge.html 
    """


def polySubdivideFacet(flagcaching: boolean, flagconstructionHistory: boolean, flagdivisions: int, flagdivisionsU: int, flagdivisionsV: int, flagmode: int, flagname: string, flagnodeState: int, flagsubdMethod: int) -> string:
    """Synopsis:
---
---
 polySubdivideFacet([caching=boolean], [constructionHistory=boolean], [divisions=int], [divisionsU=int], [divisionsV=int], [mode=int], [name=string], [nodeState=int], [subdMethod=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polySubdivideFacet is undoable, queryable, and editable.
In quad mode, a center point is introduced at the center of each face
and midpoints are inserted on all the edges of each face. New faces (all
quadrilaterals) are built by adding edges from the midpoints towards the center.
In triangle mode, only the center point is created; new faces (all
triangles) are created by connecting the center point to all the existing
vertices of the face.
Default : one subdivision step in quad mode (polySubdFacet -dv 1 -m 0;)




Example:
---
import maya.cmds as cmds

cmds.polyPlane( n='plg', w=10, h=10, sx=1, sy=3 )

Quads
cmds.polySubdivideFacet( 'plg.f[0]', dv=2 )  becomes 16 quads.

Triangles
cmds.polySubdivideFacet( 'plg.f[2]', dv=1, m=1 )  becomes 4 triangles

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
divisions(dv): int
    properties: create, query, edit
    This number specifies how many times to
recursively subdivide the selected faces.
For example, with divisions set to 3 in quad mode,
each initial quadrilateral will be recursively subdivided into 4
subfaces 3 times, yielding a total of 4 * 4 * 4 = 64 faces.
C: Default is 1.
Q: When queried, this flag returns an int.

---
divisionsU(duv): int
    properties: create, query, edit
    The number of subdivision steps to perform along the U direction.
A square face will be subdivided into 4^(divisions) faces in
quad mode, 4*3^(divisions-1) in triangle mode.

---
divisionsV(dvv): int
    properties: create, query, edit
    The number of subdivision steps to perform along the V direction.
A square face will be subdivided into 4^(divisions) faces in
quad mode, 4*3^(divisions-1) in triangle mode.

---
mode(m): int
    properties: create, query, edit
    The subdivision mode.
 0: subdivision into quads
 1: subdivision into triangles
C: Default is 0.
Q: When queried, this flag returns an int.

---
subdMethod(sbm): int
    properties: create, query, edit
    Type of subdivision to use:
0 - exponential - traditional subdivision
1 - linear - number of faces per edge grows linearly

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polySubdivideFacet.html 
    """


def polyToSubdiv(flagabsolutePosition: boolean, flagaddUnderTransform: boolean, flagapplyMatrixToResult: boolean, flagcaching: boolean, flagconstructionHistory: boolean, flagmaxEdgesPerVert: int, flagmaxPolyCount: int, flagname: string, flagnodeState: int, flagobject: boolean, flagpreserveVertexOrdering: boolean, flagquickConvert: boolean, flaguvPoints: tuple[float, float], flaguvPointsU: float, flaguvPointsV: float, flaguvTreatment: int) -> string:
    """Synopsis:
---
---
 polyToSubdiv(
[poly]
    , [absolutePosition=boolean], [addUnderTransform=boolean], [applyMatrixToResult=boolean], [caching=boolean], [constructionHistory=boolean], [maxEdgesPerVert=int], [maxPolyCount=int], [name=string], [nodeState=int], [object=boolean], [preserveVertexOrdering=boolean], [quickConvert=boolean], [uvPoints=[float, float]], [uvPointsU=float], [uvPointsV=float], [uvTreatment=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyToSubdiv is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

To create a new subdivision surface from a polygon:
cmds.polyToSubdiv( 'polySphere1' )

To create a new subdivision surface from a polygon with history so that
the tesselation can be edited afterwards:
cmds.polyToSubdiv( 'polySphere1', ch=True )

---
Return:
---


    string: - the subdivision and optionally the dependency node name

Flags:
---


---
absolutePosition(ap): boolean
    properties: create, query, edit
    If true, the possible blind data information that comes from the
polygon will be treated as absolute positions of the vertices,
instead of the relative offsets.  You most likelly just want to
use the default of false, unless you know that the blind data
has the absolute positions in it.
Default: false

---
applyMatrixToResult(amr): boolean
    properties: create, query, edit
    If true, the matrix on the input geometry is applied to the object
and the resulting geometry will have identity matrix on it.  If false
the conversion is done on the local space object and the resulting
geometry has the input object's matrix on it.
Default: true

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
maxEdgesPerVert(me): int
    properties: create, query, edit
    The maximum allowed valence for a vertex on the input mesh
Default: 32

---
maxPolyCount(mpc): int
    properties: create, query, edit
    The maximum number of polygons accepted on the input mesh.
Default: 1000

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
preserveVertexOrdering(pvo): boolean
    properties: create, query, edit
    Preserve vertex ordering in conversion
Default: true

---
quickConvert(qc): boolean
    properties: create, query, edit
    Debug flag to test the performance
Default: true

---
uvPoints(uvp): [float, float]
    properties: create, query, edit, multiuse
    This is a cached uv point needed to transfer uv data associated with
finer level vertices (when switching between standard editing mode
and poly proxy mode.

---
uvPointsU(uvu): float
    properties: create, query, edit
    U value of a cached uv point

---
uvPointsV(uvv): float
    properties: create, query, edit
    V value of a cached uv point

---
uvTreatment(uvt): int
    properties: create, query, edit
    Treatment of Subd UVs when in proxy mode:

 0 - preserve Subd UVs
 1 - build Subd UVs from Poly UVs
 2 - no UVs on Subd

Default: 0

---
addUnderTransform(aut): boolean
    properties: create
    If true then add the new subdivision surface under the poly's transform.

---
constructionHistory(ch): boolean
    properties: create
    Turn the construction history on or off.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyToSubdiv.html 
    """


def polyTorus(flagaxis: tuple[linear, linear, linear], flagcaching: boolean, flagconstructionHistory: boolean, flagcreateUVs: boolean, flagname: string, flagnodeState: int, flagobject: boolean, flagradius: linear, flagsectionRadius: linear, flagsubdivisionsAxis: int, flagsubdivisionsHeight: int, flagsubdivisionsX: int, flagsubdivisionsY: int, flagtexture: boolean, flagtwist: angle) -> list[string]:
    """Synopsis:
---
---
 polyTorus([axis=[linear, linear, linear]], [caching=boolean], [constructionHistory=boolean], [createUVs=boolean], [name=string], [nodeState=int], [object=boolean], [radius=linear], [sectionRadius=linear], [subdivisionsAxis=int], [subdivisionsHeight=int], [subdivisionsX=int], [subdivisionsY=int], [texture=boolean], [twist=angle])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyTorus is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.polyTorus( sx=8, sy=16, r=10, sr=1 )
---
result has 8 sections of 16 segments,
---
the main radius is 10, the section radius is 1.

cmds.polyTorus( sx=5, sy=4, tx=False )
cmds.move( -3, 0, 0 )
---
result has 5 sections of 4 segments, default sizes.
---
no texture offsets are generated.

cmds.polyTorus( sx=5, sy=4, tw=45 )
cmds.move( 3, 0, 0 )
---
result has 5 sections of 4 segments, default sizes.
---
The sections are rotated.

---
Query the radius of the torus
r = cmds.polyTorus( 'polyTorus1' ,q=True, r=True )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
axis(ax): [linear, linear, linear]
    properties: create, query, edit
    This flag specifies the primitive axis used to build the torus.
Q: When queried, this flag returns a vector.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
createUVs(cuv): boolean
    properties: create, query, edit
    Create UVs or not.
Default: true

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node (where applicable).

---
radius(r): linear
    properties: create, query, edit
    Radius of the torus.
Default: 1.0

---
sectionRadius(sr): linear
    properties: create, query, edit
    Section of the torus.
Default: 0.50

---
subdivisionsAxis(sa): int
    properties: create, query, edit
    Subdivisions about the vertical axis.
Default: 20

---
subdivisionsHeight(sh): int
    properties: create, query, edit
    Subdivisions along the height.
Default: 20

---
subdivisionsX(sx): int
    properties: create, query, edit
    This specifies the number of subdivisions in the X direction for the torus (number of sections).
C: Default is 20.
Q: When queried, this flag returns an int.

---
subdivisionsY(sy): int
    properties: create, query, edit
    This flag specifies the number of subdivisions in the Y direction for the torus (number of segments per section).
C: Default is 20.
Q: When queried, this flag returns an int.

---
texture(tx): boolean
    properties: create, query, edit
    Apply texture or not. this is an old attribute.
This is unsupported and would be removed in a future release.
Default: true

---
twist(tw): angle
    properties: create, query, edit
    Twist angle of the torus.
Default: 0.0

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyTorus.html 
    """


def polyTransfer(flagalternateObject: string, flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int, flaguvSets: boolean, flagvertexColor: boolean, flagvertices: boolean) -> string:
    """Synopsis:
---
---
 polyTransfer([alternateObject=string], [caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int], [uvSets=boolean], [vertexColor=boolean], [vertices=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyTransfer is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create two objects with same a cube.
cmds.polyCube( sx=5, sy=5, sz=5, n='plg' )
cmds.polyCube( sx=5, sy=5, sz=5, n='atlPlg' )

Tweak the geometry of the first object
cmds.select( 'plg.vtx[0:50]', r=True )
cmds.move( .1, .2, .3, r=True )

Spherical mapping on the alternate object
cmds.polyProjection( 'atlPlg.f[0:149]', type='Spherical' )

Copy the UVs from the alternate to the first object.
cmds.polyTransfer( 'plg', uv=1, ao='atlPlg' )

---
Return:
---


    string: representing the node name.

Flags:
---


---
alternateObject(ao): string
    properties: create, query, edit
    Name of the alternate object.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
uvSets(uv): boolean
    properties: create, query, edit
    When true, the UV sets are copied from the alternate object.
C: Default is "on".

---
vertexColor(vc): boolean
    properties: create, query, edit
    When true, the colors per vertex are copied from the
alternate object.
C: Default is "off".

---
vertices(v): boolean
    properties: create, query, edit
    When true, the vertices positions are copied from
the alternate object.
C: Default is "off".

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyTransfer.html 
    """


def polyTriangulate(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyTriangulate([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyTriangulate is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Non-planar faces
cmds.polyPlane( n='plg1', sx=5, sy=5, w=5, h=5 )
cmds.move( -6, 0, 0 )
cmds.polyMoveVertex( 'plg1.vtx[7]', 'plg1.vtx[10]', 'plg1.vtx[25]', 'plg1.vtx[28]', ltz=1 )
cmds.polyTriangulate( 'plg1.f[0:1]', 'plg1.f[5:6]', 'plg1.f[3:4]', 'plg1.f[8:9]', 'plg1.f[15:16]', 'plg1.f[20:21]', 'plg1.f[18:19]', 'plg1.f[23:24]' )

Holed faces
maya.cmds.polyCreateFacet( p=[(2.5, 0, 2.5), (2.5, 0, -2.5), (-2.5, 0, -2.5), (-2.5, 0, 2.5), (), (1, 0, -1), (-1, 0, -1), (-1, 0, 1), (1, 0, 1)],  n='plg2' )
cmds.polyTriangulate( 'plg2.f[0]' )

Both holed and non-planar facets
cmds.polyPlane( n='plg3', sx=3, sy=3, h=5, w=5 )
cmds.move( 6, 0, 0 )
cmds.polyChipOff( 'plg3.f[4]', dup=1, ltz=1, ls=(.25, .25, .25) )
cmds.polyMergeFacet( 'plg3', ch=True, ff=4, sf=9 )
cmds.polyTriangulate( 'plg3.f[4]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyTriangulate.html 
    """


def polyUVCoverage(flaguvRange: tuple[float, float, float, float]) -> float[]:
    """Synopsis:
---
---
 polyUVCoverage(
selectionItem[]
    , [uvRange=[float, float, float, float]])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyUVCoverage is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

Return UV coverage from selection list
cmds.polyUVCoverage()
Result: [0.3799999952316284] ---


Return UV coverage from specified components with specified range
cmds.polyUVCoverage('pCube1.f[0:5]', usr=(0,0,2,2));
Result: [0.09749999642372131] ---


---
Return:
---


    float[]: UV space coverage percentage

Flags:
---


---
uvRange(ur): [float, float, float, float]
    properties: create
    UV space range for calculating the coverage
The 4 values specify the minimum U, V and maximum U, V in that order. Default is 0.0 0.0 1.0 1.0.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyUVCoverage.html 
    """


def polyUVOverlap(flagnonOverlappingComponents: boolean, flagoverlappingComponents: boolean) -> selectionItem[]:
    """Synopsis:
---
---
 polyUVOverlap(
selectionItem[]
    , [nonOverlappingComponents=boolean], [overlappingComponents=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyUVOverlap is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

Return UV overlapping components from selection list
cmds.polyUVOverlap( oc=True )
Result: [pCubeShape1.f[1], pCubeShape1.f[2]] ---


Return UV non-overlapping components from specified components
cmds.polyUVOverlap('pCube1.f[0:5]', noc=True)
Result: [pCubeShape1.f[0], pCubeShape1.f[3], pCubeShape1.f[4], pCubeShape1.f[5]] ---


---
Return:
---


    selectionItem[]: List of poly components

Flags:
---


---
nonOverlappingComponents(noc): boolean
    properties: create
    Return non-overlapping components based on selected/specified components

---
overlappingComponents(oc): boolean
    properties: create
    Return overlapping components based on selected/specified components

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyUVOverlap.html 
    """


def polyUVRectangle(flagcaching: boolean, flagconstructionHistory: boolean, flagname: string, flagnodeState: int) -> string:
    """Synopsis:
---
---
 polyUVRectangle([caching=boolean], [constructionHistory=boolean], [name=string], [nodeState=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyUVRectangle is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Opening up the textureView will make this example much easier to visualize.

make a cylinder
cmds.polyCylinder( r=1, h=2, sx=20, sy=10, sz=1, ax=(0,1,0), rcp=0, cuv=3, ch=1 )

map a 3x2 area of faces to the 0-1 UV square
cmds.polyUVRectangle( 'pCylinderShape1.vtx[115]', 'pCylinderShape1.vtx[57]' )

map a 2x20 ring of faces to the 0-1 UV square
cmds.polyUVRectangle( 'pCylinderShape1.vtx[136]', 'pCylinderShape1.vtx[176]' )

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyUVRectangle.html 
    """


def polyUVSet(flagallUVSets: boolean, flagallUVSetsIndices: boolean, flagallUVSetsWithCount: boolean, flagcopy: boolean, flagcreate: boolean, flagcurrentLastUVSet: boolean, flagcurrentPerInstanceUVSet: boolean, flagcurrentUVSet: boolean, flagdelete: boolean, flaggenNewUVSet: boolean, flagnewUVSet: string, flagperInstance: boolean, flagprojections: boolean, flagrename: boolean, flagreorder: boolean, flagshareInstances: boolean, flagunshared: boolean, flaguvSet: string) -> boolean:
    """Synopsis:
---
---
 polyUVSet([allUVSets=boolean], [allUVSetsIndices=boolean], [allUVSetsWithCount=boolean], [copy=boolean], [create=boolean], [currentLastUVSet=boolean], [currentPerInstanceUVSet=boolean], [currentUVSet=boolean], [delete=boolean], [genNewUVSet=boolean], [newUVSet=string], [perInstance=boolean], [projections=boolean], [rename=boolean], [reorder=boolean], [shareInstances=boolean], [unshared=boolean], [uvSet=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyUVSet is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds


start with poly object
cmds.polySphere(n='plg', cuv=1, r=10.0)

Make a copy of "map1" to a new uvset. The
name of which is automatically generated and returned.
cmds.polyUVSet( copy=True, uvSet='map1' )

Create a new empty uv set
cmds.polyUVSet( create=True, uvSet='map2' )

To set the current uv set to be "map2".
cmds.polyUVSet( currentUVSet=True,  uvSet='map2')

To set the current uv set to the last uv set added to an object.
cmds.polyUVSet( currentLastUVSet=True )

To query the current uv set.
cmds.polyUVSet( query=True, currentUVSet=True )

To rename a currently existing uv set from "map2" to "map3".
cmds.polyUVSet(rename=True, newUVSet='map3', uvSet= 'map2')

Rename the current uv set (if any) to "map4".
cmds.polyUVSet(rename=True, newUVSet='map4' )

To delete a currently existing uv set "map4".
cmds.polyUVSet( delete=True, uvSet='map4')

To delete the current uv set (if any)
cmds.polyUVSet( delete=True )

Copy values of uvset "map1" to "map2"
cmds.polyUVSet( copy=True, nuv='map2', uvSet='map1' )

Copy values of the current uvset to "map2"
cmds.polyUVSet( copy=True, nuv='map2' )

Reorder uvsets "map1" and "map2"
cmds.polyUVSet( reorder=True, nuv='map2', uvSet='map1' )

Create a new empty uv set with a generate new name
The newly generated name is returned.
cmds.polyUVSet( create=True )

To query all of the uv sets
cmds.polyUVSet( query=True, allUVSets=True )

To query the logical indices of the uv sets in the
uv set array of the node
node = "plg"
indices = cmds.polyUVSet(node, query=True, allUVSetsIndices=True)

for i in indices[:]:
        name = cmds.getAttr(node+".uvSet["+str(i)+"].uvSetName")
        print("Found uv set called " + name )

To create a new per-instance uv set named "myMap"
cmds.polyUVSet(create=True,perInstance=True,uvSet='myMap');

---
Return:
---


    boolean: Success or Failure.

Flags:
---


---
allUVSets(auv): boolean
    properties: query, edit
    This flag when used in in a query will return a list of all
of the uv set names

---
allUVSetsIndices(uvn): boolean
    properties: query, edit
    This flag when queried will return a list of the logical plug
indices of all the uv sets in the sparse uv set array.

---
allUVSetsWithCount(awc): boolean
    properties: query, edit
    This flag when used in a query will return a list of all
of the uv set family names, with a count appended to the perInstance
sets indicating the number of instances in the uv set shared by
the specified or selected shape.

---
copy(cp): boolean
    properties: create, query, edit
    This flag when used will result in the copying of the uv set corresponding
to name specified with the uvSet flag to the uvset corresponding
to the name specified with the newUVSet flag

---
create(cr): boolean
    properties: create, query, edit
    This flag when used will result in the creation of an empty uv set
corresponding to the name specified with the uvSet flag. If
a uvSet with that name already exists, then no new uv set will
be created.

---
currentLastUVSet(luv): boolean
    properties: create, query, edit
    This flag when used will set the current uv set that the object needs to
work on, to be the last uv set added to the object.
If no uv set exists for the object, then no uv set name will be returned.

---
currentPerInstanceUVSet(cpi): boolean
    properties: query, edit
    This is a query-only flag for use when the current uv set is a per-instance
uv set family. This returns the member of the set family that corresponds
to the currently select instance.

---
currentUVSet(cuv): boolean
    properties: create, query, edit
    This flag when used will set the current uv set that the object needs to
work on, to be the uv set corresponding to the name specified with the
uvSet flag. This does require that a uvSet with the specified name exist.
When queried, this returns the current uv set.

---
delete(d): boolean
    properties: create, query, edit
    This flag when used will result in the deletion of the uv set corresponding
to the name specified with the uvSet flag.

---
genNewUVSet(gen): boolean
    properties: query, edit
    This is a query-only flag to generate a new unique name.

---
newUVSet(nuv): string
    properties: create, query, edit
    Specifies the name that the uv set corresponding to the name specified with
the uvSet flag, needs to be renamed to.

---
perInstance(pi): boolean
    properties: create, query, edit
    This flag can be used in conjunction with the create flag to indicate
whether or not the uv set is per-instance. When you create a per-instance
uv set, the set will be applied as shared between all selected instances
of the shape unless the unshared flag is used. The perInstance flag can
be used in query mode with the currentUVSet or allUVSets  flag to indicate
that the set family names (i.e. not containing instance identifiers) will
be returned by the query.
                        In query mode, this flag can accept a value.

---
projections(pr): boolean
    properties: query, edit
    This flag when used in a query will return a list of polygon
uv projection node names. The order of the list is from
most-recently-applied to least-recently-applied.

---
rename(rn): boolean
    properties: create, query, edit
    This flag when used will result in the renaming of the uv set corresponding
to the name specified with the uvSet flag to the name specified using the
newUVSet flag.

---
reorder(ro): boolean
    properties: create, query, edit
    This flag when used will result in the reordering of two uv sets corresponding
to name specified with the uvSet flag, and the uvset corresponding
to the name specified with the newUVSet flag

---
shareInstances(si): boolean
    properties: create, query, edit
    This flag is used to modify the sharing of per-instance uv sets within
a given uv set family so that all selected instances share the specified
set. In query mode, it returns a list of the instances that share the
set specified by the uvSet flag.

---
unshared(us): boolean
    properties: create, query, edit
    This flag can be used in conjunction with the create and perInstance flags
to indicate that the newly created per-instance set should be created with
a separate set per instance.

---
uvSet(uvs): string
    properties: create, query, edit
    Specifies the name of the uv set that this command needs to work on.
This flag has to be specified for this command to do anything meaningful
other than query the current uv set.
                        In query mode, this flag needs a value.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyUVSet.html 
    """


def polyUVStackSimilarShells(flagonlyMatch: boolean, flagtolerance: float) -> list[string]:
    """Synopsis:
---
---
 polyUVStackSimilarShells(
selectionItem[]
    , [onlyMatch=boolean], [tolerance=float])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyUVStackSimilarShells is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

// Stack Similar UV Shells with tolerance.
cmds.polyUVStackSimilarShells(to = 0.001)

---
Return:
---


    list[string]: UVs of stacked UV Shells or target UV shells.

Flags:
---


---
onlyMatch(om): boolean
    properties: create
    If this flag is true, only match UV shells and return UVs of target UV shells but don't stack.

---
tolerance(to): float
    properties: create
    The tolerance setting for stacking how similar UV shells.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyUVStackSimilarShells.html 
    """


def polyUnite(flagcaching: boolean, flagcenterPivot: boolean, flagmergeUVSets: int, flagnodeState: int, flagobjectPivot: boolean) -> list[string]:
    """Synopsis:
---
---
 polyUnite(
poly poly [poly ...]
    , [caching=boolean], [centerPivot=boolean], [mergeUVSets=int], [nodeState=int], [objectPivot=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyUnite is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polySphere( n='plg1' )
cmds.polyCube( w=2, h=.2, d=2, n='plg2' )
cmds.move( 0, -1.1, 0 )
cmds.polyCube( w=2, h=.2, d=2, n='plg3' )
cmds.move( 0, 1.1, 0 )
cmds.polyUnite( 'plg1', 'plg2', 'plg3', n='result' )
cmds.rotate( 0, 0, 90, 'result' )

---
Return:
---


    list[string]: Object name and node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
mergeUVSets(muv): int
    properties: create
    Specify how UV sets will be merged on the output mesh.
The choices are 0 | 1 | 2.
0 = Do not merge. Each UV set on each mesh will become a new UV set in the output.
1 = Merge by name. UV sets with the same name will be merged.
2 = Merge by UV links. UV sets will be merged so that UV linking on the input meshes continues to work.
The default is 1 (merge by name).

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
centerPivot(cp): boolean
    properties: create
    Set the resulting object's pivot to the center of the selected objects bounding box.

---
objectPivot(op): boolean
    properties: create
    Set the resulting object's pivot to last selected object's pivot.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyUnite.html 
    """


def polyUniteSkinned(flagcenterPivot: boolean, flagconstructionHistory: boolean, flagmergeUVSets: int, flagobjectPivot: boolean) -> None:
    """Synopsis:
---
---
 polyUniteSkinned([centerPivot=boolean], [constructionHistory=boolean], [mergeUVSets=int], [objectPivot=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyUniteSkinned is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

cmds.polyUniteSkinned( 'pSphere1', 'pSphere2', ch=0 )

---


Flags:
---


---
centerPivot(cp): boolean
    properties: create, query, edit
    Set the resulting object's pivot to the center of the selected objects bounding box.

---
constructionHistory(ch): boolean
    properties: create, query, edit
    Turn the construction history on or off.

---
mergeUVSets(muv): int
    properties: create, query, edit
    Specify how UV sets will be merged on the output mesh.
The choices are 0 | 1 | 2.
0 = Do not merge. Each UV set on each mesh will become a new UV set in the output.
1 = Merge by name. UV sets with the same name will be merged.
2 = Merge by UV links. UV sets will be merged so that UV linking on the input meshes continues to work.
The default is 1 (merge by name).

---
objectPivot(op): boolean
    properties: create, query, edit
    Set the resulting object's pivot to last selected object's pivot.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyUniteSkinned.html 
    """


def polyUnsmooth(flagcaching: boolean, flagconstructionHistory: boolean, flagdivisionLevels: int, flagfrozen: boolean, flagname: string, flagnodeState: int, flagreplaceOriginal: boolean) -> string:
    """Synopsis:
---
---
 polyUnsmooth([caching=boolean], [constructionHistory=boolean], [divisionLevels=int], [frozen=boolean], [name=string], [nodeState=int], [replaceOriginal=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyUnsmooth is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Create a default Maya cube:
cmds.polyCube()
cmds.polyEvaluate( 'pCube1', face=True )
Result: 6

Run Catmull-Clark subdivision 4 times to create a higher poly count object, and then
delete construction history.
cmds.polySmooth( 'pCube1', dv=4 )
cmds.delete( 'pCube1', ch=True )
cmds.polyEvaluate( 'pCube1', face=True )
Result: 1536

Attempt to figure out the lowest original level before Catmull-Clark subdivision was run.
cmds.polyUnsmooth( 'pCube1', divisionLevels=4 )
cmds.polyEvaluate( 'pCube1', face=True )
Result: 6

---
Return:
---


    string: The node name.

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
divisionLevels(dlv): int
    properties: create, query, edit
    This flag specifies how many subdivision levels to attempt to step backwards.

---
frozen(fzn): boolean
    properties: create, query, edit
    Inherited from base class TpolyCleanCmd.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
replaceOriginal(rpo): boolean
    properties: create
    Create "in place" (i.e., replace) (not available in all commands). NOTE:
This flag is intended for use by the "Unsmoorh" menu item. If
'polyUnsmooth -rpo 0' is executed from the command line, Shader information will
not be copied from the original mesh to the result.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyUnsmooth.html 
    """


def polyWedgeFace(flagaxis: tuple[float, float, float], flagcaching: boolean, flagcenter: tuple[float, float, float], flagconstructionHistory: boolean, flagdivisions: int, flagedge: int, flagname: string, flagnodeState: int, flagwedgeAngle: angle, flagworldSpace: boolean) -> string:
    """Synopsis:
---
---
 polyWedgeFace([axis=[float, float, float]], [caching=boolean], [center=[float, float, float]], [constructionHistory=boolean], [divisions=int], [edge=int], [name=string], [nodeState=int], [wedgeAngle=angle], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

polyWedgeFace is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.polyPlane( n='plg', w=10, h=10 )

Wedge about a single axis
cmds.polyWedgeFace( 'plg.f[24:29]', 'plg.f[34]', 'plg.f[44]', 'plg.f[54]', 'plg.f[64]', 'plg.f[74:79]', ws=1, wedgeAngle=90, divisions=8, ed=(62,167), ch=1 )

Wedge about multiple axes (one axis for each command)
cmds.polyCube( n='plg', w=1, h=1, d=1, sx=4, sy=4, sz=4, ax=(0, 1, 0), tx=1, ch=1 )
cmds.polyWedgeFace( 'plg.f[64:79]', ws=1, wedgeAngle=90, divisions=9, ed=(128, 133, 138, 143), ch=1 )
cmds.polyWedgeFace( 'plg.f[0:15]', ws=1, wedgeAngle=90, divisions=9, ed=(0, 1, 2, 3), ch=1 )
cmds.polyWedgeFace( 'plg.f[80:95]', ws=1, wedgeAngle=90, divisions=9, ed=(100, 105, 110, 115), ch=1 )
cmds.polyWedgeFace( 'plg.f[32:47]', ws=1, wedgeAngle=90, divisions=9, ed=(36, 37, 38, 39), ch=1 )

---
Return:
---


    string: The node name.

Flags:
---


---
axis(ax): [float, float, float]
    properties: create
    This flag (along with -center) can be used instead of the -edge flag to
specify the axis about which the wedge is performed. The flag expects
three coordinates that form a vector about which the rotation is performed.

---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
center(cen): [float, float, float]
    properties: create
    This flag (along with -axis) can be used instead of the -edge flag to
specify the location about which the wedge is performed. The flag expects
three coordinates that define the center of rotation.

---
constructionHistory(ch): boolean
    properties: create, query
    Turn the construction history on or off (where applicable). If
construction history is on then the corresponding node will be
inserted into the history chain for the mesh. If construction history
is off then the operation will be performed directly on the object.

Note: If the object already has construction history then
this flag is ignored and the node will always be inserted into
the history chain.

---
divisions(d): int
    properties: create
    This flag specifies the number of subdivisions
along the extrusion.

---
edge(ed): int
    properties: create, multiuse
    This flag specifies the edgeId that should be
used to perform the wedge about. Multiple edges
can be specified. The wedge operation is performed
about an axis that is the average of all the edges.
It is recommended that only colinear edges are
used, otherwise the result may not look intuitive.

Instead of specifying the -edge flag, the wedge can be
performed about a point and axis. See the -center and
-axis flags for details.

---
name(n): string
    properties: create
    Give a name to the resulting node.

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
wedgeAngle(wa): angle
    properties: create
    This flag specifies the angle of rotation.

---
worldSpace(ws): boolean
    properties: create, query, edit
    This flag specifies which reference to use.
If "on" : all geometrical values are taken in world reference.
If "off" : all geometrical values are taken in object reference.
C: Default is off.
Q: When queried, this flag returns an int.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/polyWedgeFace.html 
    """


def popupMenu(flagallowOptionBoxes: boolean, flagaltModifier: boolean, flagbutton: int, flagctrlModifier: boolean, flagdefineTemplate: string, flagdeleteAllItems: boolean, flagexists: boolean, flagitemArray: boolean, flagmarkingMenu: boolean, flagnumberOfItems: boolean, flagparent: string, flagpostMenuCommand: script, flagpostMenuCommandOnce: boolean, flagshiftModifier: boolean, flaguseTemplate: string) -> string:
    """Synopsis:
---
---
 popupMenu(
string
    , [allowOptionBoxes=boolean], [altModifier=boolean], [button=int], [ctrlModifier=boolean], [defineTemplate=string], [deleteAllItems=boolean], [exists=boolean], [itemArray=boolean], [markingMenu=boolean], [numberOfItems=boolean], [parent=string], [postMenuCommand=script], [postMenuCommandOnce=boolean], [shiftModifier=boolean], [useTemplate=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

popupMenu is undoable, queryable, and editable.
Popup menus can be added to any kind of control, however,
on some widgets, only the standard menu button (3rd mouse button)
can be used to trigger popup menus. This is to meet generally
accepted UI guidelines that assign the 3rd mouse button and only
this one to popup menus, and also to prevent unexpected behavior
of controls like text fields, that expect 1st and 2nd button to be
reserved for contextual operations like text or item selection...




Example:
---
import maya.cmds as cmds

cmds.window()
cmds.columnLayout()
cmds.button()
cmds.popupMenu()
cmds.menuItem()
cmds.menuItem()
cmds.menuItem()
cmds.text()
cmds.popupMenu( button=1 )
cmds.menuItem()
cmds.menuItem()
cmds.menuItem()
cmds.checkBox( 'aCheckBox' )
cmds.popupMenu( parent='aCheckBox', alt=True, ctl=True )
cmds.menuItem()
cmds.menuItem()
cmds.menuItem()
cmds.showWindow()

---
Return:
---


    string: Full path name to the menu.

Flags:
---


---
allowOptionBoxes(aob): boolean
    properties: create, query
    Indicate whether the menu will be able to support option box
menu items.  An error results if an option box item is added to a
menu that doesn't allow them.  This flag may be queried and must be
specified when the popup menu is created.  The default value is
false.

---
altModifier(alt): boolean
    properties: create, query, edit
    Specify this flag if the Alt modifier must be pressed when
posting the popup menu.

---
button(b): int
    properties: create, query, edit
    Indicate which button posts the popup menu.  Valid values
range from 1 to 3 where 1 is the left most button on the mouse.

---
ctrlModifier(ctl): boolean
    properties: create, query, edit
    Specify this flag if the Cntl modifier must be pressed when
posting the popup menu.

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
deleteAllItems(dai): boolean
    properties: edit
    Delete all the items in this menu.

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
itemArray(ia): boolean
    properties: query
    Return string array of the menu item names.

---
markingMenu(mm): boolean
    properties: create, query, edit
    Set the marking menu state of this popup menu.

---
numberOfItems(ni): boolean
    properties: query
    Return number of items in the menu.

---
parent(p): string
    properties: create
    Specify the control that the popup menu will appear in.

---
postMenuCommand(pmc): script
    properties: create, edit
    Specify a script to be executed when the popup menu is about
to be shown.

---
postMenuCommandOnce(pmo): boolean
    properties: create, query, edit
    Indicate the -pmc/postMenuCommand should only be
invoked once.  Default value is false, ie.
the -pmc/postMenuCommand is invoked every time the popup menu is
shown.

---
shiftModifier(sh): boolean
    properties: create, query, edit
    Specify this flag if the Shift modifier must be pressed
when posting the popup menu.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/popupMenu.html 
    """


def pose(flagallPoses: boolean, flagapply: boolean, flagname: string) -> string:
    """Synopsis:
---
---
 pose([allPoses=boolean], [apply=boolean], [name=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

pose is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

First, create a character to hold the pose. The character will be
a 3-bone skeleton named "arm".
---

cmds.select( d=True )
cmds.joint( p=(0, 0, 0) )
cmds.joint( p=(0, 4, 0) )
cmds.joint( 'joint1', e=True, zso=True, oj='xyz' )
cmds.joint( p=(0, 8, -1) )
cmds.joint( 'joint2', e=True, zso=True, oj='xyz' )
cmds.joint( p=(0, 9, -2) )
cmds.joint( 'joint3', e=True, zso=True, oj='xyz' )
cmds.select( 'joint2', 'joint3', 'joint1', r=True )
cmds.character( name='arm' )


Create a pose for the current joint position named "handWave"
---

cmds.pose( 'arm', name='handWave' )

Query the existing poses
---

cmds.pose( 'arm', query=True, n=True )

Restore the pose onto the character
---

cmds.pose( 'arm', name='handWave', apply=True )

---
Return:
---


    string: Pose name

Flags:
---


---
allPoses(ap): boolean
    properties: query
    This flag is used to query all the poses in the scene.

---
apply(a): boolean
    properties: create
    This flag is used in conjunction with the name flag to specify a pose should be applied to the character.

---
name(n): string
    properties: create, query
    In create mode, specify the pose name. In query mode, return a list of all the poses for the character. In apply mode, specify the pose to be applied.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/pose.html 
    """


def poseEditor(flagcontrol: boolean, flagdefineTemplate: string, flagdocTag: string, flagexists: boolean, flagfilter: string, flagforceMainConnection: string, flaghighlightConnection: string, flaglockMainConnection: boolean, flagmainListConnection: string, flagpanel: string, flagparent: string, flagselectionConnection: string, flagstateString: boolean, flagunParent: boolean, flagunlockMainConnection: boolean, flagupdateMainConnection: boolean, flaguseTemplate: string) -> string:
    """Synopsis:
---
---
 poseEditor(
string
    , [control=boolean], [defineTemplate=string], [docTag=string], [exists=boolean], [filter=string], [forceMainConnection=string], [highlightConnection=string], [lockMainConnection=boolean], [mainListConnection=string], [panel=string], [parent=string], [selectionConnection=string], [stateString=boolean], [unParent=boolean], [unlockMainConnection=boolean], [updateMainConnection=boolean], [useTemplate=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

poseEditor is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.poseEditor( 'poseEd' )

---
Return:
---


    string: The name of the editor

Flags:
---


---
control(ctl): boolean
    properties: query
    Query only. Returns the top level control for this editor.
Usually used for getting a parent to attach popup menus.
Caution: It is possible for an editor to exist without a
control. The query will return "NONE" if no control is present.

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
docTag(dtg): string
    properties: create, query, edit
    Attaches a tag to the editor.

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
filter(f): string
    properties: create, query, edit
    Specifies the name of an itemFilter object to be used with this editor.
This filters the information coming onto the main list
of the editor.

---
forceMainConnection(fmc): string
    properties: create, query, edit
    Specifies the name of a selectionConnection object that the
editor will use as its source of content. The editor will only
display items contained in the selectionConnection object. This is
a variant of the -mainListConnection flag in that it will force a
change even when the connection is locked. This flag is used to
reduce the overhead when using the -unlockMainConnection
, -mainListConnection, -lockMainConnection flags in immediate
succession.

---
highlightConnection(hlc): string
    properties: create, query, edit
    Specifies the name of a selectionConnection object that
the editor will synchronize with its highlight list. Not all
editors have a highlight list. For those that do, it is a secondary
selection list.

---
lockMainConnection(lck): boolean
    properties: create, edit
    Locks the current list of objects within the mainConnection,
so that only those objects are displayed within the editor.
Further changes to the original mainConnection are ignored.

---
mainListConnection(mlc): string
    properties: create, query, edit
    Specifies the name of a selectionConnection object that the
editor will use as its source of content. The editor will
only display items contained in the selectionConnection object.

---
panel(pnl): string
    properties: create, query
    Specifies the panel for this editor. By default if
an editor is created in the create callback of a scripted panel it
will belong to that panel. If an editor does not belong to a panel
it will be deleted when the window that it is in is deleted.

---
parent(p): string
    properties: create, query, edit
    Specifies the parent layout for this editor. This flag will only
have an effect if the editor is currently un-parented.

---
selectionConnection(slc): string
    properties: create, query, edit
    Specifies the name of a selectionConnection object that the
editor will synchronize with its own selection list. As the user
selects things in this editor, they will be selected in the
selectionConnection object. If the object undergoes changes, the
editor updates to show the changes.

---
stateString(sts): boolean
    properties: query
    Query only flag. Returns the MEL command that will create an
editor to match the current editor state. The returned command string
uses the string variable $editorName in place of a specific name.

---
unParent(up): boolean
    properties: create, edit
    Specifies that the editor should be removed from its layout.
This cannot be used in query mode.

---
unlockMainConnection(ulk): boolean
    properties: create, edit
    Unlocks the mainConnection, effectively restoring the original
mainConnection (if it is still available), and dynamic updates.

---
updateMainConnection(upd): boolean
    properties: create, edit
    Causes a locked mainConnection to be updated from the orginal
mainConnection, but preserves the lock state.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/poseEditor.html 
    """


def posePanel(flagcontrol: boolean, flagcopy: string, flagcreateString: boolean, flagdefineTemplate: string, flagdocTag: string, flageditString: boolean, flagexists: boolean, flaginit: boolean, flagisUnique: boolean, flaglabel: string, flagmenuBarRepeatLast: boolean, flagmenuBarVisible: boolean, flagneedsInit: boolean, flagparent: string, flagpopupMenuProcedure: script, flagposeEditor: boolean, flagreplacePanel: string, flagtearOff: boolean, flagtearOffCopy: string, flagtearOffRestore: boolean, flagunParent: boolean, flaguseTemplate: string) -> string:
    """Synopsis:
---
---
 posePanel(
string
    , [control=boolean], [copy=string], [createString=boolean], [defineTemplate=string], [docTag=string], [editString=boolean], [exists=boolean], [init=boolean], [isUnique=boolean], [label=string], [menuBarRepeatLast=boolean], [menuBarVisible=boolean], [needsInit=boolean], [parent=string], [popupMenuProcedure=script], [poseEditor=boolean], [replacePanel=string], [tearOff=boolean], [tearOffCopy=string], [tearOffRestore=boolean], [unParent=boolean], [useTemplate=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

posePanel is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.posePanel( 'pP' )

---
Return:
---


    string: The name of the panel

Flags:
---


---
control(ctl): boolean
    properties: query
    Returns the top level control for this panel.
Usually used for getting a parent to attach popup menus.
CAUTION: panels may not have controls at times.  This
flag can return "" if no control is present.

---
copy(cp): string
    properties: edit
    Makes this panel a copy of the specified panel.  Both
panels must be of the same type.

---
createString(cs): boolean
    properties: edit
    Command string used to create a panel

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
docTag(dtg): string
    properties: create, query, edit
    Attaches a tag to the Maya panel.

---
editString(es): boolean
    properties: edit
    Command string used to edit a panel

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
init(init): boolean
    properties: create, edit
    Initializes the panel's default state.  This is usually done
automatically on file -new and file -open.

---
isUnique(iu): boolean
    properties: query
    Returns true if only one instance of this panel type is allowed.

---
label(l): string
    properties: query, edit
    Specifies the user readable label for the panel.

---
menuBarRepeatLast(mrl): boolean
    properties: create, query, edit
    Controls whether clicking on the menu header with the middle mouse button would repeat the last selected menu item.

---
menuBarVisible(mbv): boolean
    properties: create, query, edit
    Controls whether the menu bar for the panel is displayed.

---
needsInit(ni): boolean
    properties: query, edit
    (Internal) On Edit will mark the panel as requiring initialization.
Query will return whether the panel is marked for initialization.  Used
during file -new and file -open.

---
parent(p): string
    properties: create
    Specifies the parent layout for this panel.

---
popupMenuProcedure(pmp): script
    properties: query, edit
    Specifies the procedure called for building the panel's popup menu(s).
The default value is "buildPanelPopupMenu".  The procedure should take
one string argument which is the panel's name.

---
poseEditor(pe): boolean
    properties: query
    Query only flag that returns the name of an editor to be associated with the panel.

---
replacePanel(rp): string
    properties: edit
    Will replace the specified panel with this panel.  If the
target panel is within the same layout it will perform a swap.

---
tearOff(to): boolean
    properties: query, edit
    Will tear off this panel into a separate window with a paneLayout
as the parent of the panel. When queried this flag will return if the
panel has been torn off into its own window.

---
tearOffCopy(toc): string
    properties: create
    Will create this panel as a torn of copy of the specified source panel.

---
tearOffRestore(tor): boolean
    properties: create, edit
    Restores panel if it is torn off and focus is given to it.
If docked, becomes the active panel in the docked window.
This should be the default flag that is added to all panels
instead of -to/-tearOff flag which should only be used to tear off the panel.

---
unParent(up): boolean
    properties: edit
    Specifies that the panel should be removed from its layout.
This (obviously) cannot be used with query.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/posePanel.html 
    """


def preferredRenderer(flagfallback: string, flagmakeCurrent: boolean) -> None:
    """Synopsis:
---
---
 preferredRenderer([string], [fallback=string], [makeCurrent=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

preferredRenderer is NOT undoable, queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

To set the preferred renderer to a renderer called "myRenderer":
---

cmds.preferredRenderer( 'myRenderer' )

To query the preferred renderer
---

cmds.preferredRenderer( query=True )

To set the current renderer as the preferred one
---

cmds.preferredRenderer( makeCurrent=True )

To set the preferred fallback renderer
---

cmds.preferredRenderer( fallback='myRenderer' )

---


Flags:
---


---
fallback(f): string
    properties: create, query
    Sets the preferred fallback renderer.

---
makeCurrent(mc): boolean
    properties: create
    Sets the current renderer as the preferred one.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/preferredRenderer.html 
    """


def preloadRefEd(flagcontrol: boolean, flagdefineTemplate: string, flagdocTag: string, flagexists: boolean, flagfilter: string, flagforceMainConnection: string, flaghighlightConnection: string, flaglockMainConnection: boolean, flagmainListConnection: string, flagpanel: string, flagparent: string, flagselectCommand: script, flagselectFileNode: boolean, flagselectionConnection: string, flagstateString: boolean, flagunParent: boolean, flagunlockMainConnection: boolean, flagupdateMainConnection: boolean, flaguseTemplate: string) -> string:
    """Synopsis:
---
---
 preloadRefEd([control=boolean], [defineTemplate=string], [docTag=string], [exists=boolean], [filter=string], [forceMainConnection=string], [highlightConnection=string], [lockMainConnection=boolean], [mainListConnection=string], [panel=string], [parent=string], [selectCommand=script], [selectFileNode=boolean], [selectionConnection=string], [stateString=boolean], [unParent=boolean], [unlockMainConnection=boolean], [updateMainConnection=boolean], [useTemplate=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

preloadRefEd is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

window = cmds.window()
cmds.paneLayout()
cmds.preloadRefEd()
cmds.showWindow(window)

---
Return:
---


    string: Name of editor

Flags:
---


---
control(ctl): boolean
    properties: query
    Query only. Returns the top level control for this editor.
Usually used for getting a parent to attach popup menus.
Caution: It is possible for an editor to exist without a
control. The query will return "NONE" if no control is present.

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
docTag(dtg): string
    properties: create, query, edit
    Attaches a tag to the editor.

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
filter(f): string
    properties: create, query, edit
    Specifies the name of an itemFilter object to be used with this editor.
This filters the information coming onto the main list
of the editor.

---
forceMainConnection(fmc): string
    properties: create, query, edit
    Specifies the name of a selectionConnection object that the
editor will use as its source of content. The editor will only
display items contained in the selectionConnection object. This is
a variant of the -mainListConnection flag in that it will force a
change even when the connection is locked. This flag is used to
reduce the overhead when using the -unlockMainConnection
, -mainListConnection, -lockMainConnection flags in immediate
succession.

---
highlightConnection(hlc): string
    properties: create, query, edit
    Specifies the name of a selectionConnection object that
the editor will synchronize with its highlight list. Not all
editors have a highlight list. For those that do, it is a secondary
selection list.

---
lockMainConnection(lck): boolean
    properties: create, edit
    Locks the current list of objects within the mainConnection,
so that only those objects are displayed within the editor.
Further changes to the original mainConnection are ignored.

---
mainListConnection(mlc): string
    properties: create, query, edit
    Specifies the name of a selectionConnection object that the
editor will use as its source of content. The editor will
only display items contained in the selectionConnection object.

---
panel(pnl): string
    properties: create, query
    Specifies the panel for this editor. By default if
an editor is created in the create callback of a scripted panel it
will belong to that panel. If an editor does not belong to a panel
it will be deleted when the window that it is in is deleted.

---
parent(p): string
    properties: create, query, edit
    Specifies the parent layout for this editor. This flag will only
have an effect if the editor is currently un-parented.

---
selectCommand(sc): script
    properties: create, query, edit
    A script to be executed when an item is selected.

---
selectFileNode(sf): boolean
    properties: query
    Query the currently selected load setting. Returns the id of the
currently selected load setting. This id can be used as an argument
to the selLoadSettings command.

---
selectionConnection(slc): string
    properties: create, query, edit
    Specifies the name of a selectionConnection object that the
editor will synchronize with its own selection list. As the user
selects things in this editor, they will be selected in the
selectionConnection object. If the object undergoes changes, the
editor updates to show the changes.

---
stateString(sts): boolean
    properties: query
    Query only flag. Returns the MEL command that will create an
editor to match the current editor state. The returned command string
uses the string variable $editorName in place of a specific name.

---
unParent(up): boolean
    properties: create, edit
    Specifies that the editor should be removed from its layout.
This cannot be used in query mode.

---
unlockMainConnection(ulk): boolean
    properties: create, edit
    Unlocks the mainConnection, effectively restoring the original
mainConnection (if it is still available), and dynamic updates.

---
updateMainConnection(upd): boolean
    properties: create, edit
    Causes a locked mainConnection to be updated from the orginal
mainConnection, but preserves the lock state.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/preloadRefEd.html 
    """


def prepareRender(flagdefaultTraversalSet: string, flagderegister: string, flaginvokePostRender: boolean, flaginvokePostRenderFrame: boolean, flaginvokePostRenderLayer: boolean, flaginvokePreRender: boolean, flaginvokePreRenderFrame: boolean, flaginvokePreRenderLayer: boolean, flaginvokeSettingsUI: boolean, flaglabel: string, flaglistTraversalSets: boolean, flagpostRender: script, flagpostRenderFrame: script, flagpostRenderLayer: script, flagpreRender: script, flagpreRenderFrame: script, flagpreRenderLayer: script, flagrestore: boolean, flagsaveAssemblyConfig: boolean, flagsettingsUI: script, flagsetup: boolean, flagtraversalSet: string, flagtraversalSetInit: script) -> None:
    """Synopsis:
---
---
 prepareRender([defaultTraversalSet=string], [deregister=string], [invokePostRender=boolean], [invokePostRenderFrame=boolean], [invokePostRenderLayer=boolean], [invokePreRender=boolean], [invokePreRenderFrame=boolean], [invokePreRenderLayer=boolean], [invokeSettingsUI=boolean], [label=string], [listTraversalSets=boolean], [postRender=script], [postRenderFrame=script], [postRenderLayer=script], [preRender=script], [preRenderFrame=script], [preRenderLayer=script], [restore=boolean], [saveAssemblyConfig=boolean], [settingsUI=script], [setup=boolean], [traversalSet=string], [traversalSetInit=script])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

prepareRender is undoable, queryable, and editable.This command has special support for scene assembly nodes.  To render scene
assembly nodes, a rendering traversal can activate an appropriate
representation, for each assembly node in the scene.  When rendering is
done, this command can correspondingly restore the representation that was
active before rendering on each assembly.
Render traversals are grouped into traversal sets.  A render traversal set
includes callbacks, or render traversals, for one or more of the following
steps of rendering, ordered by decreasing level of granularity.
A render traversal callback is an arbitrary script, either MEL or Python,
that can transform the Maya scene for rendering purposes.

preRender
Traversal run once per render, before any rendering is performed.
postRender
Traversal run once per render, after all rendering has been performed.
preRenderLayer
Traversal run before rendering each render layer.
postRenderLayer
Traversal run after rendering each render layer.
preRenderFrame
Traversal run before rendering each frame.
postRenderFrame
Traversal run after rendering each frame.

During a render view or batch render, Maya will run the render traversals from
the same traversal set, the default traversal set.  Traversal sets are named,
so multiple traversal sets can be registered with this command, and the
default render traversal set can be switched to any one of these registered
traversal sets.  When changing the default traversal set, the different
render traversal callbacks (preRender, preRenderLayer, preRenderFrame,
postRender, postRenderLayer, postRenderFrame) are switched as a unit.
At render time, the software rendering code invokes the callbacks of the
default traversal set.  The prepareRender scripting capability allows for the
development of multiple rendering preparation scripts, including from plugins,
to provide extensibility rather than being constrained to a single
implementation.
A special traversal set is the "null" traversal set.  It is the initial
default traversal set, and cannot be deregistered.  It performs no work,
and does not save and restore the assembly node active representation
configuration.  It will provide WYSIWYG (What You See Is What You Get)
rendering of assembly nodes, without switching to a different representation
to render.
Render traversals are invoked by Maya using this command's create mode.
This is done by Maya's rendering infrastructure, and should not be required
unless developing new render views or batch render code.  Most uses of this
command will simply use the edit mode to register render traversals into a
render traversal set, or the query mode to query the names of the render
traversals in a render traversal set.



Example:
---
import maya.cmds as cmds


Query what the default render traversal set is.
cmds.prepareRender(query=True, defaultTraversalSet=True)

Set the render traversal set to 'MyPrepareRender'.
cmd.prepareRender(edit=True, defaultTraversalSet='MyPrepareRender')

Set the preRender traversal to the adskPrepareRender.preRender function,
for the default render traversal set.
cmd.prepareRender(edit=True, preRender=adskPrepareRender.preRender)

Set the default render traversal set to require saving the assembly node
configuration before render, and restore it once rendering completes.
cmd.prepareRender(edit=True, saveAssemblyConfig=True)

Set the label of traversal set 'MyPrepareRender' to be 'Custom Render'.
cmd.prepareRender(edit=True, label='Custom Render', traversalSet='MyPrepareRender')

---


Flags:
---


---
defaultTraversalSet(dt): string
    properties: query, edit
    Set or query the default traversal set.  The prepareRender
command performs operations on the default traversal set, unless the
-traversalSet flag is used to specify an explicit traversal set.

---
deregister(d): string
    properties: edit
    Deregister a registered traversal set.  If the deregistered traversal set is
the default traversal set, the new default traversal set will be the "null"
traversal set.

---
invokePostRender(ior): boolean
    properties: create
    Invoke the postRender render traversal for a given traversal
set.  The traversal set will be the default traversal set, unless the
-traversalSet flag is used to specify an explicit traversal set.

---
invokePostRenderFrame(iof): boolean
    properties: create
    Invoke the postRenderFrame render traversal for a given traversal
set.  The traversal set will be the default traversal set, unless the
-traversalSet flag is used to specify an explicit traversal set.

---
invokePostRenderLayer(iol): boolean
    properties: create
    Invoke the postRenderLayer render traversal for a given traversal
set.  The traversal set will be the default traversal set, unless the
-traversalSet flag is used to specify an explicit traversal set.

---
invokePreRender(irr): boolean
    properties: create
    Invoke the preRender render traversal for a given traversal
set.  The traversal set will be the default traversal set, unless the
-traversalSet flag is used to specify an explicit traversal set.

---
invokePreRenderFrame(irf): boolean
    properties: create
    Invoke the preRenderFrame render traversal for a given traversal
set.  The traversal set will be the default traversal set, unless the
-traversalSet flag is used to specify an explicit traversal set.

---
invokePreRenderLayer(irl): boolean
    properties: create
    Invoke the preRenderLayer render traversal for a given traversal
set.  The traversal set will be the default traversal set, unless the
-traversalSet flag is used to specify an explicit traversal set.

---
invokeSettingsUI(isu): boolean
    properties: create
    Invoke the settings UI callback to populate a layout with UI controls,
for a given traversal set.  The current UI parent will be a form layout,
which the callback can query using the setParent command.  The traversal set
will be the default traversal set, unless the -traversalSet flag is used to
specify an explicit traversal set.

---
label(lbl): string
    properties: query, edit
    Set or query the label for a given traversal set.  The label is used for UI
display purposes, and can be localized.  The traversal set will be the default,
unless the -traversalSet flag is used to specify an explicit traversal set.

---
listTraversalSets(lt): boolean
    properties: query
    Query the supported render traversal sets.

---
postRender(por): script
    properties: query, edit
    Set or query the postRender render traversal for a given traversal
set.  This traversal is run after a render.  The traversal set will be the
default traversal set, unless the -traversalSet flag is used to specify an
explicit traversal set.

---
postRenderFrame(pof): script
    properties: query, edit
    Set or query the postRenderFrame render traversal for a given traversal
set.  This traversal is run after the render of a single frame, with a
render layer.  The traversal set will be the default traversal set, unless
the -traversalSet flag is used to specify an explicit traversal set.

---
postRenderLayer(pol): script
    properties: query, edit
    Set or query the postRenderLayer render traversal for a given traversal
set.  This traversal is run after a render layer is rendered, within a
render.  The traversal set will be the default traversal set, unless the
-traversalSet flag is used to specify an explicit traversal set.

---
preRender(prr): script
    properties: query, edit
    Set or query the preRender render traversal for a given traversal
set.  This traversal is run before a render.  The traversal set will be the
default traversal set, unless the -traversalSet flag is used to specify an
explicit traversal set.

---
preRenderFrame(prf): script
    properties: query, edit
    Set or query the preRenderFrame render traversal for a given traversal
set.  This traversal is run before the render of a single frame, with a
render layer.  The traversal set will be the default traversal set, unless
the -traversalSet flag is used to specify an explicit traversal set.

---
preRenderLayer(prl): script
    properties: query, edit
    Set or query the preRenderLayer render traversal for a given traversal
set.  This traversal is run before a render layer is rendered, within a
render.  The traversal set will be the default traversal set, unless the
-traversalSet flag is used to specify an explicit traversal set.

---
restore(rtr): boolean
    properties: create
    Clean up after rendering, including restoring the assembly active
representation configuration for the whole scene, if the saveAssemblyConfig
flag for the traversal set is true.  The traversal set will be the default
traversal set, unless the -traversalSet flag is used to specify an explicit
traversal set.

---
saveAssemblyConfig(sac): boolean
    properties: query, edit
    Set or query whether or not the assembly active representation configuration
for the whole scene should be saved for a given traversal set.  The traversal
set will be the default, unless the -traversalSet flag is used to specify an
explicit traversal set.

---
settingsUI(sui): script
    properties: query, edit
    Set or query the settings UI callback for a given traversal set.  The
traversal set will be the default traversal set, unless the -traversalSet
flag is used to specify an explicit traversal set.

---
setup(stp): boolean
    properties: create
    Setup render preparation, including saving the assembly active representation
configuration for the whole scene, if the saveAssemblyConfig flag for
the traversal set is true.  Any previously-saved configuration will be
overwritten.  The traversal set will be the default traversal set, unless the
-traversalSet flag is used to specify an explicit traversal set.

---
traversalSet(ts): string
    properties: create, query, edit
    Set or query properties for the specified registered traversal set.
                        In query mode, this flag needs a value.

---
traversalSetInit(tsi): script
    properties: query, edit
    Set or query the traversal set initialisation callback for a given traversal set.
The traversal set will be the default traversal set, unless the -traversalSet flag
is used to specify an explicit traversal set. This callback is invoked whenever
the specified traversal set becomes the default.
traversal set.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/prepareRender.html 
    """


def profiler(flagaddCategory: string, flagallCategories: boolean, flagbufferSize: int, flagcategoryIndex: int, flagcategoryIndexToName: int, flagcategoryInfo: string, flagcategoryName: string, flagcategoryNameToIndex: string, flagcategoryRecording: boolean, flagclearAllMelInstrumentation: boolean, flagcolorIndex: int, flageventCPUId: boolean, flageventCategory: boolean, flageventColor: boolean, flageventCount: boolean, flageventDescription: boolean, flageventDuration: boolean, flageventIndex: int, flageventName: boolean, flageventStartTime: boolean, flageventThreadId: boolean, flaginstrumentMel: boolean, flagload: string, flagoutput: string, flagprocedureDescription: string, flagprocedureName: string, flagremoveCategory: string, flagreset: boolean, flagsampling: boolean, flagsignalEvent: boolean, flagsignalMelEvent: boolean) -> None:
    """Synopsis:
---
---
 profiler([addCategory=string], [allCategories=boolean], [bufferSize=int], [categoryIndex=int], [categoryIndexToName=int], [categoryInfo=string], [categoryName=string], [categoryNameToIndex=string], [categoryRecording=boolean], [clearAllMelInstrumentation=boolean], [colorIndex=int], [eventCPUId=boolean], [eventCategory=boolean], [eventColor=boolean], [eventCount=boolean], [eventDescription=boolean], [eventDuration=boolean], [eventIndex=int], [eventName=boolean], [eventStartTime=boolean], [eventThreadId=boolean], [instrumentMel=boolean], [load=string], [output=string], [procedureDescription=string], [procedureName=string], [removeCategory=string], [reset=boolean], [sampling=boolean], [signalEvent=boolean], [signalMelEvent=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

profiler is NOT undoable, queryable, and NOT editable.
This command provides the ability to control the collection of profiling data and
to query information about the recorded events. The recorded information can also
be viewed graphically in the Profiler window.

The buffer size cannot be changed while sampling is active, it will return an error
The reset flag cannot be called while sampling is active, it will return an error.
Any changes to the buffer size will only be applied on start of the next recording.
You can't save and load in the same command, save has priority, load would be ignored.




Example:
---
import maya.cmds as cmds

Start profiling
cmds.profiler(sampling = True)

Wait for events to be profiled
Stop profiling
cmds.profiler(sampling = False)

Output the result to a file
cmds.profiler(output = "test.txt")

Load a recording from a file to the buffer
cmds.profiler(load = "test.txt")

Reset the tool
cmds.profiler(reset = True)

Set the profiler's buffer size to fit 5 megaBytes
cmds.profiler(bufferSize = 5)

Query the profiler's buffer size
cmds.profiler(query = True, bufferSize = True)

Add a new category
cmds.profiler(addCategory = "Test Category", categoryInfo="Events related to my special test")

Remove an existing category
cmds.profiler(removeCategory = "Test Category")

Query the number of categories
cmds.profiler(query = True, categoryCount = True)

Query the name of the category at the given index
cmds.profiler(query = True, categoryIndexToName = 5)

Query the info of the category at the given index
cmds.profiler(query = True, categoryIndex = 5, categoryInfo = True)

Query the index of the category with the given name
cmds.profiler(query = True, categoryNameToIndex = "Maya Qt")

Query the info of the category with the given name
cmds.profiler(query = True, categoryName = "Maya Qt", categoryInfo = True)

Query if it is enabled for the recording of the category at the given index
cmds.profiler(query = True, categoryRecording = True, categoryIndex = 5)

Query if it is enabled for the recording of the category with the given name
cmds.profiler(query = True, categoryRecording = True, categoryName = "Maya Qt")

Enable/Disable the recording of the category at the given index
cmds.profiler(categoryRecording = False, categoryIndex = 5)

Query the number of the events in the buffer
cmds.profiler(query = True, eventCount = True)

Query the time at which the event at the given index start
cmds.profiler(query = True, eventStartTime = True, eventIndex = 100)

Query the duration of the event at the given index
cmds.profiler(query = True, eventDuration = True, eventIndex = 100)

Query the name of the event at the given index
cmds.profiler(query = True, eventName = True, eventIndex = 100)

Query the description of the event at the given index
cmds.profiler(query = True, eventDescription = True, eventIndex = 100)

Query the category the the event at the given index belongs to
cmds.profiler(query = True, eventCategory = True, eventIndex = 100)

Query the color of the event at the given index
cmds.profiler(query = True, eventColor = True, eventIndex = 100)

Query the thread ID of the event at the given index
cmds.profiler(query = True, eventThreadId = True, eventIndex = 100)

Query the CPU ID of the event at the given index
cmds.profiler(query = True, eventCPUId = True, eventIndex = 100)

Query if the event at the given index is a signal event
cmds.profiler(query = True, signalEvent = True, eventIndex = 100)

---


Flags:
---


---
addCategory(a): string
    properties: create
    Add a new category for the profiler.
Returns the index of the new category.

---
allCategories(ac): boolean
    properties: query
    Query the names of all categories.
If the categoryInfo flag is set then alternate the name of the category
with the description of the category.

---
bufferSize(b): int
    properties: create, query
    Toggled : change the buffer size to fit the specified number of events (requires that sampling is off)
Query : return the current buffer size
The new buffer size will only take effect when next sampling starts.
When the buffer is full, the recording stops.

---
categoryIndex(ci): int
    properties: create, query
    Used in conjunction with other flags, to indicate the index of the category.
                        In query mode, this flag needs a value.

---
categoryIndexToName(cin): int
    properties: create, query
    Returns the name of the category with a given index.
                        In query mode, this flag needs a value.

---
categoryInfo(cf): string
    properties: create, query
    When used with the addCategory flag set the description of the added profiler category.
In query mode return the description of the category referenced by either
the categoryIndex or categoryName flags.
                        In query mode, this flag can accept a value.

---
categoryName(cn): string
    properties: query
    Used in conjunction with other flags, to indicate the name of the category.
                        In query mode, this flag needs a value.

---
categoryNameToIndex(cni): string
    properties: create, query
    Returns the index of the category with a given name.
                        In query mode, this flag needs a value.

---
categoryRecording(cr): boolean
    properties: create, query
    Toggled : Enable/disable the recording of the category.
Query : return if the recording of the category is On.
Requires the -categoryIndex or -categoryName flag to specify the category to be queried.

---
clearAllMelInstrumentation(cam): boolean
    properties: create
    Clear all MEL command or procedure instrumentation.

---
colorIndex(coi): int
    properties: create
    Used with "-instrumentMel true" to specify the color index to show the
profiling result.

---
eventCPUId(eci): boolean
    properties: query
    Query the CPU ID of the event at the given index.
Requires the -eventIndex flag to specify the event to be queried.

---
eventCategory(eca): boolean
    properties: query
    Query the category index the event at the given index belongs to.
Requires the -eventIndex flag to specify the event to be queried.

---
eventColor(eco): boolean
    properties: query
    Query the color of the event at the given index.
Requires the -eventIndex flag to specify the event to be queried.

---
eventCount(ec): boolean
    properties: query
    Query the number of events in the buffer

---
eventDescription(ed): boolean
    properties: query
    Query the description of the event at the given index.
Requires the -eventIndex flag to specify the event to be queried.

---
eventDuration(edu): boolean
    properties: query
    Query the duration of the event at the given index, the time unit is microsecond.
Note that a signal event has a 0 duration.
Requires the -eventIndex flag to specify the event to be queried.

---
eventIndex(ei): int
    properties: query
    Used usually in conjunction with other flags, to indicate the index of the event.
                        In query mode, this flag needs a value.

---
eventName(en): boolean
    properties: query
    Query the name of the event at the given index.
Requires the -eventIndex flag to specify the event to be queried.

---
eventStartTime(et): boolean
    properties: query
    Query the time of the event at the given index, the time unit is microsecond.
Requires the -eventIndex flag to specify the event to be queried.

---
eventThreadId(eti): boolean
    properties: query
    Query the thread ID of the event at the given index.
Requires the -eventIndex flag to specify the event to be queried.

---
instrumentMel(instrumentMel): boolean
    properties: create
    Enable/Diable the instrumentation of a MEL command or procedure.
When the instrumentation is enabled, the execution of MEL command
or procedure can be profiled and shown in the Profiler window.
To enable the instrumentation requires the -procedureName, -colorIndex
and -categoryIndex flags.
To disable the instrumentation requires the -procedureName flag.

---
load(l): string
    properties: create, query
    Read the recorded events from the specified file

---
output(o): string
    properties: create, query
    Output the recorded events to the specified file

---
procedureDescription(pd): string
    properties: create
    Used with "-instrumentMel true" to provide a description of the MEL
command or procedure being instrumented.
This description can be viewed in the Profiler Tool window.

---
procedureName(pn): string
    properties: create
    Used with -instrumentMel to specify the name of the procedure to be
enabled/disabled the instrumentation.

---
removeCategory(rc): string
    properties: create
    Remove an existing category for the profiler.
Returns the index of the removed category.

---
reset(r): boolean
    properties: create, query
    reset the profiler's data (requires that sampling is off)

---
sampling(s): boolean
    properties: create, query
    Toggled : Enable/disable the recording of events
Query : return if the recording of events is On.

---
signalEvent(sig): boolean
    properties: query
    Query if the event at the given index is a signal event.
Requires the -eventIndex flag to specify the event to be queried.
A Signal Event only remembers the start moment and has no knowledge about
duration. It can be used in cases when the user does not care about the
duration but only cares if this event does happen.

---
signalMelEvent(sim): boolean
    properties: create
    Used with "-instrumentMel true", inform profiler that this instrumented
MEL command or procedure will be taken as a signal event during profiling.
A Signal Event only remembers the start moment and has no knowledge about
duration. It can be used in cases when the user does not care about the
duration but only cares if this event does happen.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/profiler.html 
    """


def profilerTool(flagcategoryView: boolean, flagcollapseSelectedEvents: boolean, flagcollapseSelectedEventsRepetition: boolean, flagcpuView: boolean, flagdestroy: boolean, flageventTypes: boolean, flagexists: boolean, flagexpandSelectedEvents: boolean, flagexpandSelectedEventsRepetition: boolean, flagfindNext: boolean, flagfindPrevious: boolean, flagframeAll: boolean, flagframeSelected: boolean, flagisolateSegment: int, flagmake: boolean, flagmatchWholeWord: boolean, flagsearchEvent: string, flagsegmentCount: boolean, flagshowAllEvent: boolean, flagshowCriticalPath: boolean, flagshowHotspot: boolean, flagshowSelectedEvents: boolean, flagshowSelectedEventsRepetition: boolean, flagthreadView: boolean, flagunisolateSegment: boolean) -> None:
    """Synopsis:
---
---
 profilerTool([categoryView=boolean], [collapseSelectedEvents=boolean], [collapseSelectedEventsRepetition=boolean], [cpuView=boolean], [destroy=boolean], [eventTypes=boolean], [exists=boolean], [expandSelectedEvents=boolean], [expandSelectedEventsRepetition=boolean], [findNext=boolean], [findPrevious=boolean], [frameAll=boolean], [frameSelected=boolean], [isolateSegment=int], [make=boolean], [matchWholeWord=boolean], [searchEvent=string], [segmentCount=boolean], [showAllEvent=boolean], [showCriticalPath=boolean], [showHotspot=boolean], [showSelectedEvents=boolean], [showSelectedEventsRepetition=boolean], [threadView=boolean], [unisolateSegment=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

profilerTool is NOT undoable, queryable, and editable.
This script is intended to be used by the profilerPanel to interact with the profiler tool's view (draw region).
It can be used to control some behaviors about the profiler Tool.




Example:
---
import maya.cmds as cmds


---
First record/load a profile
---
Frame the tool's view on all recorded events.
cmds.profilerTool( edit = True, frameAll = True )

---
Frame selected events
cmds.profilerTool( edit = True, frameSelected = True )

---
Change to cpu view
cmds.profilerTool( edit = True, cpuView = True )

---
Show only selected events
cmds.profilerTool( edit = True, showSelectedEvents = True )

---
Show all events
cmds.profilerTool( edit = True, showAllEvent = True )

---
Hide all events that have same comment as selected events
cmds.profilerTool( edit = True, showSelectedEventsRepetition = False )

---
Show hotspot
cmds.profilerTool( edit = True, showHotspot = True )

---
Find all events whose name contains "abc"
cmds.profilerTool( query = True, searchEvent = "abc" )

---
Find the first event, whose name exactly matches with "def", next to current selected event
cmds.profilerTool( edit = True, matchWholeWord = True )
cmds.profilerTool( query = True, searchEvent = "def", findNext = True )

---
Query the active event types
cmds.profilerTool( query = True, eventTypes = True )

---
Query segment count in buffer
cmds.profilerTool( query = True, segmentCount = True )

---
Isolate the first segment
cmds.profilerTool( edit = True, isolateSegment = 0 )

---
Unisolate segment
cmds.profilerTool( edit = True, unisolateSegment = True )

---


Flags:
---


---
categoryView(cat): boolean
    properties: edit
    Change view mode to category view

---
collapseSelectedEvents(cs): boolean
    properties: edit
    Hide all sub-events of selected events so that only top-level events show

---
collapseSelectedEventsRepetition(csr): boolean
    properties: edit
    Hide all sub-events repetition of selected events based on their comment

---
cpuView(cpu): boolean
    properties: edit
    Change view mode to cpu view

---
destroy(dtr): boolean
    properties: create
    Destroy the profiler tool
Internal flag. Should not be used by user.

---
eventTypes(et): boolean
    properties: query
    Return JSON data containing the list of event types on currently existing events.
If the value of the flag is true then show only event types for selected events,
otherwise show them for all events.  The JSON return string will contain the event
type information in the following format:

{
    "eventSummary" : [
        { "type"        : EVENT_TYPE_NAME,
        , "description" : EVENT_TYPE_DESCRIPTION,
        , "color"       : [ RED_AS_FLOAT, GREEN_AS_FLOAT, BLUE_AS_FLOAT ]
        , "category"    : CATEGORY_NAME
        , "count"       : EVENT_TYPE_COUNT
        }
    ]
}

"type" and "description" may be omitted, indicating that the results
correspond to anonymous events.

---
exists(ex): boolean
    properties: query
    Query if the profiler tool view exists.
Profiler tool can only exist after "profilerTool -make" is called.

---
expandSelectedEvents(es): boolean
    properties: edit
    Show all sub-events of selected events

---
expandSelectedEventsRepetition(esr): boolean
    properties: edit
    Show all sub-events repetition of selected events based on their comment

---
findNext(fn): boolean
    properties: query
    This flag is used along with flag -searchEvent.

---
findPrevious(fp): boolean
    properties: query
    This flag is used along with flag -searchEvent.

---
frameAll(fa): boolean
    properties: edit
    Frame on all events in the profilerToolView

---
frameSelected(fs): boolean
    properties: edit
    Frame on all selected events in the profilerToolView

---
isolateSegment(isolateSegment): int
    properties: edit
    Isolate a specified segment.
A segment is a set of events that happened in one animation frame.
You can use flag -segmentCount to query the number of segments in the event buffer.
The segment index starts from 0.
If the specified segment does not exist, an error will be thrown.

---
make(mk): boolean
    properties: create
    Make the profiler tool and parent it to the most recent layout created
Internal flag. Should not be used by user.

---
matchWholeWord(mww): boolean
    properties: edit
    Tells profiler tool if it should match whole word when searching event(s).
The default value is false.

---
searchEvent(se): string
    properties: query
    Search event(s).
You can set -matchWholeWord before you use -searchEvent.
If -matchWholeWord has been set to true, the profiler tool will search event(s) whose name exactly matches with the string.
If -matchWholeWord has been set to false, the profiler tool will search event(s) whose name contains the string.
If -findNext is also used along with this flag, the profiler tool will find the first event next to the current selected event.
If -findPrevious is also used along with this flag, the profiler tool will find the first event previous to the current selected event.
If currently don't have a selected event or there are multiple selected events, the search will start at
the first event in profiler buffer.
If -findNext and -findPrevious are not used along with this flag, the profiler tool will find all events.
                        In query mode, this flag needs a value.

---
segmentCount(sc): boolean
    properties: query
    Returns the number of segments in the event buffer.

---
showAllEvent(sa): boolean
    properties: edit
    Show all events (if events were hidden by filtering) (true) or
Hide all events (false)

---
showCriticalPath(scp): boolean
    properties: edit
    Show critical path of selected frame

---
showHotspot(sh): boolean
    properties: edit
    Show hotspot of selected frame

---
showSelectedEvents(ss): boolean
    properties: edit
    Show only the selected events (true) or
hide all selected events (false)

---
showSelectedEventsRepetition(ssr): boolean
    properties: edit
    Show only the selected events repetition based on their comment (true) or
Hide all selected events repetition based on their comment (false)

---
threadView(thd): boolean
    properties: edit
    Change view mode to thread view

---
unisolateSegment(uis): boolean
    properties: edit
    Unisolate current isolated segment.
If no segment is currently isolated, nothing will happen.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/profilerTool.html 
    """


def progressBar(flagannotation: string, flagbackgroundColor: tuple[float, float, float], flagbeginProgress: boolean, flagdefineTemplate: string, flagdocTag: string, flagdragCallback: script, flagdropCallback: script, flagenable: boolean, flagenableBackground: boolean, flagenableKeyboardFocus: boolean, flagendProgress: boolean, flagexists: boolean, flagfullPathName: boolean, flagheight: int, flaghighlightColor: tuple[float, float, float], flagisCancelled: boolean, flagisInterruptable: boolean, flagisMainProgressBar: boolean, flagisObscured: boolean, flagmanage: boolean, flagmaxValue: int, flagminValue: int, flagnoBackground: boolean, flagnumberOfPopupMenus: boolean, flagparent: string, flagpopupMenuArray: boolean, flagpreventOverride: boolean, flagprogress: int, flagstatus: string, flagstatusBarMessage: string, flagstep: int, flaguseTemplate: string, flagvisible: boolean, flagvisibleChangeCommand: script, flagwidth: int) -> string:
    """Synopsis:
---
---
 progressBar(
[string]
    , [annotation=string], [backgroundColor=[float, float, float]], [beginProgress=boolean], [defineTemplate=string], [docTag=string], [dragCallback=script], [dropCallback=script], [enable=boolean], [enableBackground=boolean], [enableKeyboardFocus=boolean], [endProgress=boolean], [exists=boolean], [fullPathName=boolean], [height=int], [highlightColor=[float, float, float]], [isCancelled=boolean], [isInterruptable=boolean], [isMainProgressBar=boolean], [isObscured=boolean], [manage=boolean], [maxValue=int], [minValue=int], [noBackground=boolean], [numberOfPopupMenus=boolean], [parent=string], [popupMenuArray=boolean], [preventOverride=boolean], [progress=int], [status=string], [statusBarMessage=string], [step=int], [useTemplate=string], [visible=boolean], [visibleChangeCommand=script], [width=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

progressBar is undoable, queryable, and editable.




Example:
---
import maya.cmds as cmds

Create a custom progressBar in a windows ...

window = cmds.window()
cmds.columnLayout()

progressControl = cmds.progressBar(maxValue=10, width=300)
cmds.button( label='Make Progress!', command='cmds.progressBar(progressControl, edit=True, step=1)' )

cmds.showWindow( window )

Or, to use the progress bar in the main window ...

import maya.mel
gMainProgressBar = maya.mel.eval('$tmp = $gMainProgressBar')

cmds.progressBar( gMainProgressBar,
                                edit=True,
                                beginProgress=True,
                                isInterruptable=True,
                                status='Example Calculation ...',
                                maxValue=5000 )

for i in range(5000) :
        if cmds.progressBar(gMainProgressBar, query=True, isCancelled=True ) :
                break

        cmds.progressBar(gMainProgressBar, edit=True, step=1)

cmds.progressBar(gMainProgressBar, edit=True, endProgress=True)

---
Return:
---


    string: Full path name to the control.

Flags:
---


---
annotation(ann): string
    properties: create, query, edit
    Annotate the control with an extra string value.

---
backgroundColor(bgc): [float, float, float]
    properties: create, query, edit
    The background color of the control. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0.
When setting backgroundColor, the background is automatically
enabled, unless enableBackground is also specified with a false
value.

---
beginProgress(bp): boolean
    properties: create, edit
    Only valid for the main progress bar
Shows the main progress bar (normally in the Help Line).
This is normally issued through MEL when a length computation is
about to occur.

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
docTag(dtg): string
    properties: create, query, edit
    Add a documentation flag to the control.  The documentation flag
has a directory structure.
(e.g., -dt render/multiLister/createNode/material)

---
dragCallback(dgc): script
    properties: create, edit
    Adds a callback that is called when the middle mouse button
is pressed.  The MEL version of the callback is of the form:

global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods)

The proc returns a string array that is transferred to the drop site.
By convention the first string in the array describes the user settable
message type.  Controls that are application defined drag sources may
ignore the callback. $mods allows testing for the key modifiers CTRL and
SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTRL,
3 == CTRL + SHIFT.

In Python, it is similar, but there are two ways to specify the callback.  The
recommended way is to pass a Python function object as the argument.  In that
case, the Python callback should have the form:

def callbackName( dragControl, x, y, modifiers ):

The values of these arguments are the same as those for the MEL version above.

The other way to specify the callback in Python is to specify a string to be
executed.  In that case, the string will have the values substituted into it
via the standard Python format operator.  The format values are passed in a
dictionary with the keys "dragControl", "x", "y", "modifiers".  The
"dragControl" value is a string and the other values are integers (eg the
callback string could be "print '%(dragControl)s %(x)d %(y)d %(modifiers)d'")

---
dropCallback(dpc): script
    properties: create, edit
    Adds a callback that is called when a drag and drop
operation is released above the drop site.  The MEL version of the callback is
of the form:

global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type)

The proc receives a string array that is transferred from the drag source.
The first string in the msgs array describes the user defined message type.
Controls that are application defined drop sites may ignore the
callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link.

In Python, it is similar, but there are two ways to specify the callback.  The
recommended way is to pass a Python function object as the argument.  In that
case, the Python callback should have the form:

def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ):

The values of these arguments are the same as those for the MEL version above.

The other way to specify the callback in Python is to specify a string to be
executed.  In that case, the string will have the values substituted into it
via the standard Python format operator.  The format values are passed in a
dictionary with the keys "dragControl", "dropControl", "messages", "x", "y",
"type".  The "dragControl" value is a string and the other values are integers
(eg the callback string could be
"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'")

---
enable(en): boolean
    properties: create, query, edit
    The enable state of the control.  By default, this flag is
set to true and the control is enabled.  Specify false and the control
will appear dimmed or greyed-out indicating it is disabled.

---
enableBackground(ebg): boolean
    properties: create, query, edit
    Enables the background color of the control.

---
enableKeyboardFocus(ekf): boolean
    properties: create, query, edit
    If enabled, the user can navigate to the control with the tab key and select values with the keyboard or mouse.
This flag would typically be used to turn off focus support from controls that get it by default, like Edit and List controls.
If disabled, text in text fields can still be selected with the mouse but cannot be copied (except on Linux when "Middle Click Paste" is enabled).

---
endProgress(ep): boolean
    properties: edit
    Only valid for the main progress bar
Hides the progress bar. No other flags can be used at the
same time. This is normally issued through
MEL in response to the -ic/isCancelled flag being set or if the progress
value reaches its maximum.

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
fullPathName(fpn): boolean
    properties: query
    Return the full path name of the widget, which includes all the parents.

---
height(h): int
    properties: create, query, edit
    The height of the control.  The control will attempt to
be this size if it is not overruled by parent layout conditions.

---
highlightColor(hlc): [float, float, float]
    properties: create, query, edit
    The highlight color of the control. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0.

---
isCancelled(ic): boolean
    properties: query
    Returns true if the user has tried to cancel the operation.
Returns false otherwise.

---
isInterruptable(ii): boolean
    properties: create, query, edit
    Only valid for the main progress bar
 Returns true if the isCancelled flag should respond to attempts
to cancel the operation. Setting this to true will add a note in the help
line display message to the user indicating that they can cancel the
operation.

---
isMainProgressBar(imp): boolean
    properties: create, query, edit
    Determines whether this progressBar is used to show the progress
of all basic operations such as Open/Save file.
The main progressBar behaves very differently, in that it only shows itself
when there is an ongoing basic operation.
Defaults to false, and only one progress bar will be recognized as the "main" one.

---
isObscured(io): boolean
    properties: query
    Return whether the control can actually be seen by the user.
The control will be obscured if its state is invisible, if it is
blocked (entirely or partially) by some other control, if it or a
parent layout is unmanaged, or if the control's window is
invisible or iconified.

---
manage(m): boolean
    properties: create, query, edit
    Manage state of the control.  An unmanaged control is
not visible, nor does it take up any screen real estate.  All
controls are created managed by default.

---
maxValue(max): int
    properties: create, query, edit
    The maximum or "ending" value of the progress indicator.
If the progress value is greater than the -max/maxValue, the
progress value will be set to the maximum.
Default value is 100.

---
minValue(min): int
    properties: create, query, edit
    The minimum or "starting" value of the progress indicator.
If the progress value is less than the -min/minValue, the
progress value will be set to the minimum.
Default value is 0.

---
noBackground(nbg): boolean
    properties: create, edit
    Clear/reset the control's background.
Passing true means the background should not be drawn at all, false means the background should be drawn.  The state of this flag is inherited by children of this control.

---
numberOfPopupMenus(npm): boolean
    properties: query
    Return the number of popup menus attached to this control.

---
parent(p): string
    properties: create, query
    The parent layout for this control.

---
popupMenuArray(pma): boolean
    properties: query
    Return the names of all the popup menus attached to this
control.

---
preventOverride(po): boolean
    properties: create, query, edit
    If true, this flag prevents overriding the control's
attribute via the control's right mouse button menu.

---
progress(pr): int
    properties: create, query, edit
    The amount of progress currently shown on the control.
The value will always be between min and max.
Default is equal to the minimum when the control is created.

---
status(st): string
    properties: create, query, edit
    Only valid for the main progress bar
Sets the contents of the helpLine control when the
progressBar is showing. Use this instead of setting the helpLine
directly because this will force a graphical refresh before returning.

---
statusBarMessage(sbm): string
    properties: create, edit
    Extra string to display in the status bar when the mouse is over the control.

---
step(s): int
    properties: edit
    Increments the -pr/progress value by the amount specified.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

---
visible(vis): boolean
    properties: create, query, edit
    The visible state of the control.  A control is created
visible by default.  Note that a control's actual appearance is
also dependent on the visible state of its parent layout(s).

---
visibleChangeCommand(vcc): script
    properties: create, query, edit
    Command that gets executed when visible state of the control changes.

---
width(w): int
    properties: create, query, edit
    The width of the control.  The control will attempt to
be this size if it is not overruled by parent layout conditions.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/progressBar.html 
    """


def progressWindow(flagendProgress: boolean, flagisCancelled: boolean, flagisInterruptable: boolean, flagmaxValue: int, flagminValue: int, flagprogress: int, flagstatus: string, flagstep: int, flagtitle: string) -> boolean:
    """Synopsis:
---
---
 progressWindow([endProgress=boolean], [isCancelled=boolean], [isInterruptable=boolean], [maxValue=int], [minValue=int], [progress=int], [status=string], [step=int], [title=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

progressWindow is undoable, queryable, and editable.Only one progress window is allowed on screen at a time. While the window
is visible, the busy cursor is shown.




Example:
---
import maya.cmds as cmds

+-+------------------+
|-|  Doing Nothing   |
+--------------------+
| Sleeping: 40%      |
|                    |
| +----------------+ |
| |||||||          | |
| +----------------+ |
|                    |
| Hit ESC to Cancel  |
+--------------------+

Always use the progress dialog from a script, never directly
from the Script Editor.

amount = 0

cmds.progressWindow(	title='Doing Nothing',
                                        progress=amount,
                                        status='Sleeping: 0%',
                                        isInterruptable=True )
while True :
        Check if the dialog has been cancelled
        if cmds.progressWindow( query=True, isCancelled=True ) :
                break

        Check if end condition has been reached
        if cmds.progressWindow( query=True, progress=True ) >= 100 :
                break

        amount += 5

        cmds.progressWindow( edit=True, progress=amount, status=('Sleeping: ' + `amount` + '%' ) )

        cmds.pause( seconds=1 )

cmds.progressWindow(endProgress=1)

---
Return:
---


    boolean: Returns true if the window was successfully
created, and false if the window could not be created (possibly
because one is already showing).

Flags:
---


---
endProgress(ep): boolean
    properties: create
    Terminates the progress window. No other flags can be used
at the same time. This is normally issued through
MEL in response to the -ic/isCancelled flag being set or if the progress
value reaches its maximum.

---
isCancelled(ic): boolean
    properties: query
    Returns true if the user has tried to cancel the operation.
Returns false otherwise.

---
isInterruptable(ii): boolean
    properties: create, query, edit
    Returns true if the progress window should respond to attempts
to cancel the operation. The cancel button is disabled if this is set
to true.

---
maxValue(max): int
    properties: create, query, edit
    The maximum or "ending" value of the progress indicator.
If the progress value is greater than the -max/maxValue, the
progress value will be set to the maximum.
Default value is 100.

---
minValue(min): int
    properties: create, query, edit
    The minimum or "starting" value of the progress indicator.
If the progress value is less than the -min/minValue, the
progress value will be set to the minimum.
Default value is 0.

---
progress(pr): int
    properties: create, query, edit
    The amount of progress currently shown on the control.
The value will always be between min and max.
Default is equal to the minimum when the control is created.

---
status(st): string
    properties: create, query, edit
    The status text appearing above the progress gauge.

---
step(s): int
    properties: edit
    Increments the -pr/progress value by the amount specified.

---
title(t): string
    properties: create, query, edit
    The window title.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/progressWindow.html 
    """


def projectCurve(flagcaching: boolean, flagconstructionHistory: boolean, flagdirection: tuple[linear, linear, linear], flagdirectionX: linear, flagdirectionY: linear, flagdirectionZ: linear, flagname: string, flagnodeState: int, flagobject: boolean, flagrange: boolean, flagtolerance: linear, flaguseNormal: boolean) -> list[string]:
    """Synopsis:
---
---
 projectCurve(
[curve] [surface]
    , [caching=boolean], [constructionHistory=boolean], [direction=[linear, linear, linear]], [directionX=linear], [directionY=linear], [directionZ=linear], [name=string], [nodeState=int], [object=boolean], [range=boolean], [tolerance=linear], [useNormal=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

projectCurve is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Project the active curve onto the active surface using the surface
normals:
cmds.projectCurve( un=True )

Project this curve onto the nurbs sphere using the specified direction:
cmds.projectCurve( 'curve1', 'nurbsSphere1', d=(0.0, 6.0, 0.0) )

---
Return:
---


    list[string]: Object name and node name

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
direction(d): [linear, linear, linear]
    properties: create, query, edit
    Direction of projection. Available only if useNormal is false.

---
directionX(dx): linear
    properties: create, query, edit
    X direction of projection.
Default: 0.0

---
directionY(dy): linear
    properties: create, query, edit
    Y direction of projection.
Default: 0.0

---
directionZ(dz): linear
    properties: create, query, edit
    Z direction of projection.
Default: 1.0

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
tolerance(tol): linear
    properties: create, query, edit
    Tolerance to fit to.
Default: 0.01

---
useNormal(un): boolean
    properties: create, query, edit
    True if the surface normal is to be used and false if the direction vector should be used instead.
Default: false

---
constructionHistory(ch): boolean
    properties: create
    Turn the construction history on or off.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node.

---
range(rn): boolean
    properties: create
    Force a curve range on complete input curve.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/projectCurve.html 
    """


def projectTangent(flagcaching: boolean, flagconstructionHistory: boolean, flagcurvature: boolean, flagcurvatureScale: linear, flagignoreEdges: boolean, flagname: string, flagnodeState: int, flagobject: boolean, flagreplaceOriginal: boolean, flagreverseTangent: boolean, flagrotate: angle, flagtangentDirection: int, flagtangentScale: linear) -> list[string]:
    """Synopsis:
---
---
 projectTangent(
[curve] [[curve] [curve] | [surface]]
    , [caching=boolean], [constructionHistory=boolean], [curvature=boolean], [curvatureScale=linear], [ignoreEdges=boolean], [name=string], [nodeState=int], [object=boolean], [replaceOriginal=boolean], [reverseTangent=boolean], [rotate=angle], [tangentDirection=int], [tangentScale=linear])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

projectTangent is undoable, queryable, and editable.
Tangent continuity means the end of the curve is modified to be tangent
at the point it meets the other objects.

Curvature continuity means the end of the curve is modified to be
curvature continuous as well as tangent.

If the normal tangent direction is used, the curvature continuity
and rotation do not apply. Also, curvature continuity is only available
if align to a surface (not with 2 curves).




Example:
---
import maya.cmds as cmds

Do project tangent with curvature continuity between a curve and a
nurbs plane surface
cmds.projectTangent( 'curve1', 'nurbsPlane1', c=True )

Do project tangent between the 3 curves and tangent align the curve
with the reverse tangent of the second of the other 2 curves
(i.e. with curve3)
cmds.projectTangent( 'curve1', 'curve2', 'curve3', td=2, rt=True )

---
Return:
---


    list[string]: Object name and node name

Flags:
---


---
caching(cch): boolean
    properties: create, query, edit
    Toggle caching for all attributes so that no recomputation is needed

---
curvature(c): boolean
    properties: create, query, edit
    Curvature continuity is on if true and off otherwise.
Default: false

---
curvatureScale(cs): linear
    properties: create, query, edit
    Curvature scale applied to curvature of curve to align. Available if curvature option is true.
Default: 0.0

---
ignoreEdges(ie): boolean
    properties: create, query, edit
    If false, use the tangents of the trim edge curves if the surface is trimmed. If true, use the tangents of the underlying surface in the U/V directions.
Default: false

---
nodeState(nds): int
    properties: create, query, edit
    Maya dependency nodes have 6 possible states.
The Normal (0), HasNoEffect (1), and Blocking (2) states can be
used to alter how the graph is evaluated.



The Waiting-Normal (3), Waiting-HasNoEffect (4), Waiting-Blocking (5)
are for internal use only. They temporarily shut off parts of the graph during interaction
(e.g., manipulation). The understanding is that once the operation is done,
the state will be reset appropriately, e.g. Waiting-Blocking will reset
back to Blocking.



The Normal and Blocking cases apply to all nodes, while
HasNoEffect is node specific; many nodes do not support this option.
Plug-ins store state in the MPxNode::state attribute. Anyone can set
it or check this attribute.  Additional details about each of these 3 states follow.




State
Description


Normal
The normal node state. This is the default.


HasNoEffect


The HasNoEffect option (a.k.a. pass-through), is used in cases where
there is an operation on an input producing an output of the same data type.
Nearly all deformers support this state, as do a few other nodes.
As stated earlier, it is not supported by all nodes.


It’s typical to implement support for the HasNoEffect state in
the node’s compute method and to perform appropriate operations.
Plug-ins can also support HasNoEffect.


The usual implementation of this state is to copy the input directly to the
matching output without applying the algorithm in the node. For deformers,
applying this state leaves the input geometry undeformed on the output.




Blocking


This is implemented in the depend node base class and applies to all nodes.
Blocking is applied during the evaluation phase to connections.
An evaluation request to a blocked connection will return as failures,
causing the destination plug to retain its current value. Dirty propagation
is indirectly affected by this state since blocked connections are never cleaned.


When a node is set to Blocking the behavior is supposed to be the same as
if all outgoing connections were broken. As long as nobody requests evaluation
of the blocked node directly it won’t evaluate after that. Note that a blocked
node will still respond to getAttr requests but a getAttr on a
downstream node will not reevaluate the blocked node.


Setting the root transform of a hierarchy to Blocking won’t automatically
influence child transforms in the hierarchy. To do this, you’d need to
explicitly set all child nodes to the Blocking state.


For example, to set all child transforms to Blocking, you could use the
following script.



import maya.cmds as cmds
def blockTree(root):
nodesToBlock = []
for node in {child:1 for child in cmds.listRelatives( root, path=True, allDescendents=True )}.keys():
nodesToBlock += cmds.listConnections(node, source=True, destination=True )
for node in {source:1 for source in nodesToBlock}.keys():
cmds.setAttr( '%s.nodeState' % node, 2 )



Applying this script would continue to draw objects but things would not be animated.




Default: kdnNormal

---
reverseTangent(rt): boolean
    properties: create, query, edit
    Reverse the tangent direction if true and leave it the way it is if false.
Default: false

---
rotate(ro): angle
    properties: create, query, edit
    Amount by which the tangent of the curve to align will be rotated. Available only if the normal direction (3) is not used for tangentDirection.
Default: 0.0

---
tangentDirection(td): int
    properties: create, query, edit
    Tangent align direction type legal values: 1=u direction (of surface or use first curve), 2=v direction (of surface or use second curve), 3=normal direction (at point of intersection).
Default: 1

---
tangentScale(ts): linear
    properties: create, query, edit
    Tangent scale applied to tangent of curve to align.
Default: 1.0

---
constructionHistory(ch): boolean
    properties: create
    Turn the construction history on or off.

---
name(n): string
    properties: create
    Sets the name of the newly-created node. If it contains
namespace path, the new node will be created under the
specified namespace; if the namespace does not exist, it
will be created.

---
object(o): boolean
    properties: create
    Create the result, or just the dependency node.

---
replaceOriginal(rpo): boolean
    properties: create
    Create "in place" (i.e., replace).

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/projectTangent.html 
    """


def projectionContext(flagexists: boolean, flaghistory: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flagname: string) -> string:
    """Synopsis:
---
---
 projectionContext([exists=boolean], [history=boolean], [image1=string], [image2=string], [image3=string], [name=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

projectionContext is undoable, queryable, and editable.


Return:
---


    string: Context name.

Flags:
---


---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
history(ch): boolean
    properties: create
    If this is a tool command, turn the construction history on
for the tool in question.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
name(n): string
    properties: create
    If this is a tool command, name the tool appropriately.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/projectionContext.html 
    """


def projectionManip(flagfitBBox: boolean, flagprojType: int, flagswitchType: boolean) -> None:
    """Synopsis:
---
---
 projectionManip([fitBBox=boolean], [projType=int], [switchType=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

projectionManip is undoable, queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

cmds.projectionManip( fb=True )
cmds.projectionManip( pt=3 )

---


Flags:
---


---
fitBBox(fb): boolean
    properties: create
    Fit the projection manipulator size and position to the shading
group bounding box. The orientation is not modified.

---
projType(pt): int
    properties: create
    Set the projection type to the given value. Projection type values are:

 1 = planar.
 2 = spherical.
 3 = cylindrical.
 4 = ball.
 5 = cubic.
 6 = triplanar.
 7 = concentric.
 8 = camera.

---
switchType(st): boolean
    properties: create
    Loop over the allowed types. If the hardware shading is on, it loops
over the hardware shadeable types (planar, cylindrical, spherical),
otherwise, it loops over all the types.
If there is no given value, it loops over the different projection
types.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/projectionManip.html 
    """


def promptDialog(flagbackgroundColor: tuple[float, float, float], flagbutton: string, flagcancelButton: string, flagdefaultButton: string, flagdismissString: string, flagmessage: string, flagmessageAlign: string, flagparent: string, flagscrollableField: boolean, flagstyle: string, flagtext: string, flagtitle: string) -> string:
    """Synopsis:
---
---
 promptDialog([backgroundColor=[float, float, float]], [button=string], [cancelButton=string], [defaultButton=string], [dismissString=string], [message=string], [messageAlign=string], [parent=string], [scrollableField=boolean], [style=string], [text=string], [title=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

promptDialog is undoable, queryable, and NOT editable.-ds/dismissString
The default behaviour when no arguments are specified is to create an
empty single button dialog.

To obtain the text entered by the user simply query
the -tx/text flag.




Example:
---
import maya.cmds as cmds

Create an OK/Cancel prompt dialog.
---

+-+---------------------+
|-|    Rename Object    |
+-----------------------+
| Enter Name:           |
| +-------------------+ |
| |                   | |
| |                   | |
| +-------------------+ |
+-----------------------+
| +-------+  +--------+ |
| |  OK   |  | Cancel | |
| +-------+  +--------+ |
+-----------------------+
---


result = cmds.promptDialog(
                title='Rename Object',
                message='Enter Name:',
                button=['OK', 'Cancel'],
                defaultButton='OK',
                cancelButton='Cancel',
                dismissString='Cancel')

if result == 'OK':
        text = cmds.promptDialog(query=True, text=True)

---
Return:
---


    string: Indicates how the dialog was dismissed. If a button is
pressed then the label of the button is returned. If the dialog is
closed then the value for the flagds/dismissStringis
returned.

Flags:
---


---
backgroundColor(bgc): [float, float, float]
    properties: create
    The background color of the dialog. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0. (Windows only flag)

---
button(b): string
    properties: create, multiuse
    Create a button with the given string as it's text.

---
cancelButton(cb): string
    properties: create
    The cancel button is activated by pressing the escape key.
Note that this flag does not create a button, it simply indicates
which button created via the -b/button flag shall respond
to the escape key.

---
defaultButton(db): string
    properties: create
    The default button is activated by pressing the enter key.
Note that this flag does not create a button, it simply indicates
which button created via the -b/button flag shall respond
to the enter key.

---
dismissString(ds): string
    properties: create
    The string returned when the user selects the 'Close' item
from the Window Manager menu.  If this flag is not set then the
string "dismiss" is returned.

---
message(m): string
    properties: create
    The message text appearing in the dialog.

---
messageAlign(ma): string
    properties: create
    Align the message left, center, or right.

---
parent(p): string
    properties: create
    Specify the parent window for the dialog.  The dialog will
be centered on this window and raise and lower with it's parent.
By default, the dialog is not parented to a particular window and
is simply centered on the screen.

---
scrollableField(sf): boolean
    properties: create
    By default a single line text field is used in the dialog.
Specify true for a multi-line scroll field.

---
style(st): string
    properties: create
    Specify the type of input expected in the input field.
Vaid input types are "integer" "float" "text".
If this flag is not specified, we assume the input type is "text".

---
text(tx): string
    properties: create, query
    The field text.

---
title(t): string
    properties: create
    The dialog title.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/promptDialog.html 
    """


def propModCtx(flaganimCurve: string, flaganimCurveFalloff: tuple[float, float], flaganimCurveParam: string, flagdirection: tuple[float, float, float], flagexists: boolean, flagimage1: string, flagimage2: string, flagimage3: string, flaglinear: float, flaglinearParam: tuple[float, float], flagnurbsCurve: string, flagpowerCutoff: float, flagpowerCutoffParam: tuple[float, float], flagpowerDegree: float, flagpowerDegreeParam: float, flagscript: string, flagscriptParam: string, flagtype: int, flagworldspace: boolean) -> string:
    """Synopsis:
---
---
 propModCtx(
string
    , [animCurve=string], [animCurveFalloff=[float, float]], [animCurveParam=string], [direction=[float, float, float]], [exists=boolean], [image1=string], [image2=string], [image3=string], [linear=float], [linearParam=[float, float]], [nurbsCurve=string], [powerCutoff=float], [powerCutoffParam=[float, float]], [powerDegree=float], [powerDegreeParam=float], [script=string], [scriptParam=string], [type=int], [worldspace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

propModCtx is undoable, queryable, and editable.


Example:
---
import maya.cmds as cmds

Edit type of propmod context.
cmds.propModCtx( 'PropMod', e=True, t=1 )

Activate propmod context.
cmds.setToolTo( 'PropMod' )

Change the type and dropoff.
cmds.propModCtx( 'PropMod', e=True, d=(0, 1, 0) )

---
Return:
---


    string: Name of the new context created

Flags:
---


---
animCurve(ac): string
    properties: create, query, edit
    Name of the anim curve to use as a drop-off curve.
Only the 0 -> side of the curve will be used and the distance
will be mapped to "seconds".  The profile of the curve will be
used as the profile for propmod function.

---
animCurveFalloff(acf): [float, float]
    properties: create, query, edit
    The profile of the curve will be used as the profile for propmod function in
both U and V. This will be scaled in U, V according to the paramters provided.
The ratio of the U, V scaling parameters will dictate the footprint of the fuction
while the curve itself provides the magnitudes.

---
animCurveParam(acp): string
    properties: create, query, edit
    Name of the anim curve to use as a drop-off curve.
Only the 0 -> side of the curve will be used and the distance
will be mapped to "seconds", where 1 second maps to 0.01 units
in parametric space.

---
direction(d): [float, float, float]
    properties: create, query, edit
    Direction along which to compute the distance for
the distance based drop-off functions.  The default is (1 1 1)

---
exists(ex): boolean
    properties: create
    Returns true or false depending upon whether the
specified object exists. Other flags are ignored.

---
image1(i1): string
    properties: create, query, edit
    First of three possible icons representing the tool
associated with the context.

---
image2(i2): string
    properties: create, query, edit
    Second of three possible icons representing the tool
associated with the context.

---
image3(i3): string
    properties: create, query, edit
    Third of three possible icons representing the tool
associated with the context.

---
linear(l): float
    properties: create, query, edit
    If using linear drop-off function, this is its
slope.  The default of -0.1 means the point at the locator
moves with it and the point 10 units away doesn't move at all.

---
linearParam(lp): [float, float]
    properties: create, query, edit
    If using parametric linear drop-off function, these specify
its limits along the U and V directions.

---
nurbsCurve(nc): string
    properties: create, query, edit
    Name of the nurbs curve to use as a drop-off curve.
The closest point distance would be used as the drop off percentage.

---
powerCutoff(pc): float
    properties: create, query, edit
    If using the power drop-off function, this is its
distance cutoff value.  The default is 10.0.

---
powerCutoffParam(pcp): [float, float]
    properties: create, query, edit
    If using the power drop-off function, these specify
one of it's limits, 0 for U, and 1 and V.  The default cutoff is 10.0.

---
powerDegree(pd): float
    properties: create, query, edit
    If using the power drop-off function, this is its
degree.  The default is 3.

---
powerDegreeParam(pdp): float
    properties: create, query, edit
    If using the power drop-off function, this is its
degree.  The default is 3.

---
script(s): string
    properties: create, query, edit
    The name of the script to use to compute the drop-off.
The script takes 6 floats as input - first 3 are the position of
the move locator, the next 3 the position of the point to be
manipulated.  The script should return a drop-off coefficient
which could be negative or zero.

---
scriptParam(sp): string
    properties: create, query, edit
    The name of the script to use to compute the drop-off.
The script takes 4 floats as input - first 2 are the parametric
position of the move locator, the next 2 the parametric position of
the point to be manipulated.  The script should return a drop-off coefficient
which could be negative or zero.

---
type(t): int
    properties: create, query, edit
    Choose the type for the drop-off function.  Legal
values are 1 for linear, 2 for power,
3 for script,
4 for anim curve.
The default is 1.

---
worldspace(ws): boolean
    properties: create, query, edit
    Set the space in which the tool works. True for
world space, false for parametric space.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/propModCtx.html 
    """


def propMove(flagpercent: float, flagpercentX: float, flagpercentY: float, flagpercentZ: float, flagpivot: tuple[float, float, float], flagrotate: tuple[angle, angle, angle], flagscale: tuple[float, float, float], flagtranslate: tuple[linear, linear, linear], flagworldSpace: boolean) -> None:
    """Synopsis:
---
---
 propMove(
[objects]
    , [percent=float], [percentX=float], [percentY=float], [percentZ=float], [pivot=[float, float, float]], [rotate=[angle, angle, angle]], [scale=[float, float, float]], [translate=[linear, linear, linear]], [worldSpace=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

propMove is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

cmds.propMove( 3, 6, 0, 'surface1', 'surface2', 'surface3', 'surface4', 'surface5', 'surface6', 'surface7', p=[0.1, 0.5, 0.7, 1.0, 0.7, 0.5, 0.1] )
This performs a proportional translate of (3,6,0) on seven surfaces.
Note that there are 7 "-p" flags, one for each surface.

cmds.propMove( 'surface1', 'surface2', 'surface3', 'surface4', 'surface5', 'surface6', 'surface7', p=[0.1, 0.5, 0.7, 1.0, 0.7, 0.5, 0.1], pivot=(1, 1, 1), s=(3, 3, 3) )
This performs a proportional scale of (3,3,3) on seven surfaces.
Note that there are 7 "-p" flags, one for each surface. The scale
happened about the specified pivot (1,1,1).

cmds.propMove( 'surface1', 'surface2', 'surface3', 'surface4', 'surface5', 'surface6', 'surface7', p=[0.1, 0.5, 0.7, 1.0, 0.7, 0.5, 0.1], r=(30, 60, 90) )
This performs a proportional rotate of (30,60,90) on seven surfaces.
Note that there are 7 "-p" flags, one for each surface.

cmds.propMove( 'surface1', 'surface2', 'surface3', 'surface4', 'surface5', 'surface6', 'surface7', px=[0.1, 0.5, 0.7, 1.0, 0.7, 0.5, 0.1], r=(30, 60, 90) )
This performs a proportional rotate of (30,60,90) on seven surfaces.
The percentages are only applied on the rotation 30 about the X axis. The
percentages along Y and Z are  1.0. Note that there are 7 "-px" flags, one
for each surface. The surfaces are rotated by 60, 90 in Y and Z.

---


Flags:
---


---
percent(p): float
    properties: create, multiuse
    The percentage effect that the specified x,y,z has on an object.
This flag must be specified once for each object, ie. if there
are 4 objects specified, there must be 4 "-p" flags, (otherwise
a percentage of 1.0 will be used).  This flag generally has a
range between 0.0 and 1.0, but can be any float value.

---
percentX(px): float
    properties: create, multiuse
    The percentage effect that the specified x has on an object.
This flag is specified one per object.
The value ranges between 0.0 and 1.0, but can be any float value.
If the -p flag has been specified, this flag usage is invalid.

---
percentY(py): float
    properties: create, multiuse
    The percentage effect that the specified y has on an object.
This flag is specified one per object.
The value ranges between 0.0 and 1.0, but can be any float value.
If the -p flag has been specified, this flag usage is invalid.

---
percentZ(pz): float
    properties: create, multiuse
    The percentage effect that the specified z has on an object.
This flag is specified one per object.
The value ranges between 0.0 and 1.0, but can be any float value.
If the -p flag has been specified, this flag usage is invalid.

---
pivot(pi): [float, float, float]
    properties: create
    Specify the pivot about which a rotation or scale will occur.
The change in pivot lasts only as long as the current 'propMove' command, and so
must be used in conjunction with one of the above move flags for any effect to be
noticeable.

---
rotate(r): [angle, angle, angle]
    properties: create
    Proportionally rotate each object by the given angles. The rotation values
are scaled by the percentage specified by that object's
corresponding "-percent" flag.
All angles are in degrees.
The rotation is about the pivot specified by the "-pivot" flag, or (0, 0, 0)
if the "-pivot" flag is not present.

---
scale(s): [float, float, float]
    properties: create
    Proportionally scale each object by the given amounts. The scale values
are scaled by the percentage specified by that object's
corresponding "-percent" flag.
The position and size of each object is measured relative to the pivot
specified by the "-pivot" flag, and defaults to each object's individual pivot.
In the case of control vertices, or some other object component, the
default is the parent object's pivot.

---
translate(t): [linear, linear, linear]
    properties: create
    Proportionally translate each object by the given amounts. The translation
values are scaled by the percentage specified by that object's
corresponding "-percent" flag.
The "-pivot" flag has no effect on translation.

---
worldSpace(ws): boolean
    properties: create
    Use worldspace for the calculations.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/propMove.html 
    """


def proximityWrap(flagaddDrivers: string, flagapplyUserDefaults: boolean, flagcanBeAdded: string, flagdriverIndices: boolean, flagdumpInfo: boolean, flagfreeDriverIndex: boolean, flagremoveDrivers: string) -> list[string]:
    """Synopsis:
---
---
 proximityWrap(
[objects]
    , [addDrivers=string], [applyUserDefaults=boolean], [canBeAdded=string], [driverIndices=boolean], [dumpInfo=boolean], [freeDriverIndex=boolean], [removeDrivers=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

proximityWrap is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

Add drivers to the proximityWrap
cmds.proximityWrap('proximityWrap1', edit=True, addDrivers=['driverShape1', 'driverShape2'])

Add driver to the proximityWrap and skip setting the initial attributes
cmds.proximityWrap('proximityWrap1', edit=True, applyUserDefaults=True, addDrivers=['driverShape2'])

Remove drivers
cmds.proximityWrap('proximityWrap1', edit=True, removeDrivers=['driverShape1', 'driverShape2')

List driver indices (returns [0, 1])
cmds.proximityWrap('proximityWrap1', query=True, driverIndices=True)

List free driver index (returns 2)
cmds.proximityWrap('proximityWrap1', query=True, freeDriverIndex=True)

Query can be added
cmds.proximityWrap('proximityWrap1', query=True, canBeAdded=['driverShape1'])

Dump info
cmds.proximityWrap('proximityWrap1', query=True, dumpInfo= proximityWrap1)

---
Return:
---


    list[string]: (the proximityWrap node name)

Flags:
---


---
addDrivers(ad): string
    properties: edit, multiuse
    Add connect new drivers to the proximityWrap node

---
applyUserDefaults(aud): boolean
    properties: edit
    Flag used in with the addDriver flag. When set, new drivers will set the
user default attributes from the option var settings. When the flag is not set,
the user default attributes will not be set.
Default is on.

---
canBeAdded(cba): string
    properties: query, multiuse
    Returns true if all listed shapes can be added as drivers. The reason for an item
returning false would be that it is already connected as a driver, it is connected
as the deformed geometry or it represents in invalid object.

---
driverIndices(di): boolean
    properties: query
    List connected driver indices

---
dumpInfo(dui): boolean
    properties: query
    Return a python dictionary containing information relating to the proximityWrap
node. Some information is returned in string form in mel but the flag is meant to be used
in python.

---
freeDriverIndex(fdi): boolean
    properties: query
    Returns the first index which has no driver connected

---
removeDrivers(rd): string
    properties: edit, multiuse
    Remove connected drivers

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/proximityWrap.html 
    """


def psdChannelOutliner(flagaddChild: tuple[string, string], flagallItems: boolean, flagannotation: string, flagbackgroundColor: tuple[float, float, float], flagdefineTemplate: string, flagdocTag: string, flagdoubleClickCommand: string, flagdragCallback: script, flagdropCallback: script, flagenable: boolean, flagenableBackground: boolean, flagenableKeyboardFocus: boolean, flagexists: boolean, flagfullPathName: boolean, flagheight: int, flaghighlightColor: tuple[float, float, float], flagisObscured: boolean, flagmanage: boolean, flagnoBackground: boolean, flagnumberOfItems: boolean, flagnumberOfPopupMenus: boolean, flagparent: string, flagpopupMenuArray: boolean, flagpreventOverride: boolean, flagpsdParent: string, flagremoveAll: boolean, flagremoveChild: string, flagselect: string, flagselectCommand: string, flagselectItem: boolean, flagstatusBarMessage: string, flaguseTemplate: string, flagvisible: boolean, flagvisibleChangeCommand: script, flagwidth: int) -> string:
    """Synopsis:
---
---
 psdChannelOutliner(
string
    , [addChild=[string, string]], [allItems=boolean], [annotation=string], [backgroundColor=[float, float, float]], [defineTemplate=string], [docTag=string], [doubleClickCommand=string], [dragCallback=script], [dropCallback=script], [enable=boolean], [enableBackground=boolean], [enableKeyboardFocus=boolean], [exists=boolean], [fullPathName=boolean], [height=int], [highlightColor=[float, float, float]], [isObscured=boolean], [manage=boolean], [noBackground=boolean], [numberOfItems=boolean], [numberOfPopupMenus=boolean], [parent=string], [popupMenuArray=boolean], [preventOverride=boolean], [psdParent=string], [removeAll=boolean], [removeChild=string], [select=string], [selectCommand=string], [selectItem=boolean], [statusBarMessage=string], [useTemplate=string], [visible=boolean], [visibleChangeCommand=script], [width=int])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

psdChannelOutliner is undoable, queryable, and editable.



Example:
---
import maya.cmds as cmds

cmds.window()
cmds.formLayout()
cmds.psdChannelOutliner('materialList', height=175, psdParent='lambert1',
                        addChild=(('color', ''), ('diffuse', ''), ('transparency', '')) )
cmds.showWindow()

---
Return:
---


    string: The full name of the psdChannelOutliner control

Flags:
---


---
addChild(ach): [string, string]
    properties: edit, multiuse
    This flag should be used along with the "-psdParent/ppa" flag. A string
item gets added as a child to the parent specifed with "-psdParent/ppa"
flag. The next string assigns an associated image name.

---
allItems(all): boolean
    properties: query
    Returns all the items in the form parent.child.

---
annotation(ann): string
    properties: create, query, edit
    Annotate the control with an extra string value.

---
backgroundColor(bgc): [float, float, float]
    properties: create, query, edit
    The background color of the control. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0.
When setting backgroundColor, the background is automatically
enabled, unless enableBackground is also specified with a false
value.

---
defineTemplate(dt): string
    properties: create
    Puts the command in a mode where any other flags and arguments are
parsed and added to the command template specified in the argument.
They will be used as default arguments in any subsequent
invocations of the command when templateName is set as the
current template.

---
docTag(dtg): string
    properties: create, query, edit
    Add a documentation flag to the control.  The documentation flag
has a directory structure.
(e.g., -dt render/multiLister/createNode/material)

---
doubleClickCommand(dcc): string
    properties: create, edit
    Specify the command to be executed when an item is double
clicked.

---
dragCallback(dgc): script
    properties: create, edit
    Adds a callback that is called when the middle mouse button
is pressed.  The MEL version of the callback is of the form:

global proc string[] callbackName(string $dragControl, int $x, int $y, int $mods)

The proc returns a string array that is transferred to the drop site.
By convention the first string in the array describes the user settable
message type.  Controls that are application defined drag sources may
ignore the callback. $mods allows testing for the key modifiers CTRL and
SHIFT. Possible values are 0 == No modifiers, 1 == SHIFT, 2 == CTRL,
3 == CTRL + SHIFT.

In Python, it is similar, but there are two ways to specify the callback.  The
recommended way is to pass a Python function object as the argument.  In that
case, the Python callback should have the form:

def callbackName( dragControl, x, y, modifiers ):

The values of these arguments are the same as those for the MEL version above.

The other way to specify the callback in Python is to specify a string to be
executed.  In that case, the string will have the values substituted into it
via the standard Python format operator.  The format values are passed in a
dictionary with the keys "dragControl", "x", "y", "modifiers".  The
"dragControl" value is a string and the other values are integers (eg the
callback string could be "print '%(dragControl)s %(x)d %(y)d %(modifiers)d'")

---
dropCallback(dpc): script
    properties: create, edit
    Adds a callback that is called when a drag and drop
operation is released above the drop site.  The MEL version of the callback is
of the form:

global proc callbackName(string $dragControl, string $dropControl, string $msgs[], int $x, int $y, int $type)

The proc receives a string array that is transferred from the drag source.
The first string in the msgs array describes the user defined message type.
Controls that are application defined drop sites may ignore the
callback. $type can have values of 1 == Move, 2 == Copy, 3 == Link.

In Python, it is similar, but there are two ways to specify the callback.  The
recommended way is to pass a Python function object as the argument.  In that
case, the Python callback should have the form:

def pythonDropTest( dragControl, dropControl, messages, x, y, dragType ):

The values of these arguments are the same as those for the MEL version above.

The other way to specify the callback in Python is to specify a string to be
executed.  In that case, the string will have the values substituted into it
via the standard Python format operator.  The format values are passed in a
dictionary with the keys "dragControl", "dropControl", "messages", "x", "y",
"type".  The "dragControl" value is a string and the other values are integers
(eg the callback string could be
"print '%(dragControl)s %(dropControl)s %(messages)r %(x)d %(y)d %(type)d'")

---
enable(en): boolean
    properties: create, query, edit
    The enable state of the control.  By default, this flag is
set to true and the control is enabled.  Specify false and the control
will appear dimmed or greyed-out indicating it is disabled.

---
enableBackground(ebg): boolean
    properties: create, query, edit
    Enables the background color of the control.

---
enableKeyboardFocus(ekf): boolean
    properties: create, query, edit
    If enabled, the user can navigate to the control with the tab key and select values with the keyboard or mouse.
This flag would typically be used to turn off focus support from controls that get it by default, like Edit and List controls.
If disabled, text in text fields can still be selected with the mouse but cannot be copied (except on Linux when "Middle Click Paste" is enabled).

---
exists(ex): boolean
    properties: create
    Returns whether the
specified object exists or not. Other flags are ignored.

---
fullPathName(fpn): boolean
    properties: query
    Return the full path name of the widget, which includes all the parents.

---
height(h): int
    properties: create, query, edit
    The height of the control.  The control will attempt to
be this size if it is not overruled by parent layout conditions.

---
highlightColor(hlc): [float, float, float]
    properties: create, query, edit
    The highlight color of the control. The arguments correspond
to the red, green, and blue color components. Each component ranges
in value from 0.0 to 1.0.

---
isObscured(io): boolean
    properties: query
    Return whether the control can actually be seen by the user.
The control will be obscured if its state is invisible, if it is
blocked (entirely or partially) by some other control, if it or a
parent layout is unmanaged, or if the control's window is
invisible or iconified.

---
manage(m): boolean
    properties: create, query, edit
    Manage state of the control.  An unmanaged control is
not visible, nor does it take up any screen real estate.  All
controls are created managed by default.

---
noBackground(nbg): boolean
    properties: create, edit
    Clear/reset the control's background.
Passing true means the background should not be drawn at all, false means the background should be drawn.  The state of this flag is inherited by children of this control.

---
numberOfItems(ni): boolean
    properties: query
    Total number of items in the control.

---
numberOfPopupMenus(npm): boolean
    properties: query
    Return the number of popup menus attached to this control.

---
parent(p): string
    properties: create, query
    The parent layout for this control.

---
popupMenuArray(pma): boolean
    properties: query
    Return the names of all the popup menus attached to this
control.

---
preventOverride(po): boolean
    properties: create, query, edit
    If true, this flag prevents overriding the control's
attribute via the control's right mouse button menu.

---
psdParent(ppa): string
    properties: edit
    Adds an item string to the controls which is treated as parent.

---
removeAll(ra): boolean
    properties: edit
    Removes all the items from the control.

---
removeChild(rc): string
    properties: edit, multiuse
    Deletes the particular child of the parent as specifed in "-psdParent/ppa"
flag.

---
select(sel): string
    properties: edit
    Select the named item.

---
selectCommand(sc): string
    properties: create, edit
    Specify the command to be executed when an item is selected.

---
selectItem(si): boolean
    properties: query
    Returns the selected items.

---
statusBarMessage(sbm): string
    properties: create, edit
    Extra string to display in the status bar when the mouse is over the control.

---
useTemplate(ut): string
    properties: create
    Forces the command to use a command template other than
the current one.

---
visible(vis): boolean
    properties: create, query, edit
    The visible state of the control.  A control is created
visible by default.  Note that a control's actual appearance is
also dependent on the visible state of its parent layout(s).

---
visibleChangeCommand(vcc): script
    properties: create, query, edit
    Command that gets executed when visible state of the control changes.

---
width(w): int
    properties: create, query, edit
    The width of the control.  The control will attempt to
be this size if it is not overruled by parent layout conditions.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/psdChannelOutliner.html 
    """


def psdEditTextureFile(flagaddChannel: string, flagaddChannelColor: tuple[string, float, float, float], flagaddChannelImage: tuple[string, string], flagdeleteChannel: string, flagpsdFileName: string, flagsnapShotImage: string, flaguvSnapPostionTop: boolean) -> None:
    """Synopsis:
---
---
 psdEditTextureFile([addChannel=string], [addChannelColor=[string, float, float, float]], [addChannelImage=[string, string]], [deleteChannel=string], [psdFileName=string], [snapShotImage=string], [uvSnapPostionTop=boolean])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

psdEditTextureFile is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

Create a Photoshop file with an image layer from a disk image file
cmds.psdTextureFile(xr=512, yr=512, ifn=('C:\\tex.jpg', 'layerSet1', 1), psf='C:\\final.psd')
// Saved file: C:\final.psd ---


Create a poly plane
cmds.polyPlane(w=10, h=10, sx=10, sy=10, n='pPlane1')
cmds.select('pPlane1')

Create a snapshot file containing the UVs of pPlane1
cmds.uvSnapshot(n='C:\\uvSnapshot.iff', xr=512, yr=512, o=True)
// Saved file: C:\uvSnapshot.iff ---


Edit the "final.psd" file which we have created, add a UV snapshot layer from snapshot file and an image layer from disk image file
cmds.psdEditTextureFile(aci=('layerSet2', 'C:\\tex1.jpg'), ssi='C:\\uvSnapshot.iff', uvt=1, psf='C:\\final.psd')

---


Flags:
---


---
addChannel(adc): string
    properties: create, multiuse
    Adds an empty layer set with the given name to a already existing PSD file.

---
addChannelColor(acc): [string, float, float, float]
    properties: create, multiuse
    (M) Specifies the filled color of  the layer which is created in a layer set given
by the layer name.

---
addChannelImage(aci): [string, string]
    properties: create, multiuse
    (M) Specifies the image file name whose image needs to be added
as a layer to a given layer set which is the first string.

---
deleteChannel(deleteChannel): string
    properties: create, multiuse
    (M) Deletes the channels (layer sets) from a PSD file. This is a multiuse
flag.

---
psdFileName(psf): string
    properties: create
    PSD file name.

---
snapShotImage(ssi): string
    properties: create
    Image file name on the disk containing UV snapshot / reference image.

---
uvSnapPostionTop(uvt): boolean
    properties: create
    Specifies the position of UV snapshot image layer  in the PSD file. "True"
positions this layer at the top and "False" positions the layer at the bottom
next to the background layer in the PSD file

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/psdEditTextureFile.html 
    """


def psdExport(flagalphaChannelIdx: int, flagbytesPerChannel: int, flagemptyLayerSet: boolean, flagformat: string, flaglayerName: string, flaglayerSetName: string, flagoutFileName: string, flagpreMultiplyAlpha: boolean, flagpsdFileName: string) -> None:
    """Synopsis:
---
---
 psdExport([alphaChannelIdx=int], [bytesPerChannel=int], [emptyLayerSet=boolean], [format=string], [layerName=string], [layerSetName=string], [outFileName=string], [preMultiplyAlpha=boolean], [psdFileName=string])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

psdExport is NOT undoable, queryable, and NOT editable.


Example:
---
import maya.cmds as cmds

Write the layer set 1 of psd file as 16 bit tif file
cmds.psdExport( ifn='/tmp/test.psd', ofn='/tmp/test.set1.tif', lsn='Set 1', format='tif', bpc=2 )

Query if the layer set "Set 2" is empty.
cmds.psdExport( ifn='/tmp/test.psd', lsn='Set 2', q=True, els=True )

---


Flags:
---


---
alphaChannelIdx(aci): int
    properties: create, query
    Index of the alpha channel to output, if not supplied, writes out the
default alpha channel.  The index is zero based.
This is useful to write out specific alpha channels available as
"Additional Alpha Channels" of Photoshop.

---
bytesPerChannel(bpc): int
    properties: create, query
    Output file depth. Any of these keyword:

0 for choosing depth based on input
1 for 8 bits per channel
2 for 16 bits per channel

Default is 0.

---
emptyLayerSet(els): boolean
    properties: create, query
    Option to check if the given layer set is empty or not.  This should be
used in query mode and input file name and layer set names should be specified.

---
format(format): string
    properties: create, query
    Output file format. Any of these keyword: "iff", "sgi", "pic", "tif", "als", "gif", "rla", "jpg"
Default is iff.

---
layerName(lyn): string
    properties: create, query
    Name of the layer to output.

---
layerSetName(lsn): string
    properties: create, query
    Name of the layer set to output, if not supplied, writes out the Composite image.
                        In query mode, this flag needs a value.

---
outFileName(ofn): string
    properties: create, query
    Name(with path) of the output file.

---
preMultiplyAlpha(pma): boolean
    properties: create, query
    Option to multiply RGB colors with alpha values.  If (r,g,b,a) is the
value of pixel, it will be changed to (r*a, g*a, b*a, a) when this flag
is used.

---
psdFileName(ifn): string
    properties: create, query
    Name(with path) of the input Photoshop file.
                        In query mode, this flag needs a value.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/psdExport.html 
    """


def psdTextureFile(flagchannelRGB: tuple[string, uint, uint, uint, uint], flagchannels: tuple[string, uint, boolean], flagimageFileName: tuple[string, string, uint], flagpsdFileName: string, flagsnapShotImageName: string, flaguvSnapPostionTop: boolean, flagxResolution: uint, flagyResolution: uint) -> None:
    """Synopsis:
---
---
 psdTextureFile([channelRGB=[string, uint, uint, uint, uint]], [channels=[string, uint, boolean]], [imageFileName=[string, string, uint]], [psdFileName=string], [snapShotImageName=string], [uvSnapPostionTop=boolean], [xResolution=uint], [yResolution=uint])  
Note: Strings representing object names and arguments must be separated by commas. This is not depicted in the synopsis.

psdTextureFile is undoable, NOT queryable, and NOT editable.



Example:
---
import maya.cmds as cmds

Create a poly plane
cmds.polyPlane(w=10, h=10, sx=10, sy=10, n='pPlane1')
cmds.select('pPlane1')

Create a snapshot file containing the UVs of pPlane1
cmds.uvSnapshot(n='C:\\uvSnapshot.iff', xr=512, yr=512, o=True)
// Saved file: C:\uvSnapshot.iff ---


Create a Photoshop file containing a UV snapshot layer from UV snapshot file we have just created and an image layer from a disk image file
cmds.psdTextureFile(xr=512, yr=512, ifn=('C:\\tex.jpg', 'layerSet1', 1), ssi='C:\\uvSnapshot.iff', uvt=1, psf='C:\\final.psd')
// Saved file: C:\final.psd ---


---


Flags:
---


---
channelRGB(chc): [string, uint, uint, uint, uint]
    properties: create, multiuse
    (M) Layer set names, index, red, green and blue values are given as input.
Using this flag, the layers created can be filled with specified
colors.  This is a multi use flag.  The index specifies the
placement order of layer sets in the created file.

---
channels(chs): [string, uint, boolean]
    properties: create, multiuse
    (M) Layer set names and index are given as input. This is a multi use flag.
A layer set with the given name will be created.  The second argument
is the index which specifies the placement order of layer sets
in the created file. The third argument is a boolean, if "true" a layer
is created inside the layer set , "false" creates an  empty layer set

---
imageFileName(ifn): [string, string, uint]
    properties: create, multiuse
    Image file name, Layerset name and index.  The image in the file will be
transferred to layer set specified.  The index specifies the
placement order of layer sets in the created psd file.  The image file
specified can be in any of the formats supported by maya
(ex. iff, jpg, gif, tif etc.)

---
psdFileName(psf): string
    properties: create
    PSD file name.

---
snapShotImageName(ssi): string
    properties: create
    Image file name on the disk containing UV snapshot / reference image.

---
uvSnapPostionTop(uvt): boolean
    properties: create
    Specifies the position of UV snapshot image layer  in the PSD file. "True"
positions this layer at the top and "False" positions the layer at the bottom
next to the background layer in the PSD file

---
xResolution(xr): uint
    properties: create
    X - resolution of the image.

---
yResolution(yr): uint
    properties: create
    Y - resolution of the image.

URL:
---
https://help.autodesk.com/cloudhelp/2024/ENU/Maya-Tech-Docs/CommandsPython/psdTextureFile.html 
    """
